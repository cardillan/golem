  1480 instructions before optimizations.
    41 instructions eliminated by Temp Variables Elimination (2 passes, 7 iterations).
   258 instructions eliminated by Dead Code Elimination (8 iterations).
     7 instructions eliminated by Jump Normalization (2 passes, 7 iterations).
   125 instructions eliminated by Condition Optimization (2 passes, 9 iterations).
   107 instructions eliminated by Single Step Elimination (4 passes, 11 iterations).
     2 instructions eliminated by Boolean Optimization (8 iterations).
       2 final jumps of a short-circuited expression optimized.
     4 instructions eliminated by If Expression Optimization (2 passes, 4 iterations).
    89 instructions eliminated by Data Flow Optimization (4 passes, 17 iterations).
     2 instructions added by Loop Rotation (4 iterations).
       3 loop conditions were partially rotated.
   158 instructions added by Loop Unrolling (8 iterations).
     2 loops unrolled by Loop Unrolling.
    46 instructions eliminated by Jump Straightening (3 passes, 10 iterations).
    33 instructions updated by Jump Threading.
    19 instructions eliminated by Unreachable Code Elimination (2 passes, 3 iterations).
    56 instructions eliminated by Print Merging.
   886 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 230):
    Partial loop rotation at line 54:5                           size    +1, benefit       25.0, efficiency     25.000
    Partial loop rotation at line 119:5                          size    +1, benefit       25.0, efficiency     25.000
  * Unroll iteration loop at line 169:9                          size    +5, benefit      375.0, efficiency     75.000 (+3 instructions)
    Unroll iteration loop at line 201:9                          size  +197, benefit      375.0, efficiency      1.904

Pass 1: speed optimization selection (cost limit 227):
  * Partial loop rotation at line 54:5                           size    +1, benefit       25.0, efficiency     25.000 (+1 instructions)
    Partial loop rotation at line 119:5                          size    +1, benefit       25.0, efficiency     25.000
    Unroll iteration loop at line 201:9                          size  +197, benefit      375.0, efficiency      1.904

Pass 1: speed optimization selection (cost limit 226):
  * Partial loop rotation at line 119:5                          size    +1, benefit       25.0, efficiency     25.000 (+1 instructions)
    Unroll iteration loop at line 201:9                          size  +197, benefit      375.0, efficiency      1.904

Pass 1: speed optimization selection (cost limit 225):
  * Unroll iteration loop at line 201:9                          size  +197, benefit      375.0, efficiency      1.904 (+147 instructions)

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-173 instructions):
 
    37 label *label17
    38 jump *label15 equal :locateCore*retval false
    39 jump *label1 always
-    * set *tmp2 null
    40 jump *label16 always
    41 label *label15
-    * set *tmp2 null
    42 label *label16
    43 label *label9
    44 multijump *tmp1 0 0 (m:marker0)
 
   120 label *label40
   121 set *tmp28 null
   122 label *label41
-    * set *tmp26 *tmp28
   123 jump *label37 always
   124 label *label36
   125 set *tmp29 :areUnitsAvailable:occupied
   126 op add :areUnitsAvailable:occupied :areUnitsAvailable:occupied 1
-    * set *tmp26 *tmp29
   127 label *label37
   128 ubind :areUnitsAvailable:type
   129 label *label34
 
   135 jump *label35 equal *tmp32 false
   136 jump *label33 always
   137 label *label35
-    * set *tmp12 null
   138 jump *label29 always
   139 label *label28
-    * set *tmp12 null
   140 label *label29
   141 jump *label43 equal :areUnitsAvailable:output false
   142 print :areUnitsAvailable:type
 
   150 jump *label45 equal *tmp34 false
   151 print ", needed: "
   152 print :areUnitsAvailable:needed
-    * set *tmp35 null
   153 jump *label46 always
   154 label *label45
-    * set *tmp35 null
   155 label *label46
   156 print "\n"
-    * set *tmp33 null
   157 jump *label44 always
   158 label *label43
-    * set *tmp33 null
   159 label *label44
   160 set *tmp10 false
   161 jump *label27 always
 
   164 jump *label25 equal *tmp10 false
   165 set *tmp9 UNIT_TYPE
   166 jump *label21 always
-    * set *tmp36 null
   167 jump *label26 always
   168 label *label25
-    * set *tmp36 null
   169 label *label26
   170 set :chooseUnitType:type @flare
   171 setaddr *tmp37 *label50
 
   233 label *label71
   234 set *tmp58 null
   235 label *label72
-    * set *tmp56 *tmp58
   236 jump *label68 always
   237 label *label67
   238 set *tmp59 :areUnitsAvailable.1:occupied
   239 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
-    * set *tmp56 *tmp59
   240 label *label68
   241 ubind :areUnitsAvailable.1:type
   242 label *label65
 
   248 jump *label66 equal *tmp62 false
   249 jump *label64 always
   250 label *label66
-    * set *tmp42 null
   251 jump *label60 always
   252 label *label59
-    * set *tmp42 null
   253 label *label60
   254 jump *label74 equal :areUnitsAvailable.1:output false
   255 print :areUnitsAvailable.1:type
 
   263 jump *label76 equal *tmp64 false
   264 print ", needed: "
   265 print :areUnitsAvailable.1:needed
-    * set *tmp65 null
   266 jump *label77 always
   267 label *label76
-    * set *tmp65 null
   268 label *label77
   269 print "\n"
-    * set *tmp63 null
   270 jump *label75 always
   271 label *label74
-    * set *tmp63 null
   272 label *label75
   273 set *tmp40 false
   274 jump *label58 always
 
   283 label *label56
   284 set *tmp66 null
   285 label *label57
-    * set *tmp39 *tmp66
   286 jump *label55 always
   287 label *label54
-    * set *tmp39 null
   288 label *label55
   289 label *label48
   290 multijump *tmp37 0 0 (m:marker1)
 
   309 op equal *tmp68 :rebindUnits:firstUnit null
   310 jump *label79 equal *tmp68 false
   311 end
-    * set *tmp69 null
   312 jump *label80 always
   313 label *label79
-    * set *tmp69 null
   314 label *label80
   315 label *label81
   316 sensor *tmp70 @unit @controller
   317 op equal *tmp71 *tmp70 @this
   318 jump *label84 equal *tmp71 false
-    * set *tmp73 :rebindUnits:count
   319 op add :rebindUnits:count :rebindUnits:count 1
   320 ucontrol flag 1
   321 set .UNIT_S2 .UNIT_P2
 
   331 label *label86
   332 set *tmp76 null
   333 label *label87
-    * set *tmp72 *tmp76
   334 jump *label85 always
   335 label *label84
-    * set *tmp72 null
   336 label *label85
   337 ubind .TYPE
   338 label *label82
 
   344 jump *label83 equal *tmp79 false
   345 jump *label81 always
   346 label *label83
-    * set *tmp67 :rebindUnits:count
   347 jump *label78 always
-    * set *tmp67 null
   348 label *label78
   349 set :acquireUnit:currentUnit .UNIT_S1
   350 set :rebindUnit:currentUnit :acquireUnit:currentUnit
 
   357 op equal *tmp87 *tmp86 @this
   358 op land *tmp88 *tmp85 *tmp87
   359 jump *label93 equal *tmp88 false
-    * set *tmp81 :rebindUnit:currentUnit
   360 jump *label90 always
   361 set *tmp89 null
   362 jump *label94 always
   363 label *label93
   364 set *tmp89 null
   365 label *label94
-    * set *tmp83 *tmp89
   366 jump *label92 always
   367 label *label91
-    * set *tmp83 null
   368 label *label92
   369 ubind .TYPE
   370 set :rebindUnit:firstUnit @unit
 
   374 sensor *tmp92 @unit @controlled
   375 op equal *tmp93 *tmp92 0
   376 jump *label100 equal *tmp93 false
-    * set *tmp81 @unit
   377 jump *label90 always
-    * set *tmp94 null
   378 jump *label101 always
   379 label *label100
-    * set *tmp94 null
   380 label *label101
   381 ubind .TYPE
   382 label *label98
 
   388 jump *label99 equal *tmp97 false
   389 jump *label97 always
   390 label *label99
-    * set *tmp91 null
   391 jump *label96 always
   392 label *label95
-    * set *tmp91 null
   393 label *label96
   394 end
-    * set *tmp81 null
   395 label *label90
   396 ucontrol flag 1
   397 set *tmp80 @unit
 
   410 op equal *tmp105 *tmp104 @this
   411 op land *tmp106 *tmp103 *tmp105
   412 jump *label107 equal *tmp106 false
-    * set *tmp99 :rebindUnit.1:currentUnit
   413 jump *label104 always
   414 set *tmp107 null
   415 jump *label108 always
   416 label *label107
   417 set *tmp107 null
   418 label *label108
-    * set *tmp101 *tmp107
   419 jump *label106 always
   420 label *label105
-    * set *tmp101 null
   421 label *label106
   422 ubind .TYPE
   423 set :rebindUnit.1:firstUnit @unit
 
   427 sensor *tmp110 @unit @controlled
   428 op equal *tmp111 *tmp110 0
   429 jump *label114 equal *tmp111 false
-    * set *tmp99 @unit
   430 jump *label104 always
-    * set *tmp112 null
   431 jump *label115 always
   432 label *label114
-    * set *tmp112 null
   433 label *label115
   434 ubind .TYPE
   435 label *label112
 
   441 jump *label113 equal *tmp115 false
   442 jump *label111 always
   443 label *label113
-    * set *tmp109 null
   444 jump *label110 always
   445 label *label109
-    * set *tmp109 null
   446 label *label110
   447 end
-    * set *tmp99 null
   448 label *label104
   449 ucontrol flag 1
   450 set *tmp98 @unit
 
   469 label *label121
   470 set .UNIT_S1 :swap:a
   471 set .UNIT_P1 :swap:b
-    * set *tmp120 null
   472 jump *label118 always
   473 label *label117
-    * set *tmp120 null
   474 label *label118
   475 sensor *tmp121 .UNIT_S1 @itemCapacity
   476 set .UNIT_CAPACITY *tmp121
 
   481 op strictEqual *tmp124 .SPEED null
   482 jump *label122 equal *tmp124 false
   483 stop
-    * set *tmp125 null
   484 jump *label123 always
   485 label *label122
-    * set *tmp125 null
   486 label *label123
   487 set :needsFourUnits.2:unit .UNIT_S1
   488 op sub *tmp127 .DOME_X .CORE_X
 
   510 op equal *tmp142 *tmp141 @this
   511 op land *tmp143 *tmp140 *tmp142
   512 jump *label131 equal *tmp143 false
-    * set *tmp136 :rebindUnit.2:currentUnit
   513 jump *label128 always
   514 set *tmp144 null
   515 jump *label132 always
   516 label *label131
   517 set *tmp144 null
   518 label *label132
-    * set *tmp138 *tmp144
   519 jump *label130 always
   520 label *label129
-    * set *tmp138 null
   521 label *label130
   522 ubind .TYPE
   523 set :rebindUnit.2:firstUnit @unit
 
   527 sensor *tmp147 @unit @controlled
   528 op equal *tmp148 *tmp147 0
   529 jump *label138 equal *tmp148 false
-    * set *tmp136 @unit
   530 jump *label128 always
-    * set *tmp149 null
   531 jump *label139 always
   532 label *label138
-    * set *tmp149 null
   533 label *label139
   534 ubind .TYPE
   535 label *label136
 
   541 jump *label137 equal *tmp152 false
   542 jump *label135 always
   543 label *label137
-    * set *tmp146 null
   544 jump *label134 always
   545 label *label133
-    * set *tmp146 null
   546 label *label134
   547 end
-    * set *tmp136 null
   548 label *label128
   549 ucontrol flag 1
   550 set *tmp135 @unit
 
   563 op equal *tmp160 *tmp159 @this
   564 op land *tmp161 *tmp158 *tmp160
   565 jump *label145 equal *tmp161 false
-    * set *tmp154 :rebindUnit.3:currentUnit
   566 jump *label142 always
   567 set *tmp162 null
   568 jump *label146 always
   569 label *label145
   570 set *tmp162 null
   571 label *label146
-    * set *tmp156 *tmp162
   572 jump *label144 always
   573 label *label143
-    * set *tmp156 null
   574 label *label144
   575 ubind .TYPE
   576 set :rebindUnit.3:firstUnit @unit
 
   580 sensor *tmp165 @unit @controlled
   581 op equal *tmp166 *tmp165 0
   582 jump *label152 equal *tmp166 false
-    * set *tmp154 @unit
   583 jump *label142 always
-    * set *tmp167 null
   584 jump *label153 always
   585 label *label152
-    * set *tmp167 null
   586 label *label153
   587 ubind .TYPE
   588 label *label150
 
   594 jump *label151 equal *tmp170 false
   595 jump *label149 always
   596 label *label151
-    * set *tmp164 null
   597 jump *label148 always
   598 label *label147
-    * set *tmp164 null
   599 label *label148
   600 end
-    * set *tmp154 null
   601 label *label142
   602 ucontrol flag 1
   603 set *tmp153 @unit
 
   622 label *label159
   623 set .UNIT_S1 :swap.1:a
   624 set .UNIT_P2 :swap.1:b
-    * set *tmp175 null
   625 jump *label156 always
   626 label *label155
-    * set *tmp175 null
   627 label *label156
   628 sensor *tmp176 .UNIT_S2 @firstItem
   629 op equal *tmp177 *tmp176 @phase-fabric
 
   642 label *label164
   643 set .UNIT_S2 :swap.2:a
   644 set .UNIT_P2 :swap.2:b
-    * set *tmp180 null
   645 jump *label161 always
   646 label *label160
-    * set *tmp180 null
   647 label *label161
   648 set .GROUP1 "unit  1"
   649 set .GROUP2 "unit 2"
-    * set *tmp134 .GROUP2
   650 jump *label126 always
   651 label *label125
   652 ubind .UNIT_S2
 
   656 ucontrol unbind
   657 set .UNIT_P2 null
   658 set .GROUP1 "unit"
-    * set *tmp134 .GROUP1
   659 label *label126
   660 op equal *tmp181 .FOUR_UNITS false
   661 jump *label167 notEqual *tmp181 false
 
   713 print "["
   714 print "]"
   715 print "\n"
-    * set *tmp195 null
   716 jump *label178 always
   717 label *label177
   718 print "  dome:  [coral]"
 
   720 print "["
   721 print "]"
   722 print "\n"
-    * set *tmp195 null
   723 label *label178
   724 label *label176
   725 set :processUnit:unit .UNIT_S1
 
   736 op equal *tmp202 *tmp201 @this
   737 op land *tmp203 *tmp200 *tmp202
   738 jump *label183 equal *tmp203 false
-    * set *tmp196 :rebindUnit.4:currentUnit
   739 jump *label180 always
   740 set *tmp204 null
   741 jump *label184 always
   742 label *label183
   743 set *tmp204 null
   744 label *label184
-    * set *tmp198 *tmp204
   745 jump *label182 always
   746 label *label181
-    * set *tmp198 null
   747 label *label182
   748 ubind .TYPE
   749 set :rebindUnit.4:firstUnit @unit
 
   753 sensor *tmp207 @unit @controlled
   754 op equal *tmp208 *tmp207 0
   755 jump *label190 equal *tmp208 false
-    * set *tmp196 @unit
   756 jump *label180 always
-    * set *tmp209 null
   757 jump *label191 always
   758 label *label190
-    * set *tmp209 null
   759 label *label191
   760 ubind .TYPE
   761 label *label188
 
   767 jump *label189 equal *tmp212 false
   768 jump *label187 always
   769 label *label189
-    * set *tmp206 null
   770 jump *label186 always
   771 label *label185
-    * set *tmp206 null
   772 label *label186
   773 end
-    * set *tmp196 null
   774 label *label180
   775 sensor *tmp213 @unit @flag
   776 set :processUnit:state *tmp213
 
   811 label *label200
   812 set *tmp219 *tmp222
   813 label *label198
-    * set *tmp216 *tmp219
   814 jump *label194 always
   815 label *label193
-    * set *tmp216 null
   816 label *label194
   817 op equal *tmp225 :processUnit:state 2
   818 jump *label203 equal *tmp225 false
 
   845 set :processUnit:distance *tmp238
   846 set *tmp228 :processUnit:distance
   847 label *label206
-    * set *tmp226 *tmp228
   848 jump *label204 always
   849 label *label203
-    * set *tmp226 null
   850 label *label204
   851 op equal *tmp239 :processUnit:state 3
   852 jump *label209 equal *tmp239 false
 
   855 jump *label213 equal :processUnit:supply false
   856 ucontrol itemDrop .DOME .UNIT_CAPACITY
   857 set .MSG ", supplying\n"
-    * set *tmp243 .MSG
   858 jump *label214 always
   859 label *label213
   860 ucontrol approach .DOME_X .DOME_Y 6
   861 set .MSG ", waiting\n"
-    * set *tmp243 .MSG
   862 label *label214
   863 sensor *tmp244 @unit @totalItems
   864 op lessThanEq *tmp245 *tmp244 0
 
   885 set :processUnit:distance *tmp253
   886 set *tmp242 :processUnit:distance
   887 label *label212
-    * set *tmp240 *tmp242
   888 jump *label210 always
   889 label *label209
-    * set *tmp240 null
   890 label *label210
   891 ucontrol flag :processUnit:state
   892 sensor *tmp254 @unit @totalItems
 
   906 print "["
   907 print "] sec"
   908 print "\n"
-    * set *tmp256 null
   909 jump *label218 always
   910 label *label217
   911 print .MSG
-    * set *tmp256 .MSG
   912 label *label218
   913 set *tmp257 @unit
   914 set :processUnit:unit *tmp257
 
   930 op equal *tmp266 *tmp265 @this
   931 op land *tmp267 *tmp264 *tmp266
   932 jump *label225 equal *tmp267 false
-    * set *tmp260 :rebindUnit.5:currentUnit
   933 jump *label222 always
   934 set *tmp268 null
   935 jump *label226 always
   936 label *label225
   937 set *tmp268 null
   938 label *label226
-    * set *tmp262 *tmp268
   939 jump *label224 always
   940 label *label223
-    * set *tmp262 null
   941 label *label224
   942 ubind .TYPE
   943 set :rebindUnit.5:firstUnit @unit
 
   947 sensor *tmp271 @unit @controlled
   948 op equal *tmp272 *tmp271 0
   949 jump *label232 equal *tmp272 false
-    * set *tmp260 @unit
   950 jump *label222 always
-    * set *tmp273 null
   951 jump *label233 always
   952 label *label232
-    * set *tmp273 null
   953 label *label233
   954 ubind .TYPE
   955 label *label230
 
   961 jump *label231 equal *tmp276 false
   962 jump *label229 always
   963 label *label231
-    * set *tmp270 null
   964 jump *label228 always
   965 label *label227
-    * set *tmp270 null
   966 label *label228
   967 end
-    * set *tmp260 null
   968 label *label222
   969 sensor *tmp277 @unit @flag
   970 set :processUnit.1:state *tmp277
 
  1005 label *label242
  1006 set *tmp283 *tmp286
  1007 label *label240
-    * set *tmp280 *tmp283
  1008 jump *label236 always
  1009 label *label235
-    * set *tmp280 null
  1010 label *label236
  1011 op equal *tmp289 :processUnit.1:state 2
  1012 jump *label245 equal *tmp289 false
 
  1039 set :processUnit.1:distance *tmp302
  1040 set *tmp292 :processUnit.1:distance
  1041 label *label248
-    * set *tmp290 *tmp292
  1042 jump *label246 always
  1043 label *label245
-    * set *tmp290 null
  1044 label *label246
  1045 op equal *tmp303 :processUnit.1:state 3
  1046 jump *label251 equal *tmp303 false
 
  1049 jump *label255 equal :processUnit.1:supply false
  1050 ucontrol itemDrop .DOME .UNIT_CAPACITY
  1051 set .MSG ", supplying\n"
-    * set *tmp307 .MSG
  1052 jump *label256 always
  1053 label *label255
  1054 ucontrol approach .DOME_X .DOME_Y 6
  1055 set .MSG ", waiting\n"
-    * set *tmp307 .MSG
  1056 label *label256
  1057 sensor *tmp308 @unit @totalItems
  1058 op lessThanEq *tmp309 *tmp308 0
 
  1079 set :processUnit.1:distance *tmp317
  1080 set *tmp306 :processUnit.1:distance
  1081 label *label254
-    * set *tmp304 *tmp306
  1082 jump *label252 always
  1083 label *label251
-    * set *tmp304 null
  1084 label *label252
  1085 ucontrol flag :processUnit.1:state
  1086 sensor *tmp318 @unit @totalItems
 
  1100 print "["
  1101 print "] sec"
  1102 print "\n"
-    * set *tmp320 null
  1103 jump *label260 always
  1104 label *label259
  1105 print .MSG
-    * set *tmp320 .MSG
  1106 label *label260
  1107 set *tmp321 @unit
  1108 set :processUnit.1:unit *tmp321
 
  1119 set *tmp322 *tmp326
  1120 label *label262
  1121 set .SUPPLY_S_FIRST *tmp322
-    * set *tmp258 .SUPPLY_S_FIRST
  1122 jump *label220 always
  1123 label *label219
-    * set *tmp258 null
  1124 label *label220
  1125 set :printDomeStatus.1:item @phase-fabric
  1126 set :printDomeStatus.1:text "\n[green]Phase fabric[] status:\n"
 
  1134 print "["
  1135 print "]"
  1136 print "\n"
-    * set *tmp329 null
  1137 jump *label265 always
  1138 label *label264
  1139 print "  dome:  [coral]"
 
  1141 print "["
  1142 print "]"
  1143 print "\n"
-    * set *tmp329 null
  1144 label *label265
  1145 label *label263
  1146 set :processUnit.2:unit .UNIT_P1
 
  1157 op equal *tmp336 *tmp335 @this
  1158 op land *tmp337 *tmp334 *tmp336
  1159 jump *label270 equal *tmp337 false
-    * set *tmp330 :rebindUnit.6:currentUnit
  1160 jump *label267 always
  1161 set *tmp338 null
  1162 jump *label271 always
  1163 label *label270
  1164 set *tmp338 null
  1165 label *label271
-    * set *tmp332 *tmp338
  1166 jump *label269 always
  1167 label *label268
-    * set *tmp332 null
  1168 label *label269
  1169 ubind .TYPE
  1170 set :rebindUnit.6:firstUnit @unit
 
  1174 sensor *tmp341 @unit @controlled
  1175 op equal *tmp342 *tmp341 0
  1176 jump *label277 equal *tmp342 false
-    * set *tmp330 @unit
  1177 jump *label267 always
-    * set *tmp343 null
  1178 jump *label278 always
  1179 label *label277
-    * set *tmp343 null
  1180 label *label278
  1181 ubind .TYPE
  1182 label *label275
 
  1188 jump *label276 equal *tmp346 false
  1189 jump *label274 always
  1190 label *label276
-    * set *tmp340 null
  1191 jump *label273 always
  1192 label *label272
-    * set *tmp340 null
  1193 label *label273
  1194 end
-    * set *tmp330 null
  1195 label *label267
  1196 sensor *tmp347 @unit @flag
  1197 set :processUnit.2:state *tmp347
 
  1232 label *label287
  1233 set *tmp353 *tmp356
  1234 label *label285
-    * set *tmp350 *tmp353
  1235 jump *label281 always
  1236 label *label280
-    * set *tmp350 null
  1237 label *label281
  1238 op equal *tmp359 :processUnit.2:state 2
  1239 jump *label290 equal *tmp359 false
 
  1266 set :processUnit.2:distance *tmp372
  1267 set *tmp362 :processUnit.2:distance
  1268 label *label293
-    * set *tmp360 *tmp362
  1269 jump *label291 always
  1270 label *label290
-    * set *tmp360 null
  1271 label *label291
  1272 op equal *tmp373 :processUnit.2:state 3
  1273 jump *label296 equal *tmp373 false
 
  1276 jump *label300 equal :processUnit.2:supply false
  1277 ucontrol itemDrop .DOME .UNIT_CAPACITY
  1278 set .MSG ", supplying\n"
-    * set *tmp377 .MSG
  1279 jump *label301 always
  1280 label *label300
  1281 ucontrol approach .DOME_X .DOME_Y 6
  1282 set .MSG ", waiting\n"
-    * set *tmp377 .MSG
  1283 label *label301
  1284 sensor *tmp378 @unit @totalItems
  1285 op lessThanEq *tmp379 *tmp378 0
 
  1306 set :processUnit.2:distance *tmp387
  1307 set *tmp376 :processUnit.2:distance
  1308 label *label299
-    * set *tmp374 *tmp376
  1309 jump *label297 always
  1310 label *label296
-    * set *tmp374 null
  1311 label *label297
  1312 ucontrol flag :processUnit.2:state
  1313 sensor *tmp388 @unit @totalItems
 
  1327 print "["
  1328 print "] sec"
  1329 print "\n"
-    * set *tmp390 null
  1330 jump *label305 always
  1331 label *label304
  1332 print .MSG
-    * set *tmp390 .MSG
  1333 label *label305
  1334 set *tmp391 @unit
  1335 set :processUnit.2:unit *tmp391
 
  1351 op equal *tmp400 *tmp399 @this
  1352 op land *tmp401 *tmp398 *tmp400
  1353 jump *label312 equal *tmp401 false
-    * set *tmp394 :rebindUnit.7:currentUnit
  1354 jump *label309 always
  1355 set *tmp402 null
  1356 jump *label313 always
  1357 label *label312
  1358 set *tmp402 null
  1359 label *label313
-    * set *tmp396 *tmp402
  1360 jump *label311 always
  1361 label *label310
-    * set *tmp396 null
  1362 label *label311
  1363 ubind .TYPE
  1364 set :rebindUnit.7:firstUnit @unit
 
  1368 sensor *tmp405 @unit @controlled
  1369 op equal *tmp406 *tmp405 0
  1370 jump *label319 equal *tmp406 false
-    * set *tmp394 @unit
  1371 jump *label309 always
-    * set *tmp407 null
  1372 jump *label320 always
  1373 label *label319
-    * set *tmp407 null
  1374 label *label320
  1375 ubind .TYPE
  1376 label *label317
 
  1382 jump *label318 equal *tmp410 false
  1383 jump *label316 always
  1384 label *label318
-    * set *tmp404 null
  1385 jump *label315 always
  1386 label *label314
-    * set *tmp404 null
  1387 label *label315
  1388 end
-    * set *tmp394 null
  1389 label *label309
  1390 sensor *tmp411 @unit @flag
  1391 set :processUnit.3:state *tmp411
 
  1426 label *label329
  1427 set *tmp417 *tmp420
  1428 label *label327
-    * set *tmp414 *tmp417
  1429 jump *label323 always
  1430 label *label322
-    * set *tmp414 null
  1431 label *label323
  1432 op equal *tmp423 :processUnit.3:state 2
  1433 jump *label332 equal *tmp423 false
 
  1460 set :processUnit.3:distance *tmp436
  1461 set *tmp426 :processUnit.3:distance
  1462 label *label335
-    * set *tmp424 *tmp426
  1463 jump *label333 always
  1464 label *label332
-    * set *tmp424 null
  1465 label *label333
  1466 op equal *tmp437 :processUnit.3:state 3
  1467 jump *label338 equal *tmp437 false
 
  1470 jump *label342 equal :processUnit.3:supply false
  1471 ucontrol itemDrop .DOME .UNIT_CAPACITY
  1472 set .MSG ", supplying\n"
-    * set *tmp441 .MSG
  1473 jump *label343 always
  1474 label *label342
  1475 ucontrol approach .DOME_X .DOME_Y 6
  1476 set .MSG ", waiting\n"
-    * set *tmp441 .MSG
  1477 label *label343
  1478 sensor *tmp442 @unit @totalItems
  1479 op lessThanEq *tmp443 *tmp442 0
 
  1500 set :processUnit.3:distance *tmp451
  1501 set *tmp440 :processUnit.3:distance
  1502 label *label341
-    * set *tmp438 *tmp440
  1503 jump *label339 always
  1504 label *label338
-    * set *tmp438 null
  1505 label *label339
  1506 ucontrol flag :processUnit.3:state
  1507 sensor *tmp452 @unit @totalItems
 
  1521 print "["
  1522 print "] sec"
  1523 print "\n"
-    * set *tmp454 null
  1524 jump *label347 always
  1525 label *label346
  1526 print .MSG
-    * set *tmp454 .MSG
  1527 label *label347
  1528 set *tmp455 @unit
  1529 set :processUnit.3:unit *tmp455
 
  1540 set *tmp456 *tmp460
  1541 label *label349
  1542 set .SUPPLY_P_FIRST *tmp456
-    * set *tmp392 .SUPPLY_P_FIRST
  1543 jump *label307 always
  1544 label *label306
-    * set *tmp392 null
  1545 label *label307
  1546 op sub *tmp461 @time :start
  1547 op floor *tmp462 *tmp461
 
  1607 label *label369
  1608 set *tmp484 null
  1609 label *label370
-    * set *tmp482 *tmp484
  1610 jump *label366 always
  1611 label *label365
  1612 set *tmp485 :areUnitsAvailable.2:occupied
  1613 op add :areUnitsAvailable.2:occupied :areUnitsAvailable.2:occupied 1
-    * set *tmp482 *tmp485
  1614 label *label366
  1615 ubind :areUnitsAvailable.2:type
  1616 label *label363
 
  1622 jump *label364 equal *tmp488 false
  1623 jump *label362 always
  1624 label *label364
-    * set *tmp468 null
  1625 jump *label358 always
  1626 label *label357
-    * set *tmp468 null
  1627 label *label358
  1628 jump *label372 equal :areUnitsAvailable.2:output false
  1629 print :areUnitsAvailable.2:type
 
  1637 jump *label374 equal *tmp490 false
  1638 print ", needed: "
  1639 print :areUnitsAvailable.2:needed
-    * set *tmp491 null
  1640 jump *label375 always
  1641 label *label374
-    * set *tmp491 null
  1642 label *label375
  1643 print "\n"
-    * set *tmp489 null
  1644 jump *label373 always
  1645 label *label372
-    * set *tmp489 null
  1646 label *label373
  1647 set *tmp466 false
  1648 jump *label356 always
 
  1650 label *label356
  1651 jump *label354 equal *tmp466 false
  1652 end
-    * set *tmp492 null
  1653 jump *label355 always
  1654 label *label354
-    * set *tmp492 null
  1655 label *label355
  1656 op add *tmp493 @time 5000
  1657 set :unitCheck *tmp493
-    * set *tmp465 :unitCheck
  1658 jump *label351 always
  1659 label *label350
-    * set *tmp465 null
  1660 label *label351
  1661 label *label174
  1662 jump *label173 always
 
  1675 label *label379
  1676 ulocate building core false @copper *tmp500 *tmp501 *tmp502 *tmp499
  1677 set .CORE *tmp499
-    * set *tmp498 .CORE
  1678 jump *label378 always
  1679 label *label377
-    * set *tmp498 null
  1680 label *label378
  1681 set :locateCore*retval .CORE
  1682 label *label376

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-53 instructions):
 
   115 jump *label40 equal *tmp27 false
   116 set *tmp10 true
   117 jump *label27 always
-    * set *tmp28 null
   118 jump *label41 always
   119 label *label40
-    * set *tmp28 null
   120 label *label41
   121 jump *label37 always
   122 label *label36
-    * set *tmp29 :areUnitsAvailable:occupied
   123 op add :areUnitsAvailable:occupied :areUnitsAvailable:occupied 1
   124 label *label37
   125 ubind :areUnitsAvailable:type
 
   225 jump *label71 equal *tmp57 false
   226 set *tmp40 true
   227 jump *label58 always
-    * set *tmp58 null
   228 jump *label72 always
   229 label *label71
-    * set *tmp58 null
   230 label *label72
   231 jump *label68 always
   232 label *label67
-    * set *tmp59 :areUnitsAvailable.1:occupied
   233 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   234 label *label68
   235 ubind :areUnitsAvailable.1:type
 
   272 printflush null
   273 set *tmp9 :chooseUnitType:type
   274 jump *label21 always
-    * set *tmp66 null
   275 jump *label57 always
   276 label *label56
-    * set *tmp66 null
   277 label *label57
   278 jump *label55 always
   279 label *label54
 
   318 op notEqual *tmp75 .UNIT_S2 null
   319 jump *label86 equal *tmp75 false
   320 jump *label83 always
-    * set *tmp76 null
   321 jump *label87 always
   322 label *label86
-    * set *tmp76 null
   323 label *label87
   324 jump *label85 always
   325 label *label84
 
   348 op land *tmp88 *tmp85 *tmp87
   349 jump *label93 equal *tmp88 false
   350 jump *label90 always
-    * set *tmp89 null
   351 jump *label94 always
   352 label *label93
-    * set *tmp89 null
   353 label *label94
   354 jump *label92 always
   355 label *label91
 
   399 op land *tmp106 *tmp103 *tmp105
   400 jump *label107 equal *tmp106 false
   401 jump *label104 always
-    * set *tmp107 null
   402 jump *label108 always
   403 label *label107
-    * set *tmp107 null
   404 label *label108
   405 jump *label106 always
   406 label *label105
 
   497 op land *tmp143 *tmp140 *tmp142
   498 jump *label131 equal *tmp143 false
   499 jump *label128 always
-    * set *tmp144 null
   500 jump *label132 always
   501 label *label131
-    * set *tmp144 null
   502 label *label132
   503 jump *label130 always
   504 label *label129
 
   548 op land *tmp161 *tmp158 *tmp160
   549 jump *label145 equal *tmp161 false
   550 jump *label142 always
-    * set *tmp162 null
   551 jump *label146 always
   552 label *label145
-    * set *tmp162 null
   553 label *label146
   554 jump *label144 always
   555 label *label143
 
   719 op land *tmp203 *tmp200 *tmp202
   720 jump *label183 equal *tmp203 false
   721 jump *label180 always
-    * set *tmp204 null
   722 jump *label184 always
   723 label *label183
-    * set *tmp204 null
   724 label *label184
   725 jump *label182 always
   726 label *label181
 
   767 op equal *tmp218 *tmp217 :processUnit:item
   768 jump *label197 equal *tmp218 false
   769 set :processUnit:state 3
-    * set *tmp219 :processUnit:state
   770 jump *label198 always
   771 label *label197
   772 sensor *tmp220 @unit @totalItems
 
   788 label *label202
   789 set *tmp222 *tmp224
   790 label *label200
-    * set *tmp219 *tmp222
   791 label *label198
   792 jump *label194 always
   793 label *label193
 
   808 set .MSG ", loading\n"
   809 set *tmp231 .MSG
   810 label *label208
-    * set *tmp228 *tmp231
   811 jump *label206 always
   812 label *label205
   813 ucontrol approach .CORE_X .CORE_Y 6
 
   820 op idiv *tmp237 *tmp236 .SPEED_TENTHS
   821 op div *tmp238 *tmp237 10
   822 set :processUnit:distance *tmp238
-    * set *tmp228 :processUnit:distance
   823 label *label206
   824 jump *label204 always
   825 label *label203
 
   846 label *label215
   847 set *tmp246 null
   848 label *label216
-    * set *tmp242 *tmp246
   849 jump *label212 always
   850 label *label211
   851 ucontrol approach .DOME_X .DOME_Y 6
 
   858 op idiv *tmp252 *tmp251 .SPEED_TENTHS
   859 op div *tmp253 *tmp252 10
   860 set :processUnit:distance *tmp253
-    * set *tmp242 :processUnit:distance
   861 label *label212
   862 jump *label210 always
   863 label *label209
 
   905 op land *tmp267 *tmp264 *tmp266
   906 jump *label225 equal *tmp267 false
   907 jump *label222 always
-    * set *tmp268 null
   908 jump *label226 always
   909 label *label225
-    * set *tmp268 null
   910 label *label226
   911 jump *label224 always
   912 label *label223
 
   953 op equal *tmp282 *tmp281 :processUnit.1:item
   954 jump *label239 equal *tmp282 false
   955 set :processUnit.1:state 3
-    * set *tmp283 :processUnit.1:state
   956 jump *label240 always
   957 label *label239
   958 sensor *tmp284 @unit @totalItems
 
   974 label *label244
   975 set *tmp286 *tmp288
   976 label *label242
-    * set *tmp283 *tmp286
   977 label *label240
   978 jump *label236 always
   979 label *label235
 
   994 set .MSG ", loading\n"
   995 set *tmp295 .MSG
   996 label *label250
-    * set *tmp292 *tmp295
   997 jump *label248 always
   998 label *label247
   999 ucontrol approach .CORE_X .CORE_Y 6
 
  1006 op idiv *tmp301 *tmp300 .SPEED_TENTHS
  1007 op div *tmp302 *tmp301 10
  1008 set :processUnit.1:distance *tmp302
-    * set *tmp292 :processUnit.1:distance
  1009 label *label248
  1010 jump *label246 always
  1011 label *label245
 
  1032 label *label257
  1033 set *tmp310 null
  1034 label *label258
-    * set *tmp306 *tmp310
  1035 jump *label254 always
  1036 label *label253
  1037 ucontrol approach .DOME_X .DOME_Y 6
 
  1044 op idiv *tmp316 *tmp315 .SPEED_TENTHS
  1045 op div *tmp317 *tmp316 10
  1046 set :processUnit.1:distance *tmp317
-    * set *tmp306 :processUnit.1:distance
  1047 label *label254
  1048 jump *label252 always
  1049 label *label251
 
  1124 op land *tmp337 *tmp334 *tmp336
  1125 jump *label270 equal *tmp337 false
  1126 jump *label267 always
-    * set *tmp338 null
  1127 jump *label271 always
  1128 label *label270
-    * set *tmp338 null
  1129 label *label271
  1130 jump *label269 always
  1131 label *label268
 
  1172 op equal *tmp352 *tmp351 :processUnit.2:item
  1173 jump *label284 equal *tmp352 false
  1174 set :processUnit.2:state 3
-    * set *tmp353 :processUnit.2:state
  1175 jump *label285 always
  1176 label *label284
  1177 sensor *tmp354 @unit @totalItems
 
  1193 label *label289
  1194 set *tmp356 *tmp358
  1195 label *label287
-    * set *tmp353 *tmp356
  1196 label *label285
  1197 jump *label281 always
  1198 label *label280
 
  1213 set .MSG ", loading\n"
  1214 set *tmp365 .MSG
  1215 label *label295
-    * set *tmp362 *tmp365
  1216 jump *label293 always
  1217 label *label292
  1218 ucontrol approach .CORE_X .CORE_Y 6
 
  1225 op idiv *tmp371 *tmp370 .SPEED_TENTHS
  1226 op div *tmp372 *tmp371 10
  1227 set :processUnit.2:distance *tmp372
-    * set *tmp362 :processUnit.2:distance
  1228 label *label293
  1229 jump *label291 always
  1230 label *label290
 
  1251 label *label302
  1252 set *tmp380 null
  1253 label *label303
-    * set *tmp376 *tmp380
  1254 jump *label299 always
  1255 label *label298
  1256 ucontrol approach .DOME_X .DOME_Y 6
 
  1263 op idiv *tmp386 *tmp385 .SPEED_TENTHS
  1264 op div *tmp387 *tmp386 10
  1265 set :processUnit.2:distance *tmp387
-    * set *tmp376 :processUnit.2:distance
  1266 label *label299
  1267 jump *label297 always
  1268 label *label296
 
  1310 op land *tmp401 *tmp398 *tmp400
  1311 jump *label312 equal *tmp401 false
  1312 jump *label309 always
-    * set *tmp402 null
  1313 jump *label313 always
  1314 label *label312
-    * set *tmp402 null
  1315 label *label313
  1316 jump *label311 always
  1317 label *label310
 
  1358 op equal *tmp416 *tmp415 :processUnit.3:item
  1359 jump *label326 equal *tmp416 false
  1360 set :processUnit.3:state 3
-    * set *tmp417 :processUnit.3:state
  1361 jump *label327 always
  1362 label *label326
  1363 sensor *tmp418 @unit @totalItems
 
  1379 label *label331
  1380 set *tmp420 *tmp422
  1381 label *label329
-    * set *tmp417 *tmp420
  1382 label *label327
  1383 jump *label323 always
  1384 label *label322
 
  1399 set .MSG ", loading\n"
  1400 set *tmp429 .MSG
  1401 label *label337
-    * set *tmp426 *tmp429
  1402 jump *label335 always
  1403 label *label334
  1404 ucontrol approach .CORE_X .CORE_Y 6
 
  1411 op idiv *tmp435 *tmp434 .SPEED_TENTHS
  1412 op div *tmp436 *tmp435 10
  1413 set :processUnit.3:distance *tmp436
-    * set *tmp426 :processUnit.3:distance
  1414 label *label335
  1415 jump *label333 always
  1416 label *label332
 
  1437 label *label344
  1438 set *tmp444 null
  1439 label *label345
-    * set *tmp440 *tmp444
  1440 jump *label341 always
  1441 label *label340
  1442 ucontrol approach .DOME_X .DOME_Y 6
 
  1449 op idiv *tmp450 *tmp449 .SPEED_TENTHS
  1450 op div *tmp451 *tmp450 10
  1451 set :processUnit.3:distance *tmp451
-    * set *tmp440 :processUnit.3:distance
  1452 label *label341
  1453 jump *label339 always
  1454 label *label338
 
  1552 jump *label369 equal *tmp483 false
  1553 set *tmp466 true
  1554 jump *label356 always
-    * set *tmp484 null
  1555 jump *label370 always
  1556 label *label369
-    * set *tmp484 null
  1557 label *label370
  1558 jump *label366 always
  1559 label *label365
-    * set *tmp485 :areUnitsAvailable.2:occupied
  1560 op add :areUnitsAvailable.2:occupied :areUnitsAvailable.2:occupied 1
  1561 label *label366
  1562 ubind :areUnitsAvailable.2:type

Modifications by Initial phase, Dead Code Elimination, iteration 3 (-24 instructions):
 
   773 op equal *tmp221 *tmp220 0
   774 jump *label199 equal *tmp221 false
   775 set :processUnit:state 2
-    * set *tmp222 :processUnit:state
   776 jump *label200 always
   777 label *label199
   778 set .MSG ", initializing\n"
 
   785 label *label201
   786 set *tmp224 null
   787 label *label202
-    * set *tmp222 *tmp224
   788 label *label200
   789 label *label198
   790 jump *label194 always
 
   800 jump *label207 equal *tmp230 false
   801 ucontrol approach .DOME_X .DOME_Y 6
   802 set :processUnit:state 3
-    * set *tmp231 :processUnit:state
   803 jump *label208 always
   804 label *label207
   805 set .MSG ", loading\n"
-    * set *tmp231 .MSG
   806 label *label208
   807 jump *label206 always
   808 label *label205
 
   837 jump *label215 equal *tmp245 false
   838 ucontrol approach .CORE_X .CORE_Y 6
   839 set :processUnit:state 2
-    * set *tmp246 :processUnit:state
   840 jump *label216 always
   841 label *label215
-    * set *tmp246 null
   842 label *label216
   843 jump *label212 always
   844 label *label211
 
   953 op equal *tmp285 *tmp284 0
   954 jump *label241 equal *tmp285 false
   955 set :processUnit.1:state 2
-    * set *tmp286 :processUnit.1:state
   956 jump *label242 always
   957 label *label241
   958 set .MSG ", initializing\n"
 
   965 label *label243
   966 set *tmp288 null
   967 label *label244
-    * set *tmp286 *tmp288
   968 label *label242
   969 label *label240
   970 jump *label236 always
 
   980 jump *label249 equal *tmp294 false
   981 ucontrol approach .DOME_X .DOME_Y 6
   982 set :processUnit.1:state 3
-    * set *tmp295 :processUnit.1:state
   983 jump *label250 always
   984 label *label249
   985 set .MSG ", loading\n"
-    * set *tmp295 .MSG
   986 label *label250
   987 jump *label248 always
   988 label *label247
 
  1017 jump *label257 equal *tmp309 false
  1018 ucontrol approach .CORE_X .CORE_Y 6
  1019 set :processUnit.1:state 2
-    * set *tmp310 :processUnit.1:state
  1020 jump *label258 always
  1021 label *label257
-    * set *tmp310 null
  1022 label *label258
  1023 jump *label254 always
  1024 label *label253
 
  1166 op equal *tmp355 *tmp354 0
  1167 jump *label286 equal *tmp355 false
  1168 set :processUnit.2:state 2
-    * set *tmp356 :processUnit.2:state
  1169 jump *label287 always
  1170 label *label286
  1171 set .MSG ", initializing\n"
 
  1178 label *label288
  1179 set *tmp358 null
  1180 label *label289
-    * set *tmp356 *tmp358
  1181 label *label287
  1182 label *label285
  1183 jump *label281 always
 
  1193 jump *label294 equal *tmp364 false
  1194 ucontrol approach .DOME_X .DOME_Y 6
  1195 set :processUnit.2:state 3
-    * set *tmp365 :processUnit.2:state
  1196 jump *label295 always
  1197 label *label294
  1198 set .MSG ", loading\n"
-    * set *tmp365 .MSG
  1199 label *label295
  1200 jump *label293 always
  1201 label *label292
 
  1230 jump *label302 equal *tmp379 false
  1231 ucontrol approach .CORE_X .CORE_Y 6
  1232 set :processUnit.2:state 2
-    * set *tmp380 :processUnit.2:state
  1233 jump *label303 always
  1234 label *label302
-    * set *tmp380 null
  1235 label *label303
  1236 jump *label299 always
  1237 label *label298
 
  1346 op equal *tmp419 *tmp418 0
  1347 jump *label328 equal *tmp419 false
  1348 set :processUnit.3:state 2
-    * set *tmp420 :processUnit.3:state
  1349 jump *label329 always
  1350 label *label328
  1351 set .MSG ", initializing\n"
 
  1358 label *label330
  1359 set *tmp422 null
  1360 label *label331
-    * set *tmp420 *tmp422
  1361 label *label329
  1362 label *label327
  1363 jump *label323 always
 
  1373 jump *label336 equal *tmp428 false
  1374 ucontrol approach .DOME_X .DOME_Y 6
  1375 set :processUnit.3:state 3
-    * set *tmp429 :processUnit.3:state
  1376 jump *label337 always
  1377 label *label336
  1378 set .MSG ", loading\n"
-    * set *tmp429 .MSG
  1379 label *label337
  1380 jump *label335 always
  1381 label *label334
 
  1410 jump *label344 equal *tmp443 false
  1411 ucontrol approach .CORE_X .CORE_Y 6
  1412 set :processUnit.3:state 2
-    * set *tmp444 :processUnit.3:state
  1413 jump *label345 always
  1414 label *label344
-    * set *tmp444 null
  1415 label *label345
  1416 jump *label341 always
  1417 label *label340

Modifications by Initial phase, Dead Code Elimination, iteration 4 (-8 instructions):
 
   780 ucontrol within .CORE_X .CORE_Y 8 *tmp223
   781 jump *label201 equal *tmp223 false
   782 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * set *tmp224 null
   783 jump *label202 always
   784 label *label201
-    * set *tmp224 null
   785 label *label202
   786 label *label200
   787 label *label198
 
   958 ucontrol within .CORE_X .CORE_Y 8 *tmp287
   959 jump *label243 equal *tmp287 false
   960 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * set *tmp288 null
   961 jump *label244 always
   962 label *label243
-    * set *tmp288 null
   963 label *label244
   964 label *label242
   965 label *label240
 
  1169 ucontrol within .CORE_X .CORE_Y 8 *tmp357
  1170 jump *label288 equal *tmp357 false
  1171 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * set *tmp358 null
  1172 jump *label289 always
  1173 label *label288
-    * set *tmp358 null
  1174 label *label289
  1175 label *label287
  1176 label *label285
 
  1347 ucontrol within .CORE_X .CORE_Y 8 *tmp421
  1348 jump *label330 equal *tmp421 false
  1349 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * set *tmp422 null
  1350 jump *label331 always
  1351 label *label330
-    * set *tmp422 null
  1352 label *label331
  1353 label *label329
  1354 label *label327

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-41 instructions):
 
    48 jump *label5 always
    49 label *label7
    50 label *label1
-    * sensor *tmp3 .CORE @x
-    * set .CORE_X *tmp3
-    * sensor *tmp4 .CORE @y
-    * set .CORE_Y *tmp4
-    * sensor *tmp5 .DOME @x
-    * set .DOME_X *tmp5
-    * sensor *tmp6 .DOME @y
-    * set .DOME_Y *tmp6
+   51 sensor .CORE_X .CORE @x
+   52 sensor .CORE_Y .CORE @y
+   53 sensor .DOME_X .DOME @x
+   54 sensor .DOME_Y .DOME @y
    55 label *label18
    56 sensor *tmp7 switch1 @enabled
    57 op equal *tmp8 *tmp7 false
 
    82 op len *tmp16 *tmp14 *tmp15
    83 op mul *tmp17 2 *tmp16
    84 sensor *tmp18 :needsFourUnits:unit @speed
-    * op div *tmp19 *tmp17 *tmp18
-    * set :needsFourUnits:travel_time *tmp19
-    * op greaterThanEq *tmp20 :needsFourUnits:travel_time 47
-    * set *tmp13 *tmp20
+   85 op div :needsFourUnits:travel_time *tmp17 *tmp18
+   86 op greaterThanEq *tmp13 :needsFourUnits:travel_time 47
    87 jump *label32 always
    88 set *tmp13 null
    89 label *label32
 
   190 op len *tmp46 *tmp44 *tmp45
   191 op mul *tmp47 2 *tmp46
   192 sensor *tmp48 :needsFourUnits.1:unit @speed
-    * op div *tmp49 *tmp47 *tmp48
-    * set :needsFourUnits.1:travel_time *tmp49
-    * op greaterThanEq *tmp50 :needsFourUnits.1:travel_time 47
-    * set *tmp43 *tmp50
+  193 op div :needsFourUnits.1:travel_time *tmp47 *tmp48
+  194 op greaterThanEq *tmp43 :needsFourUnits.1:travel_time 47
   195 jump *label63 always
   196 set *tmp43 null
   197 label *label63
 
   305 set .UNIT_S2 .UNIT_P2
   306 set .UNIT_P2 .UNIT_S1
   307 set .UNIT_S1 .UNIT_P1
-    * set *tmp74 @unit
-    * set .UNIT_P1 *tmp74
+  308 set .UNIT_P1 @unit
   309 op notEqual *tmp75 .UNIT_S2 null
   310 jump *label86 equal *tmp75 false
   311 jump *label83 always
 
   449 jump *label118 always
   450 label *label117
   451 label *label118
-    * sensor *tmp121 .UNIT_S1 @itemCapacity
-    * set .UNIT_CAPACITY *tmp121
-    * sensor *tmp122 .UNIT_S1 @speed
-    * set .SPEED *tmp122
-    * op div *tmp123 .SPEED 10
-    * set .SPEED_TENTHS *tmp123
+  452 sensor .UNIT_CAPACITY .UNIT_S1 @itemCapacity
+  453 sensor .SPEED .UNIT_S1 @speed
+  454 op div .SPEED_TENTHS .SPEED 10
   455 op strictEqual *tmp124 .SPEED null
   456 jump *label122 equal *tmp124 false
   457 stop
 
   464 op len *tmp129 *tmp127 *tmp128
   465 op mul *tmp130 2 *tmp129
   466 sensor *tmp131 :needsFourUnits.2:unit @speed
-    * op div *tmp132 *tmp130 *tmp131
-    * set :needsFourUnits.2:travel_time *tmp132
-    * op greaterThanEq *tmp133 :needsFourUnits.2:travel_time 47
-    * set *tmp126 *tmp133
+  467 op div :needsFourUnits.2:travel_time *tmp130 *tmp131
+  468 op greaterThanEq *tmp126 :needsFourUnits.2:travel_time 47
   469 jump *label124 always
   470 set *tmp126 null
   471 label *label124
 
   655 set *tmp190 false
   656 label *label170
   657 set .SUPPLY_P_FIRST *tmp190
-    * op add *tmp191 @time 5000
-    * set :unitCheck *tmp191
+  658 op add :unitCheck @time 5000
   659 label *label173
   660 sensor *tmp192 switch1 @enabled
   661 jump *label175 equal *tmp192 false
 
   671 set :printDomeStatus:item @silicon
   672 set :printDomeStatus:text "\n[green]Silicon[] status:\n"
   673 print :printDomeStatus:text
-    * sensor *tmp193 .DOME :printDomeStatus:item
-    * set :printDomeStatus:level *tmp193
+  674 sensor :printDomeStatus:level .DOME :printDomeStatus:item
   675 op greaterThan *tmp194 :printDomeStatus:level 3
   676 jump *label177 equal *tmp194 false
   677 print "  dome:  [green]"
 
   736 label *label186
   737 end
   738 label *label180
-    * sensor *tmp213 @unit @flag
-    * set :processUnit:state *tmp213
+  739 sensor :processUnit:state @unit @flag
   740 set :processUnit:distance -1
   741 set :processUnit:color "gold"
   742 op lessThan *tmp214 :processUnit:state 2
 
   795 op sub *tmp235 .CORE_Y *tmp234
   796 op len *tmp236 *tmp233 *tmp235
   797 op idiv *tmp237 *tmp236 .SPEED_TENTHS
-    * op div *tmp238 *tmp237 10
-    * set :processUnit:distance *tmp238
+  798 op div :processUnit:distance *tmp237 10
   799 label *label206
   800 jump *label204 always
   801 label *label203
 
   830 op sub *tmp250 .DOME_Y *tmp249
   831 op len *tmp251 *tmp248 *tmp250
   832 op idiv *tmp252 *tmp251 .SPEED_TENTHS
-    * op div *tmp253 *tmp252 10
-    * set :processUnit:distance *tmp253
+  833 op div :processUnit:distance *tmp252 10
   834 label *label212
   835 jump *label210 always
   836 label *label209
 
   857 label *label217
   858 print .MSG
   859 label *label218
-    * set *tmp257 @unit
-    * set :processUnit:unit *tmp257
+  860 set :processUnit:unit @unit
   861 label *label179
   862 set .UNIT_S1 :processUnit:unit
   863 jump *label219 equal .FOUR_UNITS false
 
   910 label *label228
   911 end
   912 label *label222
-    * sensor *tmp277 @unit @flag
-    * set :processUnit.1:state *tmp277
+  913 sensor :processUnit.1:state @unit @flag
   914 set :processUnit.1:distance -1
   915 set :processUnit.1:color "gold"
   916 op lessThan *tmp278 :processUnit.1:state 2
 
   969 op sub *tmp299 .CORE_Y *tmp298
   970 op len *tmp300 *tmp297 *tmp299
   971 op idiv *tmp301 *tmp300 .SPEED_TENTHS
-    * op div *tmp302 *tmp301 10
-    * set :processUnit.1:distance *tmp302
+  972 op div :processUnit.1:distance *tmp301 10
   973 label *label248
   974 jump *label246 always
   975 label *label245
 
  1004 op sub *tmp314 .DOME_Y *tmp313
  1005 op len *tmp315 *tmp312 *tmp314
  1006 op idiv *tmp316 *tmp315 .SPEED_TENTHS
-    * op div *tmp317 *tmp316 10
-    * set :processUnit.1:distance *tmp317
+ 1007 op div :processUnit.1:distance *tmp316 10
  1008 label *label254
  1009 jump *label252 always
  1010 label *label251
 
  1031 label *label259
  1032 print .MSG
  1033 label *label260
-    * set *tmp321 @unit
-    * set :processUnit.1:unit *tmp321
+ 1034 set :processUnit.1:unit @unit
  1035 label *label221
  1036 set .UNIT_S2 :processUnit.1:unit
  1037 jump *label261 equal .SUPPLY_S_FIRST false
  1038 sensor *tmp323 .UNIT_S1 @totalItems
-    * op greaterThan *tmp324 *tmp323 0
-    * set *tmp322 *tmp324
+ 1039 op greaterThan *tmp322 *tmp323 0
  1040 jump *label262 always
  1041 label *label261
  1042 sensor *tmp325 .UNIT_S2 @totalItems
-    * op equal *tmp326 *tmp325 0
-    * set *tmp322 *tmp326
+ 1043 op equal *tmp322 *tmp325 0
  1044 label *label262
  1045 set .SUPPLY_S_FIRST *tmp322
  1046 jump *label220 always
 
  1049 set :printDomeStatus.1:item @phase-fabric
  1050 set :printDomeStatus.1:text "\n[green]Phase fabric[] status:\n"
  1051 print :printDomeStatus.1:text
-    * sensor *tmp327 .DOME :printDomeStatus.1:item
-    * set :printDomeStatus.1:level *tmp327
+ 1052 sensor :printDomeStatus.1:level .DOME :printDomeStatus.1:item
  1053 op greaterThan *tmp328 :printDomeStatus.1:level 3
  1054 jump *label264 equal *tmp328 false
  1055 print "  dome:  [green]"
 
  1114 label *label273
  1115 end
  1116 label *label267
-    * sensor *tmp347 @unit @flag
-    * set :processUnit.2:state *tmp347
+ 1117 sensor :processUnit.2:state @unit @flag
  1118 set :processUnit.2:distance -1
  1119 set :processUnit.2:color "gold"
  1120 op lessThan *tmp348 :processUnit.2:state 2
 
  1173 op sub *tmp369 .CORE_Y *tmp368
  1174 op len *tmp370 *tmp367 *tmp369
  1175 op idiv *tmp371 *tmp370 .SPEED_TENTHS
-    * op div *tmp372 *tmp371 10
-    * set :processUnit.2:distance *tmp372
+ 1176 op div :processUnit.2:distance *tmp371 10
  1177 label *label293
  1178 jump *label291 always
  1179 label *label290
 
  1208 op sub *tmp384 .DOME_Y *tmp383
  1209 op len *tmp385 *tmp382 *tmp384
  1210 op idiv *tmp386 *tmp385 .SPEED_TENTHS
-    * op div *tmp387 *tmp386 10
-    * set :processUnit.2:distance *tmp387
+ 1211 op div :processUnit.2:distance *tmp386 10
  1212 label *label299
  1213 jump *label297 always
  1214 label *label296
 
  1235 label *label304
  1236 print .MSG
  1237 label *label305
-    * set *tmp391 @unit
-    * set :processUnit.2:unit *tmp391
+ 1238 set :processUnit.2:unit @unit
  1239 label *label266
  1240 set .UNIT_P1 :processUnit.2:unit
  1241 jump *label306 equal .FOUR_UNITS false
 
  1288 label *label315
  1289 end
  1290 label *label309
-    * sensor *tmp411 @unit @flag
-    * set :processUnit.3:state *tmp411
+ 1291 sensor :processUnit.3:state @unit @flag
  1292 set :processUnit.3:distance -1
  1293 set :processUnit.3:color "gold"
  1294 op lessThan *tmp412 :processUnit.3:state 2
 
  1347 op sub *tmp433 .CORE_Y *tmp432
  1348 op len *tmp434 *tmp431 *tmp433
  1349 op idiv *tmp435 *tmp434 .SPEED_TENTHS
-    * op div *tmp436 *tmp435 10
-    * set :processUnit.3:distance *tmp436
+ 1350 op div :processUnit.3:distance *tmp435 10
  1351 label *label335
  1352 jump *label333 always
  1353 label *label332
 
  1382 op sub *tmp448 .DOME_Y *tmp447
  1383 op len *tmp449 *tmp446 *tmp448
  1384 op idiv *tmp450 *tmp449 .SPEED_TENTHS
-    * op div *tmp451 *tmp450 10
-    * set :processUnit.3:distance *tmp451
+ 1385 op div :processUnit.3:distance *tmp450 10
  1386 label *label341
  1387 jump *label339 always
  1388 label *label338
 
  1409 label *label346
  1410 print .MSG
  1411 label *label347
-    * set *tmp455 @unit
-    * set :processUnit.3:unit *tmp455
+ 1412 set :processUnit.3:unit @unit
  1413 label *label308
  1414 set .UNIT_P2 :processUnit.3:unit
  1415 jump *label348 equal .SUPPLY_P_FIRST false
  1416 sensor *tmp457 .UNIT_P1 @totalItems
-    * op greaterThan *tmp458 *tmp457 0
-    * set *tmp456 *tmp458
+ 1417 op greaterThan *tmp456 *tmp457 0
  1418 jump *label349 always
  1419 label *label348
  1420 sensor *tmp459 .UNIT_P2 @totalItems
-    * op equal *tmp460 *tmp459 0
-    * set *tmp456 *tmp460
+ 1421 op equal *tmp456 *tmp459 0
  1422 label *label349
  1423 set .SUPPLY_P_FIRST *tmp456
  1424 jump *label307 always
 
  1454 op len *tmp472 *tmp470 *tmp471
  1455 op mul *tmp473 2 *tmp472
  1456 sensor *tmp474 :needsFourUnits.3:unit @speed
-    * op div *tmp475 *tmp473 *tmp474
-    * set :needsFourUnits.3:travel_time *tmp475
-    * op greaterThanEq *tmp476 :needsFourUnits.3:travel_time 47
-    * set *tmp469 *tmp476
+ 1457 op div :needsFourUnits.3:travel_time *tmp473 *tmp474
+ 1458 op greaterThanEq *tmp469 :needsFourUnits.3:travel_time 47
  1459 jump *label361 always
  1460 set *tmp469 null
  1461 label *label361
 
  1529 jump *label355 always
  1530 label *label354
  1531 label *label355
-    * op add *tmp493 @time 5000
-    * set :unitCheck *tmp493
+ 1532 op add :unitCheck @time 5000
  1533 jump *label351 always
  1534 label *label350
  1535 label *label351
 
  1548 jump *label379 notEqual *tmp497 false
  1549 jump *label377 always
  1550 label *label379
-    * ulocate building core false @copper *tmp500 *tmp501 *tmp502 *tmp499
-    * set .CORE *tmp499
+ 1551 ulocate building core false @copper *tmp500 *tmp501 *tmp502 .CORE
  1552 jump *label378 always
  1553 label *label377
  1554 label *label378

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-2 instructions):
 
    15 printflush message1
    16 set .CORE null
    17 label *label5
-    * jump *label7 equal true false
    18 set :locateDomeAndCore:type @flare
    19 setaddr *tmp1 *label11
    20 jump *label8 always
 
    62 jump *label18 always
    63 label *label20
    64 label *label22
-    * jump *label24 equal true false
    65 printflush null
    66 print "[gold]Looking for suitable unit type:[]"
    67 print "\n"

Modifications by Iterated phase, Jump Straightening, pass 1, iteration 1 (-24 instructions):
 
    99 label *label39
   100 sensor *tmp24 @unit @controller
   101 op equal *tmp25 *tmp24 @this
-    * jump *label38 notEqual *tmp25 false
-    * jump *label36 always
+  102 jump *label36 equal *tmp25 false
   103 label *label38
   104 op add :areUnitsAvailable:free :areUnitsAvailable:free 1
   105 op greaterThanEq *tmp27 :areUnitsAvailable:free :areUnitsAvailable:needed
 
   120 label *label42
   121 sensor *tmp31 :areUnitsAvailable:firstUnit @dead
   122 op equal *tmp32 *tmp31 0
-    * jump *label35 equal *tmp32 false
-    * jump *label33 always
+  123 jump *label33 notEqual *tmp32 false
   124 label *label35
   125 jump *label29 always
   126 label *label28
 
   205 label *label70
   206 sensor *tmp54 @unit @controller
   207 op equal *tmp55 *tmp54 @this
-    * jump *label69 notEqual *tmp55 false
-    * jump *label67 always
+  208 jump *label67 equal *tmp55 false
   209 label *label69
   210 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
   211 op greaterThanEq *tmp57 :areUnitsAvailable.1:free :areUnitsAvailable.1:needed
 
   226 label *label73
   227 sensor *tmp61 :areUnitsAvailable.1:firstUnit @dead
   228 op equal *tmp62 *tmp61 0
-    * jump *label66 equal *tmp62 false
-    * jump *label64 always
+  229 jump *label64 notEqual *tmp62 false
   230 label *label66
   231 jump *label60 always
   232 label *label59
 
   316 label *label88
   317 sensor *tmp78 :rebindUnits:firstUnit @dead
   318 op equal *tmp79 *tmp78 0
-    * jump *label83 equal *tmp79 false
-    * jump *label81 always
+  319 jump *label81 notEqual *tmp79 false
   320 label *label83
   321 jump *label78 always
   322 label *label78
 
   357 label *label102
   358 sensor *tmp96 :rebindUnit:firstUnit @dead
   359 op equal *tmp97 *tmp96 0
-    * jump *label99 equal *tmp97 false
-    * jump *label97 always
+  360 jump *label97 notEqual *tmp97 false
   361 label *label99
   362 jump *label96 always
   363 label *label95
 
   407 label *label116
   408 sensor *tmp114 :rebindUnit.1:firstUnit @dead
   409 op equal *tmp115 *tmp114 0
-    * jump *label113 equal *tmp115 false
-    * jump *label111 always
+  410 jump *label111 notEqual *tmp115 false
   411 label *label113
   412 jump *label110 always
   413 label *label109
 
   426 label *label120
   427 sensor *tmp118 .UNIT_P1 @firstItem
   428 op equal *tmp119 *tmp118 @silicon
-    * jump *label119 notEqual *tmp119 false
-    * jump *label117 always
+  429 jump *label117 equal *tmp119 false
   430 label *label119
   431 set :swap:a .UNIT_S1
   432 set :swap:b .UNIT_P1
 
   498 label *label140
   499 sensor *tmp151 :rebindUnit.2:firstUnit @dead
   500 op equal *tmp152 *tmp151 0
-    * jump *label137 equal *tmp152 false
-    * jump *label135 always
+  501 jump *label135 notEqual *tmp152 false
   502 label *label137
   503 jump *label134 always
   504 label *label133
 
   548 label *label154
   549 sensor *tmp169 :rebindUnit.3:firstUnit @dead
   550 op equal *tmp170 *tmp169 0
-    * jump *label151 equal *tmp170 false
-    * jump *label149 always
+  551 jump *label149 notEqual *tmp170 false
   552 label *label151
   553 jump *label148 always
   554 label *label147
 
   587 label *label163
   588 sensor *tmp178 .UNIT_P2 @firstItem
   589 op equal *tmp179 *tmp178 @silicon
-    * jump *label162 notEqual *tmp179 false
-    * jump *label160 always
+  590 jump *label160 equal *tmp179 false
   591 label *label162
   592 set :swap.2:a .UNIT_S2
   593 set :swap.2:b .UNIT_P2
 
   618 sensor *tmp182 .UNIT_S1 @totalItems
   619 sensor *tmp183 .UNIT_S2 @totalItems
   620 op lessThan *tmp184 *tmp182 *tmp183
-    * jump *label167 notEqual *tmp184 false
-    * jump *label165 always
+  621 jump *label165 equal *tmp184 false
   622 label *label167
   623 set *tmp185 true
   624 jump *label166 always
 
   632 sensor *tmp187 .UNIT_P1 @totalItems
   633 sensor *tmp188 .UNIT_P2 @totalItems
   634 op lessThan *tmp189 *tmp187 *tmp188
-    * jump *label171 notEqual *tmp189 false
-    * jump *label169 always
+  635 jump *label169 equal *tmp189 false
   636 label *label171
   637 set *tmp190 true
   638 jump *label170 always
 
   713 label *label192
   714 sensor *tmp211 :rebindUnit.4:firstUnit @dead
   715 op equal *tmp212 *tmp211 0
-    * jump *label189 equal *tmp212 false
-    * jump *label187 always
+  716 jump *label187 notEqual *tmp212 false
   717 label *label189
   718 jump *label186 always
   719 label *label185
 
   727 jump *label195 notEqual *tmp214 false
   728 label *label196
   729 op greaterThan *tmp215 :processUnit:state 3
-    * jump *label195 notEqual *tmp215 false
-    * jump *label193 always
+  730 jump *label193 equal *tmp215 false
   731 label *label195
   732 sensor *tmp217 @unit @firstItem
   733 op equal *tmp218 *tmp217 :processUnit:item
 
   885 label *label234
   886 sensor *tmp275 :rebindUnit.5:firstUnit @dead
   887 op equal *tmp276 *tmp275 0
-    * jump *label231 equal *tmp276 false
-    * jump *label229 always
+  888 jump *label229 notEqual *tmp276 false
   889 label *label231
   890 jump *label228 always
   891 label *label227
 
   899 jump *label237 notEqual *tmp278 false
   900 label *label238
   901 op greaterThan *tmp279 :processUnit.1:state 3
-    * jump *label237 notEqual *tmp279 false
-    * jump *label235 always
+  902 jump *label235 equal *tmp279 false
   903 label *label237
   904 sensor *tmp281 @unit @firstItem
   905 op equal *tmp282 *tmp281 :processUnit.1:item
 
  1087 label *label279
  1088 sensor *tmp345 :rebindUnit.6:firstUnit @dead
  1089 op equal *tmp346 *tmp345 0
-    * jump *label276 equal *tmp346 false
-    * jump *label274 always
+ 1090 jump *label274 notEqual *tmp346 false
  1091 label *label276
  1092 jump *label273 always
  1093 label *label272
 
  1101 jump *label282 notEqual *tmp348 false
  1102 label *label283
  1103 op greaterThan *tmp349 :processUnit.2:state 3
-    * jump *label282 notEqual *tmp349 false
-    * jump *label280 always
+ 1104 jump *label280 equal *tmp349 false
  1105 label *label282
  1106 sensor *tmp351 @unit @firstItem
  1107 op equal *tmp352 *tmp351 :processUnit.2:item
 
  1259 label *label321
  1260 sensor *tmp409 :rebindUnit.7:firstUnit @dead
  1261 op equal *tmp410 *tmp409 0
-    * jump *label318 equal *tmp410 false
-    * jump *label316 always
+ 1262 jump *label316 notEqual *tmp410 false
  1263 label *label318
  1264 jump *label315 always
  1265 label *label314
 
  1273 jump *label324 notEqual *tmp412 false
  1274 label *label325
  1275 op greaterThan *tmp413 :processUnit.3:state 3
-    * jump *label324 notEqual *tmp413 false
-    * jump *label322 always
+ 1276 jump *label322 equal *tmp413 false
  1277 label *label324
  1278 sensor *tmp415 @unit @firstItem
  1279 op equal *tmp416 *tmp415 :processUnit.3:item
 
  1450 label *label368
  1451 sensor *tmp480 @unit @controller
  1452 op equal *tmp481 *tmp480 @this
-    * jump *label367 notEqual *tmp481 false
-    * jump *label365 always
+ 1453 jump *label365 equal *tmp481 false
  1454 label *label367
  1455 op add :areUnitsAvailable.2:free :areUnitsAvailable.2:free 1
  1456 op greaterThanEq *tmp483 :areUnitsAvailable.2:free :areUnitsAvailable.2:needed
 
  1471 label *label371
  1472 sensor *tmp487 :areUnitsAvailable.2:firstUnit @dead
  1473 op equal *tmp488 *tmp487 0
-    * jump *label364 equal *tmp488 false
-    * jump *label362 always
+ 1474 jump *label362 notEqual *tmp488 false
  1475 label *label364
  1476 jump *label358 always
  1477 label *label357
 
  1520 label *label380
  1521 sensor *tmp496 @unit @controller
  1522 op equal *tmp497 *tmp496 @this
-    * jump *label379 notEqual *tmp497 false
-    * jump *label377 always
+ 1523 jump *label377 equal *tmp497 false
  1524 label *label379
  1525 ulocate building core false @copper *tmp500 *tmp501 *tmp502 .CORE
  1526 jump *label378 always

Modifications by Iterated phase, Condition Optimization, pass 1, iteration 1 (-121 instructions):
 
     3 remark "Do not modify anything below this line."
     4 set .DOME dome1
     5 label *label2
-    * op equal *tmp0 .DOME null
-    * jump *label4 equal *tmp0 false
+    6 jump *label4 notEqual .DOME null
     7 print "[gold]Waiting for an overdrive dome to be connected..."
     8 printflush message1
     9 set .DOME dome1
 
    52 sensor .DOME_Y .DOME @y
    53 label *label18
    54 sensor *tmp7 switch1 @enabled
-    * op equal *tmp8 *tmp7 false
-    * jump *label20 equal *tmp8 false
+   55 jump *label20 notEqual *tmp7 false
    56 print "[coral]Activate switch to begin supplying overdrive dome..."
    57 print "\n"
    58 printflush message1
 
    70 set :areUnitsAvailable:needed 0
    71 ubind :areUnitsAvailable:type
    72 set :areUnitsAvailable:firstUnit @unit
-    * op notEqual *tmp11 :areUnitsAvailable:firstUnit null
-    * jump *label28 equal *tmp11 false
+   73 jump *label28 equal :areUnitsAvailable:firstUnit null
    74 set :needsFourUnits:unit @unit
    75 op sub *tmp14 .DOME_X .CORE_X
    76 op sub *tmp15 .DOME_Y .CORE_Y
 
    91 set :areUnitsAvailable:needed *tmp21
    92 label *label33
    93 sensor *tmp22 @unit @controlled
-    * op equal *tmp23 *tmp22 0
-    * jump *label38 notEqual *tmp23 false
+   94 jump *label38 equal *tmp22 0
    95 label *label39
    96 sensor *tmp24 @unit @controller
-    * op equal *tmp25 *tmp24 @this
-    * jump *label36 equal *tmp25 false
+   97 jump *label36 notEqual *tmp24 @this
    98 label *label38
    99 op add :areUnitsAvailable:free :areUnitsAvailable:free 1
-    * op greaterThanEq *tmp27 :areUnitsAvailable:free :areUnitsAvailable:needed
-    * jump *label40 equal *tmp27 false
+  100 jump *label40 lessThan :areUnitsAvailable:free :areUnitsAvailable:needed
   101 set *tmp10 true
   102 jump *label27 always
   103 jump *label41 always
 
   109 label *label37
   110 ubind :areUnitsAvailable:type
   111 label *label34
-    * op notEqual *tmp30 @unit :areUnitsAvailable:firstUnit
-    * jump *label35 equal *tmp30 false
+  112 jump *label35 equal @unit :areUnitsAvailable:firstUnit
   113 label *label42
   114 sensor *tmp31 :areUnitsAvailable:firstUnit @dead
-    * op equal *tmp32 *tmp31 0
-    * jump *label33 notEqual *tmp32 false
+  115 jump *label33 equal *tmp31 0
   116 label *label35
   117 jump *label29 always
   118 label *label28
 
   125 print ","
   126 print " free: "
   127 print :areUnitsAvailable:free
-    * op greaterThan *tmp34 :areUnitsAvailable:needed 0
-    * jump *label45 equal *tmp34 false
+  128 jump *label45 lessThanEq :areUnitsAvailable:needed 0
   129 print ", needed: "
   130 print :areUnitsAvailable:needed
   131 jump *label46 always
 
   160 set :chooseUnitType:type @mono
   161 setaddr *tmp37 *label53
   162 label *label47
-    * op notEqual *tmp38 :chooseUnitType:type UNIT_TYPE
-    * jump *label54 equal *tmp38 false
+  163 jump *label54 equal :chooseUnitType:type UNIT_TYPE
   164 set :areUnitsAvailable.1:type :chooseUnitType:type
   165 set :areUnitsAvailable.1:output true
   166 set :areUnitsAvailable.1:free 0
 
   168 set :areUnitsAvailable.1:needed 0
   169 ubind :areUnitsAvailable.1:type
   170 set :areUnitsAvailable.1:firstUnit @unit
-    * op notEqual *tmp41 :areUnitsAvailable.1:firstUnit null
-    * jump *label59 equal *tmp41 false
+  171 jump *label59 equal :areUnitsAvailable.1:firstUnit null
   172 set :needsFourUnits.1:unit @unit
   173 op sub *tmp44 .DOME_X .CORE_X
   174 op sub *tmp45 .DOME_Y .CORE_Y
 
   189 set :areUnitsAvailable.1:needed *tmp51
   190 label *label64
   191 sensor *tmp52 @unit @controlled
-    * op equal *tmp53 *tmp52 0
-    * jump *label69 notEqual *tmp53 false
+  192 jump *label69 equal *tmp52 0
   193 label *label70
   194 sensor *tmp54 @unit @controller
-    * op equal *tmp55 *tmp54 @this
-    * jump *label67 equal *tmp55 false
+  195 jump *label67 notEqual *tmp54 @this
   196 label *label69
   197 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
-    * op greaterThanEq *tmp57 :areUnitsAvailable.1:free :areUnitsAvailable.1:needed
-    * jump *label71 equal *tmp57 false
+  198 jump *label71 lessThan :areUnitsAvailable.1:free :areUnitsAvailable.1:needed
   199 set *tmp40 true
   200 jump *label58 always
   201 jump *label72 always
 
   207 label *label68
   208 ubind :areUnitsAvailable.1:type
   209 label *label65
-    * op notEqual *tmp60 @unit :areUnitsAvailable.1:firstUnit
-    * jump *label66 equal *tmp60 false
+  210 jump *label66 equal @unit :areUnitsAvailable.1:firstUnit
   211 label *label73
   212 sensor *tmp61 :areUnitsAvailable.1:firstUnit @dead
-    * op equal *tmp62 *tmp61 0
-    * jump *label64 notEqual *tmp62 false
+  213 jump *label64 equal *tmp61 0
   214 label *label66
   215 jump *label60 always
   216 label *label59
 
   223 print ","
   224 print " free: "
   225 print :areUnitsAvailable.1:free
-    * op greaterThan *tmp64 :areUnitsAvailable.1:needed 0
-    * jump *label76 equal *tmp64 false
+  226 jump *label76 lessThanEq :areUnitsAvailable.1:needed 0
   227 print ", needed: "
   228 print :areUnitsAvailable.1:needed
   229 jump *label77 always
 
   267 set :rebindUnits:count 0
   268 ubind .TYPE
   269 set :rebindUnits:firstUnit @unit
-    * op equal *tmp68 :rebindUnits:firstUnit null
-    * jump *label79 equal *tmp68 false
+  270 jump *label79 notEqual :rebindUnits:firstUnit null
   271 end
   272 jump *label80 always
   273 label *label79
   274 label *label80
   275 label *label81
   276 sensor *tmp70 @unit @controller
-    * op equal *tmp71 *tmp70 @this
-    * jump *label84 equal *tmp71 false
+  277 jump *label84 notEqual *tmp70 @this
   278 op add :rebindUnits:count :rebindUnits:count 1
   279 ucontrol flag 1
   280 set .UNIT_S2 .UNIT_P2
   281 set .UNIT_P2 .UNIT_S1
   282 set .UNIT_S1 .UNIT_P1
   283 set .UNIT_P1 @unit
-    * op notEqual *tmp75 .UNIT_S2 null
-    * jump *label86 equal *tmp75 false
+  284 jump *label86 equal .UNIT_S2 null
   285 jump *label83 always
   286 jump *label87 always
   287 label *label86
 
   291 label *label85
   292 ubind .TYPE
   293 label *label82
-    * op notEqual *tmp77 @unit :rebindUnits:firstUnit
-    * jump *label83 equal *tmp77 false
+  294 jump *label83 equal @unit :rebindUnits:firstUnit
   295 label *label88
   296 sensor *tmp78 :rebindUnits:firstUnit @dead
-    * op equal *tmp79 *tmp78 0
-    * jump *label81 notEqual *tmp79 false
+  297 jump *label81 equal *tmp78 0
   298 label *label83
   299 jump *label78 always
   300 label *label78
   301 set :acquireUnit:currentUnit .UNIT_S1
   302 set :rebindUnit:currentUnit :acquireUnit:currentUnit
-    * op notEqual *tmp82 :rebindUnit:currentUnit null
-    * jump *label91 equal *tmp82 false
+  303 jump *label91 equal :rebindUnit:currentUnit null
   304 ubind :rebindUnit:currentUnit
   305 sensor *tmp84 @unit @dead
   306 op equal *tmp85 *tmp84 0
 
   317 label *label92
   318 ubind .TYPE
   319 set :rebindUnit:firstUnit @unit
-    * op notEqual *tmp90 :rebindUnit:firstUnit null
-    * jump *label95 equal *tmp90 false
+  320 jump *label95 equal :rebindUnit:firstUnit null
   321 label *label97
   322 sensor *tmp92 @unit @controlled
-    * op equal *tmp93 *tmp92 0
-    * jump *label100 equal *tmp93 false
+  323 jump *label100 notEqual *tmp92 0
   324 jump *label90 always
   325 jump *label101 always
   326 label *label100
   327 label *label101
   328 ubind .TYPE
   329 label *label98
-    * op notEqual *tmp95 @unit :rebindUnit:firstUnit
-    * jump *label99 equal *tmp95 false
+  330 jump *label99 equal @unit :rebindUnit:firstUnit
   331 label *label102
   332 sensor *tmp96 :rebindUnit:firstUnit @dead
-    * op equal *tmp97 *tmp96 0
-    * jump *label97 notEqual *tmp97 false
+  333 jump *label97 equal *tmp96 0
   334 label *label99
   335 jump *label96 always
   336 label *label95
 
   345 set .UNIT_S1 *tmp80
   346 set :acquireUnit.1:currentUnit .UNIT_P1
   347 set :rebindUnit.1:currentUnit :acquireUnit.1:currentUnit
-    * op notEqual *tmp100 :rebindUnit.1:currentUnit null
-    * jump *label105 equal *tmp100 false
+  348 jump *label105 equal :rebindUnit.1:currentUnit null
   349 ubind :rebindUnit.1:currentUnit
   350 sensor *tmp102 @unit @dead
   351 op equal *tmp103 *tmp102 0
 
   362 label *label106
   363 ubind .TYPE
   364 set :rebindUnit.1:firstUnit @unit
-    * op notEqual *tmp108 :rebindUnit.1:firstUnit null
-    * jump *label109 equal *tmp108 false
+  365 jump *label109 equal :rebindUnit.1:firstUnit null
   366 label *label111
   367 sensor *tmp110 @unit @controlled
-    * op equal *tmp111 *tmp110 0
-    * jump *label114 equal *tmp111 false
+  368 jump *label114 notEqual *tmp110 0
   369 jump *label104 always
   370 jump *label115 always
   371 label *label114
   372 label *label115
   373 ubind .TYPE
   374 label *label112
-    * op notEqual *tmp113 @unit :rebindUnit.1:firstUnit
-    * jump *label113 equal *tmp113 false
+  375 jump *label113 equal @unit :rebindUnit.1:firstUnit
   376 label *label116
   377 sensor *tmp114 :rebindUnit.1:firstUnit @dead
-    * op equal *tmp115 *tmp114 0
-    * jump *label111 notEqual *tmp115 false
+  378 jump *label111 equal *tmp114 0
   379 label *label113
   380 jump *label110 always
   381 label *label109
 
   389 label *label103
   390 set .UNIT_P1 *tmp98
   391 sensor *tmp116 .UNIT_S1 @firstItem
-    * op equal *tmp117 *tmp116 @phase-fabric
-    * jump *label119 notEqual *tmp117 false
+  392 jump *label119 equal *tmp116 @phase-fabric
   393 label *label120
   394 sensor *tmp118 .UNIT_P1 @firstItem
-    * op equal *tmp119 *tmp118 @silicon
-    * jump *label117 equal *tmp119 false
+  395 jump *label117 notEqual *tmp118 @silicon
   396 label *label119
   397 set :swap:a .UNIT_S1
   398 set :swap:b .UNIT_P1
 
   429 jump *label125 equal .FOUR_UNITS false
   430 set :acquireUnit.2:currentUnit .UNIT_S2
   431 set :rebindUnit.2:currentUnit :acquireUnit.2:currentUnit
-    * op notEqual *tmp137 :rebindUnit.2:currentUnit null
-    * jump *label129 equal *tmp137 false
+  432 jump *label129 equal :rebindUnit.2:currentUnit null
   433 ubind :rebindUnit.2:currentUnit
   434 sensor *tmp139 @unit @dead
   435 op equal *tmp140 *tmp139 0
 
   446 label *label130
   447 ubind .TYPE
   448 set :rebindUnit.2:firstUnit @unit
-    * op notEqual *tmp145 :rebindUnit.2:firstUnit null
-    * jump *label133 equal *tmp145 false
+  449 jump *label133 equal :rebindUnit.2:firstUnit null
   450 label *label135
   451 sensor *tmp147 @unit @controlled
-    * op equal *tmp148 *tmp147 0
-    * jump *label138 equal *tmp148 false
+  452 jump *label138 notEqual *tmp147 0
   453 jump *label128 always
   454 jump *label139 always
   455 label *label138
   456 label *label139
   457 ubind .TYPE
   458 label *label136
-    * op notEqual *tmp150 @unit :rebindUnit.2:firstUnit
-    * jump *label137 equal *tmp150 false
+  459 jump *label137 equal @unit :rebindUnit.2:firstUnit
   460 label *label140
   461 sensor *tmp151 :rebindUnit.2:firstUnit @dead
-    * op equal *tmp152 *tmp151 0
-    * jump *label135 notEqual *tmp152 false
+  462 jump *label135 equal *tmp151 0
   463 label *label137
   464 jump *label134 always
   465 label *label133
 
   474 set .UNIT_S2 *tmp135
   475 set :acquireUnit.3:currentUnit .UNIT_P2
   476 set :rebindUnit.3:currentUnit :acquireUnit.3:currentUnit
-    * op notEqual *tmp155 :rebindUnit.3:currentUnit null
-    * jump *label143 equal *tmp155 false
+  477 jump *label143 equal :rebindUnit.3:currentUnit null
   478 ubind :rebindUnit.3:currentUnit
   479 sensor *tmp157 @unit @dead
   480 op equal *tmp158 *tmp157 0
 
   491 label *label144
   492 ubind .TYPE
   493 set :rebindUnit.3:firstUnit @unit
-    * op notEqual *tmp163 :rebindUnit.3:firstUnit null
-    * jump *label147 equal *tmp163 false
+  494 jump *label147 equal :rebindUnit.3:firstUnit null
   495 label *label149
   496 sensor *tmp165 @unit @controlled
-    * op equal *tmp166 *tmp165 0
-    * jump *label152 equal *tmp166 false
+  497 jump *label152 notEqual *tmp165 0
   498 jump *label142 always
   499 jump *label153 always
   500 label *label152
   501 label *label153
   502 ubind .TYPE
   503 label *label150
-    * op notEqual *tmp168 @unit :rebindUnit.3:firstUnit
-    * jump *label151 equal *tmp168 false
+  504 jump *label151 equal @unit :rebindUnit.3:firstUnit
   505 label *label154
   506 sensor *tmp169 :rebindUnit.3:firstUnit @dead
-    * op equal *tmp170 *tmp169 0
-    * jump *label149 notEqual *tmp170 false
+  507 jump *label149 equal *tmp169 0
   508 label *label151
   509 jump *label148 always
   510 label *label147
 
   518 label *label141
   519 set .UNIT_P2 *tmp153
   520 sensor *tmp171 .UNIT_S1 @firstItem
-    * op equal *tmp172 *tmp171 @phase-fabric
-    * jump *label155 equal *tmp172 false
+  521 jump *label155 notEqual *tmp171 @phase-fabric
   522 label *label158
   523 sensor *tmp173 .UNIT_P2 @firstItem
-    * op notEqual *tmp174 *tmp173 @phase-fabric
-    * jump *label155 equal *tmp174 false
+  524 jump *label155 equal *tmp173 @phase-fabric
   525 jump *label157 always
   526 label *label157
   527 set :swap.1:a .UNIT_S1
 
   536 label *label155
   537 label *label156
   538 sensor *tmp176 .UNIT_S2 @firstItem
-    * op equal *tmp177 *tmp176 @phase-fabric
-    * jump *label162 notEqual *tmp177 false
+  539 jump *label162 equal *tmp176 @phase-fabric
   540 label *label163
   541 sensor *tmp178 .UNIT_P2 @firstItem
-    * op equal *tmp179 *tmp178 @silicon
-    * jump *label160 equal *tmp179 false
+  542 jump *label160 notEqual *tmp178 @silicon
   543 label *label162
   544 set :swap.2:a .UNIT_S2
   545 set :swap.2:b .UNIT_P2
 
   564 set .UNIT_P2 null
   565 set .GROUP1 "unit"
   566 label *label126
-    * op equal *tmp181 .FOUR_UNITS false
-    * jump *label167 notEqual *tmp181 false
+  567 jump *label167 equal .FOUR_UNITS false
   568 label *label168
   569 sensor *tmp182 .UNIT_S1 @totalItems
   570 sensor *tmp183 .UNIT_S2 @totalItems
-    * op lessThan *tmp184 *tmp182 *tmp183
-    * jump *label165 equal *tmp184 false
+  571 jump *label165 greaterThanEq *tmp182 *tmp183
   572 label *label167
   573 set *tmp185 true
   574 jump *label166 always
 
   576 set *tmp185 false
   577 label *label166
   578 set .SUPPLY_S_FIRST *tmp185
-    * op equal *tmp186 .FOUR_UNITS false
-    * jump *label171 notEqual *tmp186 false
+  579 jump *label171 equal .FOUR_UNITS false
   580 label *label172
   581 sensor *tmp187 .UNIT_P1 @totalItems
   582 sensor *tmp188 .UNIT_P2 @totalItems
-    * op lessThan *tmp189 *tmp187 *tmp188
-    * jump *label169 equal *tmp189 false
+  583 jump *label169 greaterThanEq *tmp187 *tmp188
   584 label *label171
   585 set *tmp190 true
   586 jump *label170 always
 
   605 set :printDomeStatus:text "\n[green]Silicon[] status:\n"
   606 print :printDomeStatus:text
   607 sensor :printDomeStatus:level .DOME :printDomeStatus:item
-    * op greaterThan *tmp194 :printDomeStatus:level 3
-    * jump *label177 equal *tmp194 false
+  608 jump *label177 lessThanEq :printDomeStatus:level 3
   609 print "  dome:  [green]"
   610 print :printDomeStatus:level
   611 print "["
 
   625 set :processUnit:group .GROUP1
   626 set :processUnit:supply .SUPPLY_S_FIRST
   627 set :rebindUnit.4:currentUnit :processUnit:unit
-    * op notEqual *tmp197 :rebindUnit.4:currentUnit null
-    * jump *label181 equal *tmp197 false
+  628 jump *label181 equal :rebindUnit.4:currentUnit null
   629 ubind :rebindUnit.4:currentUnit
   630 sensor *tmp199 @unit @dead
   631 op equal *tmp200 *tmp199 0
 
   642 label *label182
   643 ubind .TYPE
   644 set :rebindUnit.4:firstUnit @unit
-    * op notEqual *tmp205 :rebindUnit.4:firstUnit null
-    * jump *label185 equal *tmp205 false
+  645 jump *label185 equal :rebindUnit.4:firstUnit null
   646 label *label187
   647 sensor *tmp207 @unit @controlled
-    * op equal *tmp208 *tmp207 0
-    * jump *label190 equal *tmp208 false
+  648 jump *label190 notEqual *tmp207 0
   649 jump *label180 always
   650 jump *label191 always
   651 label *label190
   652 label *label191
   653 ubind .TYPE
   654 label *label188
-    * op notEqual *tmp210 @unit :rebindUnit.4:firstUnit
-    * jump *label189 equal *tmp210 false
+  655 jump *label189 equal @unit :rebindUnit.4:firstUnit
   656 label *label192
   657 sensor *tmp211 :rebindUnit.4:firstUnit @dead
-    * op equal *tmp212 *tmp211 0
-    * jump *label187 notEqual *tmp212 false
+  658 jump *label187 equal *tmp211 0
   659 label *label189
   660 jump *label186 always
   661 label *label185
 
   665 sensor :processUnit:state @unit @flag
   666 set :processUnit:distance -1
   667 set :processUnit:color "gold"
-    * op lessThan *tmp214 :processUnit:state 2
-    * jump *label195 notEqual *tmp214 false
+  668 jump *label195 lessThan :processUnit:state 2
   669 label *label196
-    * op greaterThan *tmp215 :processUnit:state 3
-    * jump *label193 equal *tmp215 false
+  670 jump *label193 lessThanEq :processUnit:state 3
   671 label *label195
   672 sensor *tmp217 @unit @firstItem
-    * op equal *tmp218 *tmp217 :processUnit:item
-    * jump *label197 equal *tmp218 false
+  673 jump *label197 notEqual *tmp217 :processUnit:item
   674 set :processUnit:state 3
   675 jump *label198 always
   676 label *label197
   677 sensor *tmp220 @unit @totalItems
-    * op equal *tmp221 *tmp220 0
-    * jump *label199 equal *tmp221 false
+  678 jump *label199 notEqual *tmp220 0
   679 set :processUnit:state 2
   680 jump *label200 always
   681 label *label199
 
   692 jump *label194 always
   693 label *label193
   694 label *label194
-    * op equal *tmp225 :processUnit:state 2
-    * jump *label203 equal *tmp225 false
+  695 jump *label203 notEqual :processUnit:state 2
   696 ucontrol within .CORE_X .CORE_Y 8 *tmp227
   697 jump *label205 equal *tmp227 false
   698 ucontrol itemTake .CORE :processUnit:item .UNIT_CAPACITY
   699 sensor *tmp229 @unit @totalItems
-    * op greaterThanEq *tmp230 *tmp229 .UNIT_CAPACITY
-    * jump *label207 equal *tmp230 false
+  700 jump *label207 lessThan *tmp229 .UNIT_CAPACITY
   701 ucontrol approach .DOME_X .DOME_Y 6
   702 set :processUnit:state 3
   703 jump *label208 always
 
   719 jump *label204 always
   720 label *label203
   721 label *label204
-    * op equal *tmp239 :processUnit:state 3
-    * jump *label209 equal *tmp239 false
+  722 jump *label209 notEqual :processUnit:state 3
   723 ucontrol within .DOME_X .DOME_Y 8 *tmp241
   724 jump *label211 equal *tmp241 false
   725 jump *label213 equal :processUnit:supply false
 
   731 set .MSG ", waiting\n"
   732 label *label214
   733 sensor *tmp244 @unit @totalItems
-    * op lessThanEq *tmp245 *tmp244 0
-    * jump *label215 equal *tmp245 false
+  734 jump *label215 greaterThan *tmp244 0
   735 ucontrol approach .CORE_X .CORE_Y 6
   736 set :processUnit:state 2
   737 jump *label216 always
 
   763 print *tmp254
   764 print "["
   765 print "]"
-    * op greaterThanEq *tmp255 :processUnit:distance 0
-    * jump *label217 equal *tmp255 false
+  766 jump *label217 lessThan :processUnit:distance 0
   767 print .MSG
   768 print :processUnit:distance
   769 print "["
 
   783 set :processUnit.1:group .GROUP2
   784 set :processUnit.1:supply *tmp259
   785 set :rebindUnit.5:currentUnit :processUnit.1:unit
-    * op notEqual *tmp261 :rebindUnit.5:currentUnit null
-    * jump *label223 equal *tmp261 false
+  786 jump *label223 equal :rebindUnit.5:currentUnit null
   787 ubind :rebindUnit.5:currentUnit
   788 sensor *tmp263 @unit @dead
   789 op equal *tmp264 *tmp263 0
 
   800 label *label224
   801 ubind .TYPE
   802 set :rebindUnit.5:firstUnit @unit
-    * op notEqual *tmp269 :rebindUnit.5:firstUnit null
-    * jump *label227 equal *tmp269 false
+  803 jump *label227 equal :rebindUnit.5:firstUnit null
   804 label *label229
   805 sensor *tmp271 @unit @controlled
-    * op equal *tmp272 *tmp271 0
-    * jump *label232 equal *tmp272 false
+  806 jump *label232 notEqual *tmp271 0
   807 jump *label222 always
   808 jump *label233 always
   809 label *label232
   810 label *label233
   811 ubind .TYPE
   812 label *label230
-    * op notEqual *tmp274 @unit :rebindUnit.5:firstUnit
-    * jump *label231 equal *tmp274 false
+  813 jump *label231 equal @unit :rebindUnit.5:firstUnit
   814 label *label234
   815 sensor *tmp275 :rebindUnit.5:firstUnit @dead
-    * op equal *tmp276 *tmp275 0
-    * jump *label229 notEqual *tmp276 false
+  816 jump *label229 equal *tmp275 0
   817 label *label231
   818 jump *label228 always
   819 label *label227
 
   823 sensor :processUnit.1:state @unit @flag
   824 set :processUnit.1:distance -1
   825 set :processUnit.1:color "gold"
-    * op lessThan *tmp278 :processUnit.1:state 2
-    * jump *label237 notEqual *tmp278 false
+  826 jump *label237 lessThan :processUnit.1:state 2
   827 label *label238
-    * op greaterThan *tmp279 :processUnit.1:state 3
-    * jump *label235 equal *tmp279 false
+  828 jump *label235 lessThanEq :processUnit.1:state 3
   829 label *label237
   830 sensor *tmp281 @unit @firstItem
-    * op equal *tmp282 *tmp281 :processUnit.1:item
-    * jump *label239 equal *tmp282 false
+  831 jump *label239 notEqual *tmp281 :processUnit.1:item
   832 set :processUnit.1:state 3
   833 jump *label240 always
   834 label *label239
   835 sensor *tmp284 @unit @totalItems
-    * op equal *tmp285 *tmp284 0
-    * jump *label241 equal *tmp285 false
+  836 jump *label241 notEqual *tmp284 0
   837 set :processUnit.1:state 2
   838 jump *label242 always
   839 label *label241
 
   850 jump *label236 always
   851 label *label235
   852 label *label236
-    * op equal *tmp289 :processUnit.1:state 2
-    * jump *label245 equal *tmp289 false
+  853 jump *label245 notEqual :processUnit.1:state 2
   854 ucontrol within .CORE_X .CORE_Y 8 *tmp291
   855 jump *label247 equal *tmp291 false
   856 ucontrol itemTake .CORE :processUnit.1:item .UNIT_CAPACITY
   857 sensor *tmp293 @unit @totalItems
-    * op greaterThanEq *tmp294 *tmp293 .UNIT_CAPACITY
-    * jump *label249 equal *tmp294 false
+  858 jump *label249 lessThan *tmp293 .UNIT_CAPACITY
   859 ucontrol approach .DOME_X .DOME_Y 6
   860 set :processUnit.1:state 3
   861 jump *label250 always
 
   877 jump *label246 always
   878 label *label245
   879 label *label246
-    * op equal *tmp303 :processUnit.1:state 3
-    * jump *label251 equal *tmp303 false
+  880 jump *label251 notEqual :processUnit.1:state 3
   881 ucontrol within .DOME_X .DOME_Y 8 *tmp305
   882 jump *label253 equal *tmp305 false
   883 jump *label255 equal :processUnit.1:supply false
 
   889 set .MSG ", waiting\n"
   890 label *label256
   891 sensor *tmp308 @unit @totalItems
-    * op lessThanEq *tmp309 *tmp308 0
-    * jump *label257 equal *tmp309 false
+  892 jump *label257 greaterThan *tmp308 0
   893 ucontrol approach .CORE_X .CORE_Y 6
   894 set :processUnit.1:state 2
   895 jump *label258 always
 
   921 print *tmp318
   922 print "["
   923 print "]"
-    * op greaterThanEq *tmp319 :processUnit.1:distance 0
-    * jump *label259 equal *tmp319 false
+  924 jump *label259 lessThan :processUnit.1:distance 0
   925 print .MSG
   926 print :processUnit.1:distance
   927 print "["
 
   950 set :printDomeStatus.1:text "\n[green]Phase fabric[] status:\n"
   951 print :printDomeStatus.1:text
   952 sensor :printDomeStatus.1:level .DOME :printDomeStatus.1:item
-    * op greaterThan *tmp328 :printDomeStatus.1:level 3
-    * jump *label264 equal *tmp328 false
+  953 jump *label264 lessThanEq :printDomeStatus.1:level 3
   954 print "  dome:  [green]"
   955 print :printDomeStatus.1:level
   956 print "["
 
   970 set :processUnit.2:group .GROUP1
   971 set :processUnit.2:supply .SUPPLY_P_FIRST
   972 set :rebindUnit.6:currentUnit :processUnit.2:unit
-    * op notEqual *tmp331 :rebindUnit.6:currentUnit null
-    * jump *label268 equal *tmp331 false
+  973 jump *label268 equal :rebindUnit.6:currentUnit null
   974 ubind :rebindUnit.6:currentUnit
   975 sensor *tmp333 @unit @dead
   976 op equal *tmp334 *tmp333 0
 
   987 label *label269
   988 ubind .TYPE
   989 set :rebindUnit.6:firstUnit @unit
-    * op notEqual *tmp339 :rebindUnit.6:firstUnit null
-    * jump *label272 equal *tmp339 false
+  990 jump *label272 equal :rebindUnit.6:firstUnit null
   991 label *label274
   992 sensor *tmp341 @unit @controlled
-    * op equal *tmp342 *tmp341 0
-    * jump *label277 equal *tmp342 false
+  993 jump *label277 notEqual *tmp341 0
   994 jump *label267 always
   995 jump *label278 always
   996 label *label277
   997 label *label278
   998 ubind .TYPE
   999 label *label275
-    * op notEqual *tmp344 @unit :rebindUnit.6:firstUnit
-    * jump *label276 equal *tmp344 false
+ 1000 jump *label276 equal @unit :rebindUnit.6:firstUnit
  1001 label *label279
  1002 sensor *tmp345 :rebindUnit.6:firstUnit @dead
-    * op equal *tmp346 *tmp345 0
-    * jump *label274 notEqual *tmp346 false
+ 1003 jump *label274 equal *tmp345 0
  1004 label *label276
  1005 jump *label273 always
  1006 label *label272
 
  1010 sensor :processUnit.2:state @unit @flag
  1011 set :processUnit.2:distance -1
  1012 set :processUnit.2:color "gold"
-    * op lessThan *tmp348 :processUnit.2:state 2
-    * jump *label282 notEqual *tmp348 false
+ 1013 jump *label282 lessThan :processUnit.2:state 2
  1014 label *label283
-    * op greaterThan *tmp349 :processUnit.2:state 3
-    * jump *label280 equal *tmp349 false
+ 1015 jump *label280 lessThanEq :processUnit.2:state 3
  1016 label *label282
  1017 sensor *tmp351 @unit @firstItem
-    * op equal *tmp352 *tmp351 :processUnit.2:item
-    * jump *label284 equal *tmp352 false
+ 1018 jump *label284 notEqual *tmp351 :processUnit.2:item
  1019 set :processUnit.2:state 3
  1020 jump *label285 always
  1021 label *label284
  1022 sensor *tmp354 @unit @totalItems
-    * op equal *tmp355 *tmp354 0
-    * jump *label286 equal *tmp355 false
+ 1023 jump *label286 notEqual *tmp354 0
  1024 set :processUnit.2:state 2
  1025 jump *label287 always
  1026 label *label286
 
  1037 jump *label281 always
  1038 label *label280
  1039 label *label281
-    * op equal *tmp359 :processUnit.2:state 2
-    * jump *label290 equal *tmp359 false
+ 1040 jump *label290 notEqual :processUnit.2:state 2
  1041 ucontrol within .CORE_X .CORE_Y 8 *tmp361
  1042 jump *label292 equal *tmp361 false
  1043 ucontrol itemTake .CORE :processUnit.2:item .UNIT_CAPACITY
  1044 sensor *tmp363 @unit @totalItems
-    * op greaterThanEq *tmp364 *tmp363 .UNIT_CAPACITY
-    * jump *label294 equal *tmp364 false
+ 1045 jump *label294 lessThan *tmp363 .UNIT_CAPACITY
  1046 ucontrol approach .DOME_X .DOME_Y 6
  1047 set :processUnit.2:state 3
  1048 jump *label295 always
 
  1064 jump *label291 always
  1065 label *label290
  1066 label *label291
-    * op equal *tmp373 :processUnit.2:state 3
-    * jump *label296 equal *tmp373 false
+ 1067 jump *label296 notEqual :processUnit.2:state 3
  1068 ucontrol within .DOME_X .DOME_Y 8 *tmp375
  1069 jump *label298 equal *tmp375 false
  1070 jump *label300 equal :processUnit.2:supply false
 
  1076 set .MSG ", waiting\n"
  1077 label *label301
  1078 sensor *tmp378 @unit @totalItems
-    * op lessThanEq *tmp379 *tmp378 0
-    * jump *label302 equal *tmp379 false
+ 1079 jump *label302 greaterThan *tmp378 0
  1080 ucontrol approach .CORE_X .CORE_Y 6
  1081 set :processUnit.2:state 2
  1082 jump *label303 always
 
  1108 print *tmp388
  1109 print "["
  1110 print "]"
-    * op greaterThanEq *tmp389 :processUnit.2:distance 0
-    * jump *label304 equal *tmp389 false
+ 1111 jump *label304 lessThan :processUnit.2:distance 0
  1112 print .MSG
  1113 print :processUnit.2:distance
  1114 print "["
 
  1128 set :processUnit.3:group .GROUP2
  1129 set :processUnit.3:supply *tmp393
  1130 set :rebindUnit.7:currentUnit :processUnit.3:unit
-    * op notEqual *tmp395 :rebindUnit.7:currentUnit null
-    * jump *label310 equal *tmp395 false
+ 1131 jump *label310 equal :rebindUnit.7:currentUnit null
  1132 ubind :rebindUnit.7:currentUnit
  1133 sensor *tmp397 @unit @dead
  1134 op equal *tmp398 *tmp397 0
 
  1145 label *label311
  1146 ubind .TYPE
  1147 set :rebindUnit.7:firstUnit @unit
-    * op notEqual *tmp403 :rebindUnit.7:firstUnit null
-    * jump *label314 equal *tmp403 false
+ 1148 jump *label314 equal :rebindUnit.7:firstUnit null
  1149 label *label316
  1150 sensor *tmp405 @unit @controlled
-    * op equal *tmp406 *tmp405 0
-    * jump *label319 equal *tmp406 false
+ 1151 jump *label319 notEqual *tmp405 0
  1152 jump *label309 always
  1153 jump *label320 always
  1154 label *label319
  1155 label *label320
  1156 ubind .TYPE
  1157 label *label317
-    * op notEqual *tmp408 @unit :rebindUnit.7:firstUnit
-    * jump *label318 equal *tmp408 false
+ 1158 jump *label318 equal @unit :rebindUnit.7:firstUnit
  1159 label *label321
  1160 sensor *tmp409 :rebindUnit.7:firstUnit @dead
-    * op equal *tmp410 *tmp409 0
-    * jump *label316 notEqual *tmp410 false
+ 1161 jump *label316 equal *tmp409 0
  1162 label *label318
  1163 jump *label315 always
  1164 label *label314
 
  1168 sensor :processUnit.3:state @unit @flag
  1169 set :processUnit.3:distance -1
  1170 set :processUnit.3:color "gold"
-    * op lessThan *tmp412 :processUnit.3:state 2
-    * jump *label324 notEqual *tmp412 false
+ 1171 jump *label324 lessThan :processUnit.3:state 2
  1172 label *label325
-    * op greaterThan *tmp413 :processUnit.3:state 3
-    * jump *label322 equal *tmp413 false
+ 1173 jump *label322 lessThanEq :processUnit.3:state 3
  1174 label *label324
  1175 sensor *tmp415 @unit @firstItem
-    * op equal *tmp416 *tmp415 :processUnit.3:item
-    * jump *label326 equal *tmp416 false
+ 1176 jump *label326 notEqual *tmp415 :processUnit.3:item
  1177 set :processUnit.3:state 3
  1178 jump *label327 always
  1179 label *label326
  1180 sensor *tmp418 @unit @totalItems
-    * op equal *tmp419 *tmp418 0
-    * jump *label328 equal *tmp419 false
+ 1181 jump *label328 notEqual *tmp418 0
  1182 set :processUnit.3:state 2
  1183 jump *label329 always
  1184 label *label328
 
  1195 jump *label323 always
  1196 label *label322
  1197 label *label323
-    * op equal *tmp423 :processUnit.3:state 2
-    * jump *label332 equal *tmp423 false
+ 1198 jump *label332 notEqual :processUnit.3:state 2
  1199 ucontrol within .CORE_X .CORE_Y 8 *tmp425
  1200 jump *label334 equal *tmp425 false
  1201 ucontrol itemTake .CORE :processUnit.3:item .UNIT_CAPACITY
  1202 sensor *tmp427 @unit @totalItems
-    * op greaterThanEq *tmp428 *tmp427 .UNIT_CAPACITY
-    * jump *label336 equal *tmp428 false
+ 1203 jump *label336 lessThan *tmp427 .UNIT_CAPACITY
  1204 ucontrol approach .DOME_X .DOME_Y 6
  1205 set :processUnit.3:state 3
  1206 jump *label337 always
 
  1222 jump *label333 always
  1223 label *label332
  1224 label *label333
-    * op equal *tmp437 :processUnit.3:state 3
-    * jump *label338 equal *tmp437 false
+ 1225 jump *label338 notEqual :processUnit.3:state 3
  1226 ucontrol within .DOME_X .DOME_Y 8 *tmp439
  1227 jump *label340 equal *tmp439 false
  1228 jump *label342 equal :processUnit.3:supply false
 
  1234 set .MSG ", waiting\n"
  1235 label *label343
  1236 sensor *tmp442 @unit @totalItems
-    * op lessThanEq *tmp443 *tmp442 0
-    * jump *label344 equal *tmp443 false
+ 1237 jump *label344 greaterThan *tmp442 0
  1238 ucontrol approach .CORE_X .CORE_Y 6
  1239 set :processUnit.3:state 2
  1240 jump *label345 always
 
  1266 print *tmp452
  1267 print "["
  1268 print "]"
-    * op greaterThanEq *tmp453 :processUnit.3:distance 0
-    * jump *label346 equal *tmp453 false
+ 1269 jump *label346 lessThan :processUnit.3:distance 0
  1270 print .MSG
  1271 print :processUnit.3:distance
  1272 print "["
 
  1299 print " "
  1300 print "ms"
  1301 printflush message1
-    * op notEqual *tmp463 .TYPE UNIT_TYPE
-    * jump *label350 equal *tmp463 false
+ 1302 jump *label350 equal .TYPE UNIT_TYPE
  1303 label *label353
-    * op greaterThan *tmp464 :unitCheck @time
-    * jump *label350 equal *tmp464 false
+ 1304 jump *label350 lessThanEq :unitCheck @time
  1305 jump *label352 always
  1306 label *label352
  1307 set :areUnitsAvailable.2:type UNIT_TYPE
 
  1311 set :areUnitsAvailable.2:needed 0
  1312 ubind :areUnitsAvailable.2:type
  1313 set :areUnitsAvailable.2:firstUnit @unit
-    * op notEqual *tmp467 :areUnitsAvailable.2:firstUnit null
-    * jump *label357 equal *tmp467 false
+ 1314 jump *label357 equal :areUnitsAvailable.2:firstUnit null
  1315 set :needsFourUnits.3:unit @unit
  1316 op sub *tmp470 .DOME_X .CORE_X
  1317 op sub *tmp471 .DOME_Y .CORE_Y
 
  1332 set :areUnitsAvailable.2:needed *tmp477
  1333 label *label362
  1334 sensor *tmp478 @unit @controlled
-    * op equal *tmp479 *tmp478 0
-    * jump *label367 notEqual *tmp479 false
+ 1335 jump *label367 equal *tmp478 0
  1336 label *label368
  1337 sensor *tmp480 @unit @controller
-    * op equal *tmp481 *tmp480 @this
-    * jump *label365 equal *tmp481 false
+ 1338 jump *label365 notEqual *tmp480 @this
  1339 label *label367
  1340 op add :areUnitsAvailable.2:free :areUnitsAvailable.2:free 1
-    * op greaterThanEq *tmp483 :areUnitsAvailable.2:free :areUnitsAvailable.2:needed
-    * jump *label369 equal *tmp483 false
+ 1341 jump *label369 lessThan :areUnitsAvailable.2:free :areUnitsAvailable.2:needed
  1342 set *tmp466 true
  1343 jump *label356 always
  1344 jump *label370 always
 
  1350 label *label366
  1351 ubind :areUnitsAvailable.2:type
  1352 label *label363
-    * op notEqual *tmp486 @unit :areUnitsAvailable.2:firstUnit
-    * jump *label364 equal *tmp486 false
+ 1353 jump *label364 equal @unit :areUnitsAvailable.2:firstUnit
  1354 label *label371
  1355 sensor *tmp487 :areUnitsAvailable.2:firstUnit @dead
-    * op equal *tmp488 *tmp487 0
-    * jump *label362 notEqual *tmp488 false
+ 1356 jump *label362 equal *tmp487 0
  1357 label *label364
  1358 jump *label358 always
  1359 label *label357
 
  1366 print ","
  1367 print " free: "
  1368 print :areUnitsAvailable.2:free
-    * op greaterThan *tmp490 :areUnitsAvailable.2:needed 0
-    * jump *label374 equal *tmp490 false
+ 1369 jump *label374 lessThanEq :areUnitsAvailable.2:needed 0
  1370 print ", needed: "
  1371 print :areUnitsAvailable.2:needed
  1372 jump *label375 always
 
  1396 label *label0
  1397 ubind :locateCore:type
  1398 sensor *tmp494 @unit @controlled
-    * op equal *tmp495 *tmp494 0
-    * jump *label379 notEqual *tmp495 false
+ 1399 jump *label379 equal *tmp494 0
  1400 label *label380
  1401 sensor *tmp496 @unit @controller
-    * op equal *tmp497 *tmp496 @this
-    * jump *label377 equal *tmp497 false
+ 1402 jump *label377 notEqual *tmp496 @this
  1403 label *label379
  1404 ulocate building core false @copper *tmp500 *tmp501 *tmp502 .CORE
  1405 jump *label378 always

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-83 instructions):
 
    35 label *label17
    36 jump *label15 equal :locateCore*retval false
    37 jump *label1 always
-    * jump *label16 always
    38 label *label15
    39 label *label16
    40 label *label9
 
    99 jump *label40 lessThan :areUnitsAvailable:free :areUnitsAvailable:needed
   100 set *tmp10 true
   101 jump *label27 always
-    * jump *label41 always
   102 label *label40
   103 label *label41
   104 jump *label37 always
 
   112 sensor *tmp31 :areUnitsAvailable:firstUnit @dead
   113 jump *label33 equal *tmp31 0
   114 label *label35
-    * jump *label29 always
   115 label *label28
   116 label *label29
   117 jump *label43 equal :areUnitsAvailable:output false
 
   125 jump *label45 lessThanEq :areUnitsAvailable:needed 0
   126 print ", needed: "
   127 print :areUnitsAvailable:needed
-    * jump *label46 always
   128 label *label45
   129 label *label46
   130 print "\n"
-    * jump *label44 always
   131 label *label43
   132 label *label44
   133 set *tmp10 false
 
   137 jump *label25 equal *tmp10 false
   138 set *tmp9 UNIT_TYPE
   139 jump *label21 always
-    * jump *label26 always
   140 label *label25
   141 label *label26
   142 set :chooseUnitType:type @flare
 
   192 jump *label71 lessThan :areUnitsAvailable.1:free :areUnitsAvailable.1:needed
   193 set *tmp40 true
   194 jump *label58 always
-    * jump *label72 always
   195 label *label71
   196 label *label72
   197 jump *label68 always
 
   205 sensor *tmp61 :areUnitsAvailable.1:firstUnit @dead
   206 jump *label64 equal *tmp61 0
   207 label *label66
-    * jump *label60 always
   208 label *label59
   209 label *label60
   210 jump *label74 equal :areUnitsAvailable.1:output false
 
   218 jump *label76 lessThanEq :areUnitsAvailable.1:needed 0
   219 print ", needed: "
   220 print :areUnitsAvailable.1:needed
-    * jump *label77 always
   221 label *label76
   222 label *label77
   223 print "\n"
-    * jump *label75 always
   224 label *label74
   225 label *label75
   226 set *tmp40 false
 
   231 printflush null
   232 set *tmp9 :chooseUnitType:type
   233 jump *label21 always
-    * jump *label57 always
   234 label *label56
   235 label *label57
-    * jump *label55 always
   236 label *label54
   237 label *label55
   238 label *label48
 
   257 set :rebindUnits:firstUnit @unit
   258 jump *label79 notEqual :rebindUnits:firstUnit null
   259 end
-    * jump *label80 always
   260 label *label79
   261 label *label80
   262 label *label81
 
   270 set .UNIT_P1 @unit
   271 jump *label86 equal .UNIT_S2 null
   272 jump *label83 always
-    * jump *label87 always
   273 label *label86
   274 label *label87
-    * jump *label85 always
   275 label *label84
   276 label *label85
   277 ubind .TYPE
 
   281 sensor *tmp78 :rebindUnits:firstUnit @dead
   282 jump *label81 equal *tmp78 0
   283 label *label83
-    * jump *label78 always
   284 label *label78
   285 set :acquireUnit:currentUnit .UNIT_S1
   286 set :rebindUnit:currentUnit :acquireUnit:currentUnit
 
   293 op land *tmp88 *tmp85 *tmp87
   294 jump *label93 equal *tmp88 false
   295 jump *label90 always
-    * jump *label94 always
   296 label *label93
   297 label *label94
-    * jump *label92 always
   298 label *label91
   299 label *label92
   300 ubind .TYPE
 
   304 sensor *tmp92 @unit @controlled
   305 jump *label100 notEqual *tmp92 0
   306 jump *label90 always
-    * jump *label101 always
   307 label *label100
   308 label *label101
   309 ubind .TYPE
 
   313 sensor *tmp96 :rebindUnit:firstUnit @dead
   314 jump *label97 equal *tmp96 0
   315 label *label99
-    * jump *label96 always
   316 label *label95
   317 label *label96
   318 end
 
   334 op land *tmp106 *tmp103 *tmp105
   335 jump *label107 equal *tmp106 false
   336 jump *label104 always
-    * jump *label108 always
   337 label *label107
   338 label *label108
-    * jump *label106 always
   339 label *label105
   340 label *label106
   341 ubind .TYPE
 
   345 sensor *tmp110 @unit @controlled
   346 jump *label114 notEqual *tmp110 0
   347 jump *label104 always
-    * jump *label115 always
   348 label *label114
   349 label *label115
   350 ubind .TYPE
 
   354 sensor *tmp114 :rebindUnit.1:firstUnit @dead
   355 jump *label111 equal *tmp114 0
   356 label *label113
-    * jump *label110 always
   357 label *label109
   358 label *label110
   359 end
 
   378 label *label121
   379 set .UNIT_S1 :swap:a
   380 set .UNIT_P1 :swap:b
-    * jump *label118 always
   381 label *label117
   382 label *label118
   383 sensor .UNIT_CAPACITY .UNIT_S1 @itemCapacity
 
   386 op strictEqual *tmp124 .SPEED null
   387 jump *label122 equal *tmp124 false
   388 stop
-    * jump *label123 always
   389 label *label122
   390 label *label123
   391 set :needsFourUnits.2:unit .UNIT_S1
 
   412 op land *tmp143 *tmp140 *tmp142
   413 jump *label131 equal *tmp143 false
   414 jump *label128 always
-    * jump *label132 always
   415 label *label131
   416 label *label132
-    * jump *label130 always
   417 label *label129
   418 label *label130
   419 ubind .TYPE
 
   423 sensor *tmp147 @unit @controlled
   424 jump *label138 notEqual *tmp147 0
   425 jump *label128 always
-    * jump *label139 always
   426 label *label138
   427 label *label139
   428 ubind .TYPE
 
   432 sensor *tmp151 :rebindUnit.2:firstUnit @dead
   433 jump *label135 equal *tmp151 0
   434 label *label137
-    * jump *label134 always
   435 label *label133
   436 label *label134
   437 end
 
   453 op land *tmp161 *tmp158 *tmp160
   454 jump *label145 equal *tmp161 false
   455 jump *label142 always
-    * jump *label146 always
   456 label *label145
   457 label *label146
-    * jump *label144 always
   458 label *label143
   459 label *label144
   460 ubind .TYPE
 
   464 sensor *tmp165 @unit @controlled
   465 jump *label152 notEqual *tmp165 0
   466 jump *label142 always
-    * jump *label153 always
   467 label *label152
   468 label *label153
   469 ubind .TYPE
 
   473 sensor *tmp169 :rebindUnit.3:firstUnit @dead
   474 jump *label149 equal *tmp169 0
   475 label *label151
-    * jump *label148 always
   476 label *label147
   477 label *label148
   478 end
 
   488 label *label158
   489 sensor *tmp173 .UNIT_P2 @firstItem
   490 jump *label155 equal *tmp173 @phase-fabric
-    * jump *label157 always
   491 label *label157
   492 set :swap.1:a .UNIT_S1
   493 set :swap.1:b .UNIT_P2
 
   497 label *label159
   498 set .UNIT_S1 :swap.1:a
   499 set .UNIT_P2 :swap.1:b
-    * jump *label156 always
   500 label *label155
   501 label *label156
   502 sensor *tmp176 .UNIT_S2 @firstItem
 
   513 label *label164
   514 set .UNIT_S2 :swap.2:a
   515 set .UNIT_P2 :swap.2:b
-    * jump *label161 always
   516 label *label160
   517 label *label161
   518 set .GROUP1 "unit  1"
 
   597 op land *tmp203 *tmp200 *tmp202
   598 jump *label183 equal *tmp203 false
   599 jump *label180 always
-    * jump *label184 always
   600 label *label183
   601 label *label184
-    * jump *label182 always
   602 label *label181
   603 label *label182
   604 ubind .TYPE
 
   608 sensor *tmp207 @unit @controlled
   609 jump *label190 notEqual *tmp207 0
   610 jump *label180 always
-    * jump *label191 always
   611 label *label190
   612 label *label191
   613 ubind .TYPE
 
   617 sensor *tmp211 :rebindUnit.4:firstUnit @dead
   618 jump *label187 equal *tmp211 0
   619 label *label189
-    * jump *label186 always
   620 label *label185
   621 label *label186
   622 end
 
   643 ucontrol within .CORE_X .CORE_Y 8 *tmp223
   644 jump *label201 equal *tmp223 false
   645 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * jump *label202 always
   646 label *label201
   647 label *label202
   648 label *label200
   649 label *label198
-    * jump *label194 always
   650 label *label193
   651 label *label194
   652 jump *label203 notEqual :processUnit:state 2
 
   673 op idiv *tmp237 *tmp236 .SPEED_TENTHS
   674 op div :processUnit:distance *tmp237 10
   675 label *label206
-    * jump *label204 always
   676 label *label203
   677 label *label204
   678 jump *label209 notEqual :processUnit:state 3
 
   690 jump *label215 greaterThan *tmp244 0
   691 ucontrol approach .CORE_X .CORE_Y 6
   692 set :processUnit:state 2
-    * jump *label216 always
   693 label *label215
   694 label *label216
   695 jump *label212 always
 
   704 op idiv *tmp252 *tmp251 .SPEED_TENTHS
   705 op div :processUnit:distance *tmp252 10
   706 label *label212
-    * jump *label210 always
   707 label *label209
   708 label *label210
   709 ucontrol flag :processUnit:state
 
   746 op land *tmp267 *tmp264 *tmp266
   747 jump *label225 equal *tmp267 false
   748 jump *label222 always
-    * jump *label226 always
   749 label *label225
   750 label *label226
-    * jump *label224 always
   751 label *label223
   752 label *label224
   753 ubind .TYPE
 
   757 sensor *tmp271 @unit @controlled
   758 jump *label232 notEqual *tmp271 0
   759 jump *label222 always
-    * jump *label233 always
   760 label *label232
   761 label *label233
   762 ubind .TYPE
 
   766 sensor *tmp275 :rebindUnit.5:firstUnit @dead
   767 jump *label229 equal *tmp275 0
   768 label *label231
-    * jump *label228 always
   769 label *label227
   770 label *label228
   771 end
 
   792 ucontrol within .CORE_X .CORE_Y 8 *tmp287
   793 jump *label243 equal *tmp287 false
   794 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * jump *label244 always
   795 label *label243
   796 label *label244
   797 label *label242
   798 label *label240
-    * jump *label236 always
   799 label *label235
   800 label *label236
   801 jump *label245 notEqual :processUnit.1:state 2
 
   822 op idiv *tmp301 *tmp300 .SPEED_TENTHS
   823 op div :processUnit.1:distance *tmp301 10
   824 label *label248
-    * jump *label246 always
   825 label *label245
   826 label *label246
   827 jump *label251 notEqual :processUnit.1:state 3
 
   839 jump *label257 greaterThan *tmp308 0
   840 ucontrol approach .CORE_X .CORE_Y 6
   841 set :processUnit.1:state 2
-    * jump *label258 always
   842 label *label257
   843 label *label258
   844 jump *label254 always
 
   853 op idiv *tmp316 *tmp315 .SPEED_TENTHS
   854 op div :processUnit.1:distance *tmp316 10
   855 label *label254
-    * jump *label252 always
   856 label *label251
   857 label *label252
   858 ucontrol flag :processUnit.1:state
 
   888 op equal *tmp322 *tmp325 0
   889 label *label262
   890 set .SUPPLY_S_FIRST *tmp322
-    * jump *label220 always
   891 label *label219
   892 label *label220
   893 set :printDomeStatus.1:item @phase-fabric
 
   923 op land *tmp337 *tmp334 *tmp336
   924 jump *label270 equal *tmp337 false
   925 jump *label267 always
-    * jump *label271 always
   926 label *label270
   927 label *label271
-    * jump *label269 always
   928 label *label268
   929 label *label269
   930 ubind .TYPE
 
   934 sensor *tmp341 @unit @controlled
   935 jump *label277 notEqual *tmp341 0
   936 jump *label267 always
-    * jump *label278 always
   937 label *label277
   938 label *label278
   939 ubind .TYPE
 
   943 sensor *tmp345 :rebindUnit.6:firstUnit @dead
   944 jump *label274 equal *tmp345 0
   945 label *label276
-    * jump *label273 always
   946 label *label272
   947 label *label273
   948 end
 
   969 ucontrol within .CORE_X .CORE_Y 8 *tmp357
   970 jump *label288 equal *tmp357 false
   971 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * jump *label289 always
   972 label *label288
   973 label *label289
   974 label *label287
   975 label *label285
-    * jump *label281 always
   976 label *label280
   977 label *label281
   978 jump *label290 notEqual :processUnit.2:state 2
 
   999 op idiv *tmp371 *tmp370 .SPEED_TENTHS
  1000 op div :processUnit.2:distance *tmp371 10
  1001 label *label293
-    * jump *label291 always
  1002 label *label290
  1003 label *label291
  1004 jump *label296 notEqual :processUnit.2:state 3
 
  1016 jump *label302 greaterThan *tmp378 0
  1017 ucontrol approach .CORE_X .CORE_Y 6
  1018 set :processUnit.2:state 2
-    * jump *label303 always
  1019 label *label302
  1020 label *label303
  1021 jump *label299 always
 
  1030 op idiv *tmp386 *tmp385 .SPEED_TENTHS
  1031 op div :processUnit.2:distance *tmp386 10
  1032 label *label299
-    * jump *label297 always
  1033 label *label296
  1034 label *label297
  1035 ucontrol flag :processUnit.2:state
 
  1072 op land *tmp401 *tmp398 *tmp400
  1073 jump *label312 equal *tmp401 false
  1074 jump *label309 always
-    * jump *label313 always
  1075 label *label312
  1076 label *label313
-    * jump *label311 always
  1077 label *label310
  1078 label *label311
  1079 ubind .TYPE
 
  1083 sensor *tmp405 @unit @controlled
  1084 jump *label319 notEqual *tmp405 0
  1085 jump *label309 always
-    * jump *label320 always
  1086 label *label319
  1087 label *label320
  1088 ubind .TYPE
 
  1092 sensor *tmp409 :rebindUnit.7:firstUnit @dead
  1093 jump *label316 equal *tmp409 0
  1094 label *label318
-    * jump *label315 always
  1095 label *label314
  1096 label *label315
  1097 end
 
  1118 ucontrol within .CORE_X .CORE_Y 8 *tmp421
  1119 jump *label330 equal *tmp421 false
  1120 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * jump *label331 always
  1121 label *label330
  1122 label *label331
  1123 label *label329
  1124 label *label327
-    * jump *label323 always
  1125 label *label322
  1126 label *label323
  1127 jump *label332 notEqual :processUnit.3:state 2
 
  1148 op idiv *tmp435 *tmp434 .SPEED_TENTHS
  1149 op div :processUnit.3:distance *tmp435 10
  1150 label *label335
-    * jump *label333 always
  1151 label *label332
  1152 label *label333
  1153 jump *label338 notEqual :processUnit.3:state 3
 
  1165 jump *label344 greaterThan *tmp442 0
  1166 ucontrol approach .CORE_X .CORE_Y 6
  1167 set :processUnit.3:state 2
-    * jump *label345 always
  1168 label *label344
  1169 label *label345
  1170 jump *label341 always
 
  1179 op idiv *tmp450 *tmp449 .SPEED_TENTHS
  1180 op div :processUnit.3:distance *tmp450 10
  1181 label *label341
-    * jump *label339 always
  1182 label *label338
  1183 label *label339
  1184 ucontrol flag :processUnit.3:state
 
  1214 op equal *tmp456 *tmp459 0
  1215 label *label349
  1216 set .SUPPLY_P_FIRST *tmp456
-    * jump *label307 always
  1217 label *label306
  1218 label *label307
  1219 op sub *tmp461 @time :start
 
  1227 jump *label350 equal .TYPE UNIT_TYPE
  1228 label *label353
  1229 jump *label350 lessThanEq :unitCheck @time
-    * jump *label352 always
  1230 label *label352
  1231 set :areUnitsAvailable.2:type UNIT_TYPE
  1232 set :areUnitsAvailable.2:output false
 
  1265 jump *label369 lessThan :areUnitsAvailable.2:free :areUnitsAvailable.2:needed
  1266 set *tmp466 true
  1267 jump *label356 always
-    * jump *label370 always
  1268 label *label369
  1269 label *label370
  1270 jump *label366 always
 
  1278 sensor *tmp487 :areUnitsAvailable.2:firstUnit @dead
  1279 jump *label362 equal *tmp487 0
  1280 label *label364
-    * jump *label358 always
  1281 label *label357
  1282 label *label358
  1283 jump *label372 equal :areUnitsAvailable.2:output false
 
  1291 jump *label374 lessThanEq :areUnitsAvailable.2:needed 0
  1292 print ", needed: "
  1293 print :areUnitsAvailable.2:needed
-    * jump *label375 always
  1294 label *label374
  1295 label *label375
  1296 print "\n"
-    * jump *label373 always
  1297 label *label372
  1298 label *label373
  1299 set *tmp466 false
 
  1302 label *label356
  1303 jump *label354 equal *tmp466 false
  1304 end
-    * jump *label355 always
  1305 label *label354
  1306 label *label355
  1307 op add :unitCheck @time 5000
-    * jump *label351 always
  1308 label *label350
  1309 label *label351
  1310 label *label174
 
  1320 jump *label377 notEqual *tmp496 @this
  1321 label *label379
  1322 ulocate building core false @copper *tmp500 *tmp501 *tmp502 .CORE
-    * jump *label378 always
  1323 label *label377
  1324 label *label378
  1325 set :locateCore*retval .CORE

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-11 instructions):
 
    67 set :areUnitsAvailable:free 0
    68 set :areUnitsAvailable:occupied 0
    69 set :areUnitsAvailable:needed 0
-    * ubind :areUnitsAvailable:type
+   70 ubind UNIT_TYPE
    71 set :areUnitsAvailable:firstUnit @unit
    72 jump *label28 equal :areUnitsAvailable:firstUnit null
    73 set :needsFourUnits:unit @unit
 
    79 op div :needsFourUnits:travel_time *tmp17 *tmp18
    80 op greaterThanEq *tmp13 :needsFourUnits:travel_time 47
    81 jump *label32 always
-    * set *tmp13 null
    82 label *label32
    83 jump *label30 equal *tmp13 false
    84 set *tmp21 4
 
    95 jump *label36 notEqual *tmp24 @this
    96 label *label38
    97 op add :areUnitsAvailable:free :areUnitsAvailable:free 1
-    * jump *label40 lessThan :areUnitsAvailable:free :areUnitsAvailable:needed
+   98 jump *label40 lessThan :areUnitsAvailable:free *tmp21
    99 set *tmp10 true
   100 jump *label27 always
   101 label *label40
 
   104 label *label36
   105 op add :areUnitsAvailable:occupied :areUnitsAvailable:occupied 1
   106 label *label37
-    * ubind :areUnitsAvailable:type
+  107 ubind UNIT_TYPE
   108 label *label34
   109 jump *label35 equal @unit :areUnitsAvailable:firstUnit
   110 label *label42
 
   113 label *label35
   114 label *label28
   115 label *label29
-    * jump *label43 equal :areUnitsAvailable:output false
-    * print :areUnitsAvailable:type
+  116 jump *label43 equal true false
+  117 print UNIT_TYPE
   118 print ":"
   119 print " occupied: "
   120 print :areUnitsAvailable:occupied
 
   131 label *label44
   132 set *tmp10 false
   133 jump *label27 always
-    * set *tmp10 null
   134 label *label27
   135 jump *label25 equal *tmp10 false
   136 set *tmp9 UNIT_TYPE
 
   158 set :areUnitsAvailable.1:free 0
   159 set :areUnitsAvailable.1:occupied 0
   160 set :areUnitsAvailable.1:needed 0
-    * ubind :areUnitsAvailable.1:type
+  161 ubind :chooseUnitType:type
   162 set :areUnitsAvailable.1:firstUnit @unit
   163 jump *label59 equal :areUnitsAvailable.1:firstUnit null
   164 set :needsFourUnits.1:unit @unit
 
   170 op div :needsFourUnits.1:travel_time *tmp47 *tmp48
   171 op greaterThanEq *tmp43 :needsFourUnits.1:travel_time 47
   172 jump *label63 always
-    * set *tmp43 null
   173 label *label63
   174 jump *label61 equal *tmp43 false
   175 set *tmp51 4
 
   186 jump *label67 notEqual *tmp54 @this
   187 label *label69
   188 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
-    * jump *label71 lessThan :areUnitsAvailable.1:free :areUnitsAvailable.1:needed
+  189 jump *label71 lessThan :areUnitsAvailable.1:free *tmp51
   190 set *tmp40 true
   191 jump *label58 always
   192 label *label71
 
   195 label *label67
   196 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   197 label *label68
-    * ubind :areUnitsAvailable.1:type
+  198 ubind :chooseUnitType:type
   199 label *label65
   200 jump *label66 equal @unit :areUnitsAvailable.1:firstUnit
   201 label *label73
 
   204 label *label66
   205 label *label59
   206 label *label60
-    * jump *label74 equal :areUnitsAvailable.1:output false
-    * print :areUnitsAvailable.1:type
+  207 jump *label74 equal true false
+  208 print :chooseUnitType:type
   209 print ":"
   210 print " occupied: "
   211 print :areUnitsAvailable.1:occupied
 
   222 label *label75
   223 set *tmp40 false
   224 jump *label58 always
-    * set *tmp40 null
   225 label *label58
   226 jump *label56 equal *tmp40 false
   227 printflush null
 
   245 print "[gold]Binding units..."
   246 printflush message1
   247 set .UNIT_P2 null
-    * set .UNIT_S2 .UNIT_P2
-    * set .UNIT_P1 .UNIT_S2
-    * set .UNIT_S1 .UNIT_P1
+  248 set .UNIT_S2 null
+  249 set .UNIT_P1 .UNIT_P2
+  250 set .UNIT_S1 .UNIT_S2
   251 set :rebindUnits:count 0
-    * ubind .TYPE
+  252 ubind *tmp9
   253 set :rebindUnits:firstUnit @unit
   254 jump *label79 notEqual :rebindUnits:firstUnit null
   255 end
 
   270 label *label87
   271 label *label84
   272 label *label85
-    * ubind .TYPE
+  273 ubind *tmp9
   274 label *label82
   275 jump *label83 equal @unit :rebindUnits:firstUnit
   276 label *label88
 
   279 label *label83
   280 label *label78
   281 set :acquireUnit:currentUnit .UNIT_S1
-    * set :rebindUnit:currentUnit :acquireUnit:currentUnit
-    * jump *label91 equal :rebindUnit:currentUnit null
-    * ubind :rebindUnit:currentUnit
+  282 set :rebindUnit:currentUnit .UNIT_S1
+  283 jump *label91 equal :acquireUnit:currentUnit null
+  284 ubind :acquireUnit:currentUnit
   285 sensor *tmp84 @unit @dead
   286 op equal *tmp85 *tmp84 0
   287 sensor *tmp86 @unit @controller
 
   293 label *label94
   294 label *label91
   295 label *label92
-    * ubind .TYPE
+  296 ubind *tmp9
   297 set :rebindUnit:firstUnit @unit
   298 jump *label95 equal :rebindUnit:firstUnit null
   299 label *label97
 
   302 jump *label90 always
   303 label *label100
   304 label *label101
-    * ubind .TYPE
+  305 ubind *tmp9
   306 label *label98
   307 jump *label99 equal @unit :rebindUnit:firstUnit
   308 label *label102
 
   316 ucontrol flag 1
   317 set *tmp80 @unit
   318 jump *label89 always
-    * set *tmp80 null
   319 label *label89
   320 set .UNIT_S1 *tmp80
   321 set :acquireUnit.1:currentUnit .UNIT_P1
-    * set :rebindUnit.1:currentUnit :acquireUnit.1:currentUnit
-    * jump *label105 equal :rebindUnit.1:currentUnit null
-    * ubind :rebindUnit.1:currentUnit
+  322 set :rebindUnit.1:currentUnit .UNIT_P1
+  323 jump *label105 equal :acquireUnit.1:currentUnit null
+  324 ubind :acquireUnit.1:currentUnit
   325 sensor *tmp102 @unit @dead
   326 op equal *tmp103 *tmp102 0
   327 sensor *tmp104 @unit @controller
 
   333 label *label108
   334 label *label105
   335 label *label106
-    * ubind .TYPE
+  336 ubind *tmp9
   337 set :rebindUnit.1:firstUnit @unit
   338 jump *label109 equal :rebindUnit.1:firstUnit null
   339 label *label111
 
   342 jump *label104 always
   343 label *label114
   344 label *label115
-    * ubind .TYPE
+  345 ubind *tmp9
   346 label *label112
   347 jump *label113 equal @unit :rebindUnit.1:firstUnit
   348 label *label116
 
   356 ucontrol flag 1
   357 set *tmp98 @unit
   358 jump *label103 always
-    * set *tmp98 null
   359 label *label103
   360 set .UNIT_P1 *tmp98
-    * sensor *tmp116 .UNIT_S1 @firstItem
+  361 sensor *tmp116 *tmp80 @firstItem
   362 jump *label119 equal *tmp116 @phase-fabric
   363 label *label120
-    * sensor *tmp118 .UNIT_P1 @firstItem
+  364 sensor *tmp118 *tmp98 @firstItem
   365 jump *label117 notEqual *tmp118 @silicon
   366 label *label119
-    * set :swap:a .UNIT_S1
-    * set :swap:b .UNIT_P1
-    * set :swap:t :swap:a
-    * set :swap:a :swap:b
+  367 set :swap:a *tmp80
+  368 set :swap:b *tmp98
+  369 set :swap:t .UNIT_S1
+  370 set :swap:a .UNIT_P1
   371 set :swap:b :swap:t
   372 label *label121
   373 set .UNIT_S1 :swap:a
-    * set .UNIT_P1 :swap:b
+  374 set .UNIT_P1 :swap:t
   375 label *label117
   376 label *label118
   377 sensor .UNIT_CAPACITY .UNIT_S1 @itemCapacity
 
   387 op sub *tmp128 .DOME_Y .CORE_Y
   388 op len *tmp129 *tmp127 *tmp128
   389 op mul *tmp130 2 *tmp129
-    * sensor *tmp131 :needsFourUnits.2:unit @speed
-    * op div :needsFourUnits.2:travel_time *tmp130 *tmp131
+  390 sensor *tmp131 .UNIT_S1 @speed
+  391 op div :needsFourUnits.2:travel_time *tmp130 .SPEED
   392 op greaterThanEq *tmp126 :needsFourUnits.2:travel_time 47
   393 jump *label124 always
-    * set *tmp126 null
   394 label *label124
   395 set .FOUR_UNITS *tmp126
-    * jump *label125 equal .FOUR_UNITS false
+  396 jump *label125 equal *tmp126 false
   397 set :acquireUnit.2:currentUnit .UNIT_S2
-    * set :rebindUnit.2:currentUnit :acquireUnit.2:currentUnit
-    * jump *label129 equal :rebindUnit.2:currentUnit null
-    * ubind :rebindUnit.2:currentUnit
+  398 set :rebindUnit.2:currentUnit .UNIT_S2
+  399 jump *label129 equal :acquireUnit.2:currentUnit null
+  400 ubind :acquireUnit.2:currentUnit
   401 sensor *tmp139 @unit @dead
   402 op equal *tmp140 *tmp139 0
   403 sensor *tmp141 @unit @controller
 
   409 label *label132
   410 label *label129
   411 label *label130
-    * ubind .TYPE
+  412 ubind *tmp9
   413 set :rebindUnit.2:firstUnit @unit
   414 jump *label133 equal :rebindUnit.2:firstUnit null
   415 label *label135
 
   418 jump *label128 always
   419 label *label138
   420 label *label139
-    * ubind .TYPE
+  421 ubind *tmp9
   422 label *label136
   423 jump *label137 equal @unit :rebindUnit.2:firstUnit
   424 label *label140
 
   432 ucontrol flag 1
   433 set *tmp135 @unit
   434 jump *label127 always
-    * set *tmp135 null
   435 label *label127
   436 set .UNIT_S2 *tmp135
   437 set :acquireUnit.3:currentUnit .UNIT_P2
-    * set :rebindUnit.3:currentUnit :acquireUnit.3:currentUnit
-    * jump *label143 equal :rebindUnit.3:currentUnit null
-    * ubind :rebindUnit.3:currentUnit
+  438 set :rebindUnit.3:currentUnit .UNIT_P2
+  439 jump *label143 equal :acquireUnit.3:currentUnit null
+  440 ubind :acquireUnit.3:currentUnit
   441 sensor *tmp157 @unit @dead
   442 op equal *tmp158 *tmp157 0
   443 sensor *tmp159 @unit @controller
 
   449 label *label146
   450 label *label143
   451 label *label144
-    * ubind .TYPE
+  452 ubind *tmp9
   453 set :rebindUnit.3:firstUnit @unit
   454 jump *label147 equal :rebindUnit.3:firstUnit null
   455 label *label149
 
   458 jump *label142 always
   459 label *label152
   460 label *label153
-    * ubind .TYPE
+  461 ubind *tmp9
   462 label *label150
   463 jump *label151 equal @unit :rebindUnit.3:firstUnit
   464 label *label154
 
   472 ucontrol flag 1
   473 set *tmp153 @unit
   474 jump *label141 always
-    * set *tmp153 null
   475 label *label141
   476 set .UNIT_P2 *tmp153
   477 sensor *tmp171 .UNIT_S1 @firstItem
   478 jump *label155 notEqual *tmp171 @phase-fabric
   479 label *label158
-    * sensor *tmp173 .UNIT_P2 @firstItem
+  480 sensor *tmp173 *tmp153 @firstItem
   481 jump *label155 equal *tmp173 @phase-fabric
   482 label *label157
   483 set :swap.1:a .UNIT_S1
-    * set :swap.1:b .UNIT_P2
-    * set :swap.1:t :swap.1:a
-    * set :swap.1:a :swap.1:b
+  484 set :swap.1:b *tmp153
+  485 set :swap.1:t .UNIT_S1
+  486 set :swap.1:a .UNIT_P2
   487 set :swap.1:b :swap.1:t
   488 label *label159
   489 set .UNIT_S1 :swap.1:a
-    * set .UNIT_P2 :swap.1:b
+  490 set .UNIT_P2 :swap.1:t
   491 label *label155
   492 label *label156
-    * sensor *tmp176 .UNIT_S2 @firstItem
+  493 sensor *tmp176 *tmp135 @firstItem
   494 jump *label162 equal *tmp176 @phase-fabric
   495 label *label163
   496 sensor *tmp178 .UNIT_P2 @firstItem
   497 jump *label160 notEqual *tmp178 @silicon
   498 label *label162
-    * set :swap.2:a .UNIT_S2
+  499 set :swap.2:a *tmp135
   500 set :swap.2:b .UNIT_P2
-    * set :swap.2:t :swap.2:a
-    * set :swap.2:a :swap.2:b
+  501 set :swap.2:t .UNIT_S2
+  502 set :swap.2:a .UNIT_P2
   503 set :swap.2:b :swap.2:t
   504 label *label164
   505 set .UNIT_S2 :swap.2:a
-    * set .UNIT_P2 :swap.2:b
+  506 set .UNIT_P2 :swap.2:t
   507 label *label160
   508 label *label161
   509 set .GROUP1 "unit  1"
 
   518 set .UNIT_P2 null
   519 set .GROUP1 "unit"
   520 label *label126
-    * jump *label167 equal .FOUR_UNITS false
+  521 jump *label167 equal *tmp126 false
   522 label *label168
   523 sensor *tmp182 .UNIT_S1 @totalItems
   524 sensor *tmp183 .UNIT_S2 @totalItems
 
   530 set *tmp185 false
   531 label *label166
   532 set .SUPPLY_S_FIRST *tmp185
-    * jump *label171 equal .FOUR_UNITS false
+  533 jump *label171 equal *tmp126 false
   534 label *label172
   535 sensor *tmp187 .UNIT_P1 @totalItems
   536 sensor *tmp188 .UNIT_P2 @totalItems
 
   551 print "\n"
   552 print "\n"
   553 print "Unit type: [green]"
-    * print .TYPE
+  554 print *tmp9
   555 print "["
   556 print "]"
   557 print "\n"
   558 set :printDomeStatus:item @silicon
   559 set :printDomeStatus:text "\n[green]Silicon[] status:\n"
-    * print :printDomeStatus:text
-    * sensor :printDomeStatus:level .DOME :printDomeStatus:item
+  560 print "\n[green]Silicon[] status:\n"
+  561 sensor :printDomeStatus:level .DOME @silicon
   562 jump *label177 lessThanEq :printDomeStatus:level 3
   563 print "  dome:  [green]"
   564 print :printDomeStatus:level
 
   578 set :processUnit:item @silicon
   579 set :processUnit:group .GROUP1
   580 set :processUnit:supply .SUPPLY_S_FIRST
-    * set :rebindUnit.4:currentUnit :processUnit:unit
-    * jump *label181 equal :rebindUnit.4:currentUnit null
-    * ubind :rebindUnit.4:currentUnit
+  581 set :rebindUnit.4:currentUnit .UNIT_S1
+  582 jump *label181 equal :processUnit:unit null
+  583 ubind :processUnit:unit
   584 sensor *tmp199 @unit @dead
   585 op equal *tmp200 *tmp199 0
   586 sensor *tmp201 @unit @controller
 
   592 label *label184
   593 label *label181
   594 label *label182
-    * ubind .TYPE
+  595 ubind *tmp9
   596 set :rebindUnit.4:firstUnit @unit
   597 jump *label185 equal :rebindUnit.4:firstUnit null
   598 label *label187
 
   601 jump *label180 always
   602 label *label190
   603 label *label191
-    * ubind .TYPE
+  604 ubind *tmp9
   605 label *label188
   606 jump *label189 equal @unit :rebindUnit.4:firstUnit
   607 label *label192
 
   620 jump *label193 lessThanEq :processUnit:state 3
   621 label *label195
   622 sensor *tmp217 @unit @firstItem
-    * jump *label197 notEqual *tmp217 :processUnit:item
+  623 jump *label197 notEqual *tmp217 @silicon
   624 set :processUnit:state 3
   625 jump *label198 always
   626 label *label197
 
   643 jump *label203 notEqual :processUnit:state 2
   644 ucontrol within .CORE_X .CORE_Y 8 *tmp227
   645 jump *label205 equal *tmp227 false
-    * ucontrol itemTake .CORE :processUnit:item .UNIT_CAPACITY
+  646 ucontrol itemTake .CORE @silicon .UNIT_CAPACITY
   647 sensor *tmp229 @unit @totalItems
   648 jump *label207 lessThan *tmp229 .UNIT_CAPACITY
   649 ucontrol approach .DOME_X .DOME_Y 6
 
   669 jump *label209 notEqual :processUnit:state 3
   670 ucontrol within .DOME_X .DOME_Y 8 *tmp241
   671 jump *label211 equal *tmp241 false
-    * jump *label213 equal :processUnit:supply false
+  672 jump *label213 equal .SUPPLY_S_FIRST false
   673 ucontrol itemDrop .DOME .UNIT_CAPACITY
   674 set .MSG ", supplying\n"
   675 jump *label214 always
 
   700 ucontrol flag :processUnit:state
   701 sensor *tmp254 @unit @totalItems
   702 print "  "
-    * print :processUnit:group
+  703 print .GROUP1
   704 print ":"
   705 print " ["
-    * print :processUnit:color
+  706 print "gold"
   707 print "]"
   708 print *tmp254
   709 print "["
 
   721 set :processUnit:unit @unit
   722 label *label179
   723 set .UNIT_S1 :processUnit:unit
-    * jump *label219 equal .FOUR_UNITS false
+  724 jump *label219 equal *tmp126 false
   725 op equal *tmp259 .SUPPLY_S_FIRST false
   726 set :processUnit.1:unit .UNIT_S2
   727 set :processUnit.1:item @silicon
   728 set :processUnit.1:group .GROUP2
   729 set :processUnit.1:supply *tmp259
-    * set :rebindUnit.5:currentUnit :processUnit.1:unit
-    * jump *label223 equal :rebindUnit.5:currentUnit null
-    * ubind :rebindUnit.5:currentUnit
+  730 set :rebindUnit.5:currentUnit .UNIT_S2
+  731 jump *label223 equal :processUnit.1:unit null
+  732 ubind :processUnit.1:unit
   733 sensor *tmp263 @unit @dead
   734 op equal *tmp264 *tmp263 0
   735 sensor *tmp265 @unit @controller
 
   741 label *label226
   742 label *label223
   743 label *label224
-    * ubind .TYPE
+  744 ubind *tmp9
   745 set :rebindUnit.5:firstUnit @unit
   746 jump *label227 equal :rebindUnit.5:firstUnit null
   747 label *label229
 
   750 jump *label222 always
   751 label *label232
   752 label *label233
-    * ubind .TYPE
+  753 ubind *tmp9
   754 label *label230
   755 jump *label231 equal @unit :rebindUnit.5:firstUnit
   756 label *label234
 
   769 jump *label235 lessThanEq :processUnit.1:state 3
   770 label *label237
   771 sensor *tmp281 @unit @firstItem
-    * jump *label239 notEqual *tmp281 :processUnit.1:item
+  772 jump *label239 notEqual *tmp281 @silicon
   773 set :processUnit.1:state 3
   774 jump *label240 always
   775 label *label239
 
   792 jump *label245 notEqual :processUnit.1:state 2
   793 ucontrol within .CORE_X .CORE_Y 8 *tmp291
   794 jump *label247 equal *tmp291 false
-    * ucontrol itemTake .CORE :processUnit.1:item .UNIT_CAPACITY
+  795 ucontrol itemTake .CORE @silicon .UNIT_CAPACITY
   796 sensor *tmp293 @unit @totalItems
   797 jump *label249 lessThan *tmp293 .UNIT_CAPACITY
   798 ucontrol approach .DOME_X .DOME_Y 6
 
   818 jump *label251 notEqual :processUnit.1:state 3
   819 ucontrol within .DOME_X .DOME_Y 8 *tmp305
   820 jump *label253 equal *tmp305 false
-    * jump *label255 equal :processUnit.1:supply false
+  821 jump *label255 equal *tmp259 false
   822 ucontrol itemDrop .DOME .UNIT_CAPACITY
   823 set .MSG ", supplying\n"
   824 jump *label256 always
 
   849 ucontrol flag :processUnit.1:state
   850 sensor *tmp318 @unit @totalItems
   851 print "  "
-    * print :processUnit.1:group
+  852 print .GROUP2
   853 print ":"
   854 print " ["
-    * print :processUnit.1:color
+  855 print "gold"
   856 print "]"
   857 print *tmp318
   858 print "["
 
   871 label *label221
   872 set .UNIT_S2 :processUnit.1:unit
   873 jump *label261 equal .SUPPLY_S_FIRST false
-    * sensor *tmp323 .UNIT_S1 @totalItems
+  874 sensor *tmp323 :processUnit:unit @totalItems
   875 op greaterThan *tmp322 *tmp323 0
   876 jump *label262 always
   877 label *label261
-    * sensor *tmp325 .UNIT_S2 @totalItems
+  878 sensor *tmp325 :processUnit.1:unit @totalItems
   879 op equal *tmp322 *tmp325 0
   880 label *label262
   881 set .SUPPLY_S_FIRST *tmp322
 
   883 label *label220
   884 set :printDomeStatus.1:item @phase-fabric
   885 set :printDomeStatus.1:text "\n[green]Phase fabric[] status:\n"
-    * print :printDomeStatus.1:text
-    * sensor :printDomeStatus.1:level .DOME :printDomeStatus.1:item
+  886 print "\n[green]Phase fabric[] status:\n"
+  887 sensor :printDomeStatus.1:level .DOME @phase-fabric
   888 jump *label264 lessThanEq :printDomeStatus.1:level 3
   889 print "  dome:  [green]"
   890 print :printDomeStatus.1:level
 
   904 set :processUnit.2:item @phase-fabric
   905 set :processUnit.2:group .GROUP1
   906 set :processUnit.2:supply .SUPPLY_P_FIRST
-    * set :rebindUnit.6:currentUnit :processUnit.2:unit
-    * jump *label268 equal :rebindUnit.6:currentUnit null
-    * ubind :rebindUnit.6:currentUnit
+  907 set :rebindUnit.6:currentUnit .UNIT_P1
+  908 jump *label268 equal :processUnit.2:unit null
+  909 ubind :processUnit.2:unit
   910 sensor *tmp333 @unit @dead
   911 op equal *tmp334 *tmp333 0
   912 sensor *tmp335 @unit @controller
 
   918 label *label271
   919 label *label268
   920 label *label269
-    * ubind .TYPE
+  921 ubind *tmp9
   922 set :rebindUnit.6:firstUnit @unit
   923 jump *label272 equal :rebindUnit.6:firstUnit null
   924 label *label274
 
   927 jump *label267 always
   928 label *label277
   929 label *label278
-    * ubind .TYPE
+  930 ubind *tmp9
   931 label *label275
   932 jump *label276 equal @unit :rebindUnit.6:firstUnit
   933 label *label279
 
   946 jump *label280 lessThanEq :processUnit.2:state 3
   947 label *label282
   948 sensor *tmp351 @unit @firstItem
-    * jump *label284 notEqual *tmp351 :processUnit.2:item
+  949 jump *label284 notEqual *tmp351 @phase-fabric
   950 set :processUnit.2:state 3
   951 jump *label285 always
   952 label *label284
 
   969 jump *label290 notEqual :processUnit.2:state 2
   970 ucontrol within .CORE_X .CORE_Y 8 *tmp361
   971 jump *label292 equal *tmp361 false
-    * ucontrol itemTake .CORE :processUnit.2:item .UNIT_CAPACITY
+  972 ucontrol itemTake .CORE @phase-fabric .UNIT_CAPACITY
   973 sensor *tmp363 @unit @totalItems
   974 jump *label294 lessThan *tmp363 .UNIT_CAPACITY
   975 ucontrol approach .DOME_X .DOME_Y 6
 
   995 jump *label296 notEqual :processUnit.2:state 3
   996 ucontrol within .DOME_X .DOME_Y 8 *tmp375
   997 jump *label298 equal *tmp375 false
-    * jump *label300 equal :processUnit.2:supply false
+  998 jump *label300 equal .SUPPLY_P_FIRST false
   999 ucontrol itemDrop .DOME .UNIT_CAPACITY
  1000 set .MSG ", supplying\n"
  1001 jump *label301 always
 
  1026 ucontrol flag :processUnit.2:state
  1027 sensor *tmp388 @unit @totalItems
  1028 print "  "
-    * print :processUnit.2:group
+ 1029 print .GROUP1
  1030 print ":"
  1031 print " ["
-    * print :processUnit.2:color
+ 1032 print "gold"
  1033 print "]"
  1034 print *tmp388
  1035 print "["
 
  1047 set :processUnit.2:unit @unit
  1048 label *label266
  1049 set .UNIT_P1 :processUnit.2:unit
-    * jump *label306 equal .FOUR_UNITS false
+ 1050 jump *label306 equal *tmp126 false
  1051 op equal *tmp393 .SUPPLY_P_FIRST false
  1052 set :processUnit.3:unit .UNIT_P2
  1053 set :processUnit.3:item @phase-fabric
  1054 set :processUnit.3:group .GROUP2
  1055 set :processUnit.3:supply *tmp393
-    * set :rebindUnit.7:currentUnit :processUnit.3:unit
-    * jump *label310 equal :rebindUnit.7:currentUnit null
-    * ubind :rebindUnit.7:currentUnit
+ 1056 set :rebindUnit.7:currentUnit .UNIT_P2
+ 1057 jump *label310 equal :processUnit.3:unit null
+ 1058 ubind :processUnit.3:unit
  1059 sensor *tmp397 @unit @dead
  1060 op equal *tmp398 *tmp397 0
  1061 sensor *tmp399 @unit @controller
 
  1067 label *label313
  1068 label *label310
  1069 label *label311
-    * ubind .TYPE
+ 1070 ubind *tmp9
  1071 set :rebindUnit.7:firstUnit @unit
  1072 jump *label314 equal :rebindUnit.7:firstUnit null
  1073 label *label316
 
  1076 jump *label309 always
  1077 label *label319
  1078 label *label320
-    * ubind .TYPE
+ 1079 ubind *tmp9
  1080 label *label317
  1081 jump *label318 equal @unit :rebindUnit.7:firstUnit
  1082 label *label321
 
  1095 jump *label322 lessThanEq :processUnit.3:state 3
  1096 label *label324
  1097 sensor *tmp415 @unit @firstItem
-    * jump *label326 notEqual *tmp415 :processUnit.3:item
+ 1098 jump *label326 notEqual *tmp415 @phase-fabric
  1099 set :processUnit.3:state 3
  1100 jump *label327 always
  1101 label *label326
 
  1118 jump *label332 notEqual :processUnit.3:state 2
  1119 ucontrol within .CORE_X .CORE_Y 8 *tmp425
  1120 jump *label334 equal *tmp425 false
-    * ucontrol itemTake .CORE :processUnit.3:item .UNIT_CAPACITY
+ 1121 ucontrol itemTake .CORE @phase-fabric .UNIT_CAPACITY
  1122 sensor *tmp427 @unit @totalItems
  1123 jump *label336 lessThan *tmp427 .UNIT_CAPACITY
  1124 ucontrol approach .DOME_X .DOME_Y 6
 
  1144 jump *label338 notEqual :processUnit.3:state 3
  1145 ucontrol within .DOME_X .DOME_Y 8 *tmp439
  1146 jump *label340 equal *tmp439 false
-    * jump *label342 equal :processUnit.3:supply false
+ 1147 jump *label342 equal *tmp393 false
  1148 ucontrol itemDrop .DOME .UNIT_CAPACITY
  1149 set .MSG ", supplying\n"
  1150 jump *label343 always
 
  1175 ucontrol flag :processUnit.3:state
  1176 sensor *tmp452 @unit @totalItems
  1177 print "  "
-    * print :processUnit.3:group
+ 1178 print .GROUP2
  1179 print ":"
  1180 print " ["
-    * print :processUnit.3:color
+ 1181 print "gold"
  1182 print "]"
  1183 print *tmp452
  1184 print "["
 
  1197 label *label308
  1198 set .UNIT_P2 :processUnit.3:unit
  1199 jump *label348 equal .SUPPLY_P_FIRST false
-    * sensor *tmp457 .UNIT_P1 @totalItems
+ 1200 sensor *tmp457 :processUnit.2:unit @totalItems
  1201 op greaterThan *tmp456 *tmp457 0
  1202 jump *label349 always
  1203 label *label348
-    * sensor *tmp459 .UNIT_P2 @totalItems
+ 1204 sensor *tmp459 :processUnit.3:unit @totalItems
  1205 op equal *tmp456 *tmp459 0
  1206 label *label349
  1207 set .SUPPLY_P_FIRST *tmp456
 
  1215 print " "
  1216 print "ms"
  1217 printflush message1
-    * jump *label350 equal .TYPE UNIT_TYPE
+ 1218 jump *label350 equal *tmp9 UNIT_TYPE
  1219 label *label353
  1220 jump *label350 lessThanEq :unitCheck @time
  1221 label *label352
 
  1224 set :areUnitsAvailable.2:free 0
  1225 set :areUnitsAvailable.2:occupied 0
  1226 set :areUnitsAvailable.2:needed 0
-    * ubind :areUnitsAvailable.2:type
+ 1227 ubind UNIT_TYPE
  1228 set :areUnitsAvailable.2:firstUnit @unit
  1229 jump *label357 equal :areUnitsAvailable.2:firstUnit null
  1230 set :needsFourUnits.3:unit @unit
  1231 op sub *tmp470 .DOME_X .CORE_X
  1232 op sub *tmp471 .DOME_Y .CORE_Y
-    * op len *tmp472 *tmp470 *tmp471
-    * op mul *tmp473 2 *tmp472
+ 1233 op len *tmp472 *tmp127 *tmp128
+ 1234 op mul *tmp473 2 *tmp129
  1235 sensor *tmp474 :needsFourUnits.3:unit @speed
-    * op div :needsFourUnits.3:travel_time *tmp473 *tmp474
+ 1236 op div :needsFourUnits.3:travel_time *tmp130 *tmp474
  1237 op greaterThanEq *tmp469 :needsFourUnits.3:travel_time 47
  1238 jump *label361 always
-    * set *tmp469 null
  1239 label *label361
  1240 jump *label359 equal *tmp469 false
  1241 set *tmp477 4
 
  1252 jump *label365 notEqual *tmp480 @this
  1253 label *label367
  1254 op add :areUnitsAvailable.2:free :areUnitsAvailable.2:free 1
-    * jump *label369 lessThan :areUnitsAvailable.2:free :areUnitsAvailable.2:needed
+ 1255 jump *label369 lessThan :areUnitsAvailable.2:free *tmp477
  1256 set *tmp466 true
  1257 jump *label356 always
  1258 label *label369
 
  1261 label *label365
  1262 op add :areUnitsAvailable.2:occupied :areUnitsAvailable.2:occupied 1
  1263 label *label366
-    * ubind :areUnitsAvailable.2:type
+ 1264 ubind UNIT_TYPE
  1265 label *label363
  1266 jump *label364 equal @unit :areUnitsAvailable.2:firstUnit
  1267 label *label371
 
  1270 label *label364
  1271 label *label357
  1272 label *label358
-    * jump *label372 equal :areUnitsAvailable.2:output false
-    * print :areUnitsAvailable.2:type
+ 1273 jump *label372 equal false false
+ 1274 print UNIT_TYPE
  1275 print ":"
  1276 print " occupied: "
  1277 print :areUnitsAvailable.2:occupied
 
  1288 label *label373
  1289 set *tmp466 false
  1290 jump *label356 always
-    * set *tmp466 null
  1291 label *label356
  1292 jump *label354 equal *tmp466 false
  1293 end

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-48 instructions):
 
    62 printflush null
    63 print "[gold]Looking for suitable unit type:[]"
    64 print "\n"
-    * set :areUnitsAvailable:type UNIT_TYPE
-    * set :areUnitsAvailable:output true
    65 set :areUnitsAvailable:free 0
    66 set :areUnitsAvailable:occupied 0
    67 set :areUnitsAvailable:needed 0
 
   151 setaddr *tmp37 *label53
   152 label *label47
   153 jump *label54 equal :chooseUnitType:type UNIT_TYPE
-    * set :areUnitsAvailable.1:type :chooseUnitType:type
-    * set :areUnitsAvailable.1:output true
   154 set :areUnitsAvailable.1:free 0
   155 set :areUnitsAvailable.1:occupied 0
   156 set :areUnitsAvailable.1:needed 0
 
   237 label *label24
   238 set *tmp9 null
   239 label *label21
-    * set .TYPE *tmp9
   240 print "[gold]Binding units..."
   241 printflush message1
   242 set .UNIT_P2 null
   243 set .UNIT_S2 null
-    * set .UNIT_P1 .UNIT_P2
-    * set .UNIT_S1 .UNIT_S2
+  244 set .UNIT_P1 null
+  245 set .UNIT_S1 null
   246 set :rebindUnits:count 0
   247 ubind *tmp9
   248 set :rebindUnits:firstUnit @unit
 
   274 label *label83
   275 label *label78
   276 set :acquireUnit:currentUnit .UNIT_S1
-    * set :rebindUnit:currentUnit .UNIT_S1
-    * jump *label91 equal :acquireUnit:currentUnit null
-    * ubind :acquireUnit:currentUnit
+  277 jump *label91 equal .UNIT_S1 null
+  278 ubind .UNIT_S1
   279 sensor *tmp84 @unit @dead
   280 op equal *tmp85 *tmp84 0
   281 sensor *tmp86 @unit @controller
 
   313 label *label89
   314 set .UNIT_S1 *tmp80
   315 set :acquireUnit.1:currentUnit .UNIT_P1
-    * set :rebindUnit.1:currentUnit .UNIT_P1
-    * jump *label105 equal :acquireUnit.1:currentUnit null
-    * ubind :acquireUnit.1:currentUnit
+  316 jump *label105 equal .UNIT_P1 null
+  317 ubind .UNIT_P1
   318 sensor *tmp102 @unit @dead
   319 op equal *tmp103 *tmp102 0
   320 sensor *tmp104 @unit @controller
 
   357 sensor *tmp118 *tmp98 @firstItem
   358 jump *label117 notEqual *tmp118 @silicon
   359 label *label119
-    * set :swap:a *tmp80
-    * set :swap:b *tmp98
-    * set :swap:t .UNIT_S1
-    * set :swap:a .UNIT_P1
-    * set :swap:b :swap:t
+  360 set :swap:t *tmp80
+  361 set :swap:a *tmp98
+  362 set :swap:b .UNIT_S1
   363 label *label121
-    * set .UNIT_S1 :swap:a
+  364 set .UNIT_S1 .UNIT_P1
   365 set .UNIT_P1 :swap:t
   366 label *label117
   367 label *label118
 
   373 stop
   374 label *label122
   375 label *label123
-    * set :needsFourUnits.2:unit .UNIT_S1
   376 op sub *tmp127 .DOME_X .CORE_X
   377 op sub *tmp128 .DOME_Y .CORE_Y
   378 op len *tmp129 *tmp127 *tmp128
   379 op mul *tmp130 2 *tmp129
-    * sensor *tmp131 .UNIT_S1 @speed
   380 op div :needsFourUnits.2:travel_time *tmp130 .SPEED
   381 op greaterThanEq *tmp126 :needsFourUnits.2:travel_time 47
   382 jump *label124 always
   383 label *label124
-    * set .FOUR_UNITS *tmp126
   384 jump *label125 equal *tmp126 false
   385 set :acquireUnit.2:currentUnit .UNIT_S2
-    * set :rebindUnit.2:currentUnit .UNIT_S2
-    * jump *label129 equal :acquireUnit.2:currentUnit null
-    * ubind :acquireUnit.2:currentUnit
+  386 jump *label129 equal .UNIT_S2 null
+  387 ubind .UNIT_S2
   388 sensor *tmp139 @unit @dead
   389 op equal *tmp140 *tmp139 0
   390 sensor *tmp141 @unit @controller
 
   422 label *label127
   423 set .UNIT_S2 *tmp135
   424 set :acquireUnit.3:currentUnit .UNIT_P2
-    * set :rebindUnit.3:currentUnit .UNIT_P2
-    * jump *label143 equal :acquireUnit.3:currentUnit null
-    * ubind :acquireUnit.3:currentUnit
+  425 jump *label143 equal .UNIT_P2 null
+  426 ubind .UNIT_P2
   427 sensor *tmp157 @unit @dead
   428 op equal *tmp158 *tmp157 0
   429 sensor *tmp159 @unit @controller
 
   466 sensor *tmp173 *tmp153 @firstItem
   467 jump *label155 equal *tmp173 @phase-fabric
   468 label *label157
-    * set :swap.1:a .UNIT_S1
-    * set :swap.1:b *tmp153
   469 set :swap.1:t .UNIT_S1
-    * set :swap.1:a .UNIT_P2
-    * set :swap.1:b :swap.1:t
+  470 set :swap.1:a *tmp153
+  471 set :swap.1:b .UNIT_S1
   472 label *label159
-    * set .UNIT_S1 :swap.1:a
+  473 set .UNIT_S1 .UNIT_P2
   474 set .UNIT_P2 :swap.1:t
   475 label *label155
   476 label *label156
 
   480 sensor *tmp178 .UNIT_P2 @firstItem
   481 jump *label160 notEqual *tmp178 @silicon
   482 label *label162
-    * set :swap.2:a *tmp135
-    * set :swap.2:b .UNIT_P2
-    * set :swap.2:t .UNIT_S2
+  483 set :swap.2:t *tmp135
   484 set :swap.2:a .UNIT_P2
-    * set :swap.2:b :swap.2:t
+  485 set :swap.2:b .UNIT_S2
   486 label *label164
-    * set .UNIT_S2 :swap.2:a
+  487 set .UNIT_S2 .UNIT_P2
   488 set .UNIT_P2 :swap.2:t
   489 label *label160
   490 label *label161
 
   537 print "["
   538 print "]"
   539 print "\n"
-    * set :printDomeStatus:item @silicon
-    * set :printDomeStatus:text "\n[green]Silicon[] status:\n"
   540 print "\n[green]Silicon[] status:\n"
   541 sensor :printDomeStatus:level .DOME @silicon
   542 jump *label177 lessThanEq :printDomeStatus:level 3
 
   555 label *label178
   556 label *label176
   557 set :processUnit:unit .UNIT_S1
-    * set :processUnit:item @silicon
-    * set :processUnit:group .GROUP1
-    * set :processUnit:supply .SUPPLY_S_FIRST
-    * set :rebindUnit.4:currentUnit .UNIT_S1
-    * jump *label181 equal :processUnit:unit null
-    * ubind :processUnit:unit
+  558 jump *label181 equal .UNIT_S1 null
+  559 ubind .UNIT_S1
   560 sensor *tmp199 @unit @dead
   561 op equal *tmp200 *tmp199 0
   562 sensor *tmp201 @unit @controller
 
   590 label *label180
   591 sensor :processUnit:state @unit @flag
   592 set :processUnit:distance -1
-    * set :processUnit:color "gold"
   593 jump *label195 lessThan :processUnit:state 2
   594 label *label196
   595 jump *label193 lessThanEq :processUnit:state 3
 
   699 jump *label219 equal *tmp126 false
   700 op equal *tmp259 .SUPPLY_S_FIRST false
   701 set :processUnit.1:unit .UNIT_S2
-    * set :processUnit.1:item @silicon
-    * set :processUnit.1:group .GROUP2
-    * set :processUnit.1:supply *tmp259
-    * set :rebindUnit.5:currentUnit .UNIT_S2
-    * jump *label223 equal :processUnit.1:unit null
-    * ubind :processUnit.1:unit
+  702 jump *label223 equal .UNIT_S2 null
+  703 ubind .UNIT_S2
   704 sensor *tmp263 @unit @dead
   705 op equal *tmp264 *tmp263 0
   706 sensor *tmp265 @unit @controller
 
   734 label *label222
   735 sensor :processUnit.1:state @unit @flag
   736 set :processUnit.1:distance -1
-    * set :processUnit.1:color "gold"
   737 jump *label237 lessThan :processUnit.1:state 2
   738 label *label238
   739 jump *label235 lessThanEq :processUnit.1:state 3
 
   851 set .SUPPLY_S_FIRST *tmp322
   852 label *label219
   853 label *label220
-    * set :printDomeStatus.1:item @phase-fabric
-    * set :printDomeStatus.1:text "\n[green]Phase fabric[] status:\n"
   854 print "\n[green]Phase fabric[] status:\n"
   855 sensor :printDomeStatus.1:level .DOME @phase-fabric
   856 jump *label264 lessThanEq :printDomeStatus.1:level 3
 
   869 label *label265
   870 label *label263
   871 set :processUnit.2:unit .UNIT_P1
-    * set :processUnit.2:item @phase-fabric
-    * set :processUnit.2:group .GROUP1
-    * set :processUnit.2:supply .SUPPLY_P_FIRST
-    * set :rebindUnit.6:currentUnit .UNIT_P1
-    * jump *label268 equal :processUnit.2:unit null
-    * ubind :processUnit.2:unit
+  872 jump *label268 equal .UNIT_P1 null
+  873 ubind .UNIT_P1
   874 sensor *tmp333 @unit @dead
   875 op equal *tmp334 *tmp333 0
   876 sensor *tmp335 @unit @controller
 
   904 label *label267
   905 sensor :processUnit.2:state @unit @flag
   906 set :processUnit.2:distance -1
-    * set :processUnit.2:color "gold"
   907 jump *label282 lessThan :processUnit.2:state 2
   908 label *label283
   909 jump *label280 lessThanEq :processUnit.2:state 3
 
  1013 jump *label306 equal *tmp126 false
  1014 op equal *tmp393 .SUPPLY_P_FIRST false
  1015 set :processUnit.3:unit .UNIT_P2
-    * set :processUnit.3:item @phase-fabric
-    * set :processUnit.3:group .GROUP2
-    * set :processUnit.3:supply *tmp393
-    * set :rebindUnit.7:currentUnit .UNIT_P2
-    * jump *label310 equal :processUnit.3:unit null
-    * ubind :processUnit.3:unit
+ 1016 jump *label310 equal .UNIT_P2 null
+ 1017 ubind .UNIT_P2
  1018 sensor *tmp397 @unit @dead
  1019 op equal *tmp398 *tmp397 0
  1020 sensor *tmp399 @unit @controller
 
  1048 label *label309
  1049 sensor :processUnit.3:state @unit @flag
  1050 set :processUnit.3:distance -1
-    * set :processUnit.3:color "gold"
  1051 jump *label324 lessThan :processUnit.3:state 2
  1052 label *label325
  1053 jump *label322 lessThanEq :processUnit.3:state 3
 
  1177 label *label353
  1178 jump *label350 lessThanEq :unitCheck @time
  1179 label *label352
-    * set :areUnitsAvailable.2:type UNIT_TYPE
-    * set :areUnitsAvailable.2:output false
  1180 set :areUnitsAvailable.2:free 0
  1181 set :areUnitsAvailable.2:occupied 0
  1182 set :areUnitsAvailable.2:needed 0
 
  1184 set :areUnitsAvailable.2:firstUnit @unit
  1185 jump *label357 equal :areUnitsAvailable.2:firstUnit null
  1186 set :needsFourUnits.3:unit @unit
-    * op sub *tmp470 .DOME_X .CORE_X
-    * op sub *tmp471 .DOME_Y .CORE_Y
-    * op len *tmp472 *tmp127 *tmp128
-    * op mul *tmp473 2 *tmp129
  1187 sensor *tmp474 :needsFourUnits.3:unit @speed
  1188 op div :needsFourUnits.3:travel_time *tmp130 *tmp474
  1189 op greaterThanEq *tmp469 :needsFourUnits.3:travel_time 47

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 3 (-12 instructions):
 
   273 jump *label81 equal *tmp78 0
   274 label *label83
   275 label *label78
-    * set :acquireUnit:currentUnit .UNIT_S1
   276 jump *label91 equal .UNIT_S1 null
   277 ubind .UNIT_S1
   278 sensor *tmp84 @unit @dead
 
   311 jump *label89 always
   312 label *label89
   313 set .UNIT_S1 *tmp80
-    * set :acquireUnit.1:currentUnit .UNIT_P1
   314 jump *label105 equal .UNIT_P1 null
   315 ubind .UNIT_P1
   316 sensor *tmp102 @unit @dead
 
   356 jump *label117 notEqual *tmp118 @silicon
   357 label *label119
   358 set :swap:t *tmp80
-    * set :swap:a *tmp98
-    * set :swap:b .UNIT_S1
+  359 set :swap:b *tmp80
   360 label *label121
-    * set .UNIT_S1 .UNIT_P1
-    * set .UNIT_P1 :swap:t
+  361 set .UNIT_S1 *tmp98
+  362 set .UNIT_P1 *tmp80
   363 label *label117
   364 label *label118
   365 sensor .UNIT_CAPACITY .UNIT_S1 @itemCapacity
 
   379 jump *label124 always
   380 label *label124
   381 jump *label125 equal *tmp126 false
-    * set :acquireUnit.2:currentUnit .UNIT_S2
   382 jump *label129 equal .UNIT_S2 null
   383 ubind .UNIT_S2
   384 sensor *tmp139 @unit @dead
 
   417 jump *label127 always
   418 label *label127
   419 set .UNIT_S2 *tmp135
-    * set :acquireUnit.3:currentUnit .UNIT_P2
   420 jump *label143 equal .UNIT_P2 null
   421 ubind .UNIT_P2
   422 sensor *tmp157 @unit @dead
 
   462 jump *label155 equal *tmp173 @phase-fabric
   463 label *label157
   464 set :swap.1:t .UNIT_S1
-    * set :swap.1:a *tmp153
-    * set :swap.1:b .UNIT_S1
   465 label *label159
-    * set .UNIT_S1 .UNIT_P2
+  466 set .UNIT_S1 *tmp153
   467 set .UNIT_P2 :swap.1:t
   468 label *label155
   469 label *label156
 
   474 jump *label160 notEqual *tmp178 @silicon
   475 label *label162
   476 set :swap.2:t *tmp135
-    * set :swap.2:a .UNIT_P2
-    * set :swap.2:b .UNIT_S2
+  477 set :swap.2:b *tmp135
   478 label *label164
   479 set .UNIT_S2 .UNIT_P2
-    * set .UNIT_P2 :swap.2:t
+  480 set .UNIT_P2 *tmp135
   481 label *label160
   482 label *label161
   483 set .GROUP1 "unit  1"
 
   546 print "\n"
   547 label *label178
   548 label *label176
-    * set :processUnit:unit .UNIT_S1
   549 jump *label181 equal .UNIT_S1 null
   550 ubind .UNIT_S1
   551 sensor *tmp199 @unit @dead
 
   689 set .UNIT_S1 :processUnit:unit
   690 jump *label219 equal *tmp126 false
   691 op equal *tmp259 .SUPPLY_S_FIRST false
-    * set :processUnit.1:unit .UNIT_S2
   692 jump *label223 equal .UNIT_S2 null
   693 ubind .UNIT_S2
   694 sensor *tmp263 @unit @dead
 
   858 print "\n"
   859 label *label265
   860 label *label263
-    * set :processUnit.2:unit .UNIT_P1
   861 jump *label268 equal .UNIT_P1 null
   862 ubind .UNIT_P1
   863 sensor *tmp333 @unit @dead
 
  1001 set .UNIT_P1 :processUnit.2:unit
  1002 jump *label306 equal *tmp126 false
  1003 op equal *tmp393 .SUPPLY_P_FIRST false
-    * set :processUnit.3:unit .UNIT_P2
  1004 jump *label310 equal .UNIT_P2 null
  1005 ubind .UNIT_P2
  1006 sensor *tmp397 @unit @dead

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 4 (-4 instructions):
 
   355 sensor *tmp118 *tmp98 @firstItem
   356 jump *label117 notEqual *tmp118 @silicon
   357 label *label119
-    * set :swap:t *tmp80
-    * set :swap:b *tmp80
   358 label *label121
   359 set .UNIT_S1 *tmp98
   360 set .UNIT_P1 *tmp80
 
   471 sensor *tmp178 .UNIT_P2 @firstItem
   472 jump *label160 notEqual *tmp178 @silicon
   473 label *label162
-    * set :swap.2:t *tmp135
-    * set :swap.2:b *tmp135
   474 label *label164
   475 set .UNIT_S2 .UNIT_P2
   476 set .UNIT_P2 *tmp135

Modifications by Iterated phase, Loop Rotation, pass 1, iteration 1:
 
     4 set .DOME dome1
     5 label *label2
     6 jump *label4 notEqual .DOME null
+    7 label *label381
     8 print "[gold]Waiting for an overdrive dome to be connected..."
     9 printflush message1
    10 set .DOME dome1
    11 label *label3
-    * jump *label2 always
+   12 jump *label381 equal .DOME null
    13 label *label4
    14 print "[gold]Locating core..."
    15 printflush message1
 
   106 ubind UNIT_TYPE
   107 label *label34
   108 jump *label35 equal @unit :areUnitsAvailable:firstUnit
-    * label *label42
   109 sensor *tmp31 :areUnitsAvailable:firstUnit @dead
   110 jump *label33 equal *tmp31 0
   111 label *label35
 
   194 ubind :chooseUnitType:type
   195 label *label65
   196 jump *label66 equal @unit :areUnitsAvailable.1:firstUnit
-    * label *label73
   197 sensor *tmp61 :areUnitsAvailable.1:firstUnit @dead
   198 jump *label64 equal *tmp61 0
   199 label *label66
 
   267 ubind *tmp9
   268 label *label82
   269 jump *label83 equal @unit :rebindUnits:firstUnit
-    * label *label88
   270 sensor *tmp78 :rebindUnits:firstUnit @dead
   271 jump *label81 equal *tmp78 0
   272 label *label83
 
   296 ubind *tmp9
   297 label *label98
   298 jump *label99 equal @unit :rebindUnit:firstUnit
-    * label *label102
   299 sensor *tmp96 :rebindUnit:firstUnit @dead
   300 jump *label97 equal *tmp96 0
   301 label *label99
 
   333 ubind *tmp9
   334 label *label112
   335 jump *label113 equal @unit :rebindUnit.1:firstUnit
-    * label *label116
   336 sensor *tmp114 :rebindUnit.1:firstUnit @dead
   337 jump *label111 equal *tmp114 0
   338 label *label113
 
   398 ubind *tmp9
   399 label *label136
   400 jump *label137 equal @unit :rebindUnit.2:firstUnit
-    * label *label140
   401 sensor *tmp151 :rebindUnit.2:firstUnit @dead
   402 jump *label135 equal *tmp151 0
   403 label *label137
 
   435 ubind *tmp9
   436 label *label150
   437 jump *label151 equal @unit :rebindUnit.3:firstUnit
-    * label *label154
   438 sensor *tmp169 :rebindUnit.3:firstUnit @dead
   439 jump *label149 equal *tmp169 0
   440 label *label151
 
   561 ubind *tmp9
   562 label *label188
   563 jump *label189 equal @unit :rebindUnit.4:firstUnit
-    * label *label192
   564 sensor *tmp211 :rebindUnit.4:firstUnit @dead
   565 jump *label187 equal *tmp211 0
   566 label *label189
 
   703 ubind *tmp9
   704 label *label230
   705 jump *label231 equal @unit :rebindUnit.5:firstUnit
-    * label *label234
   706 sensor *tmp275 :rebindUnit.5:firstUnit @dead
   707 jump *label229 equal *tmp275 0
   708 label *label231
 
   871 ubind *tmp9
   872 label *label275
   873 jump *label276 equal @unit :rebindUnit.6:firstUnit
-    * label *label279
   874 sensor *tmp345 :rebindUnit.6:firstUnit @dead
   875 jump *label274 equal *tmp345 0
   876 label *label276
 
  1013 ubind *tmp9
  1014 label *label317
  1015 jump *label318 equal @unit :rebindUnit.7:firstUnit
-    * label *label321
  1016 sensor *tmp409 :rebindUnit.7:firstUnit @dead
  1017 jump *label316 equal *tmp409 0
  1018 label *label318
 
  1190 ubind UNIT_TYPE
  1191 label *label363
  1192 jump *label364 equal @unit :areUnitsAvailable.2:firstUnit
-    * label *label371
  1193 sensor *tmp487 :areUnitsAvailable.2:firstUnit @dead
  1194 jump *label362 equal *tmp487 0
  1195 label *label364

Modifications by Iterated phase, Boolean Optimization, pass 1, iteration 1 (-2 instructions):
 
    89 label *label33
    90 sensor *tmp22 @unit @controlled
    91 jump *label38 equal *tmp22 0
-    * label *label39
    92 sensor *tmp24 @unit @controller
    93 jump *label36 notEqual *tmp24 @this
    94 label *label38
 
   176 label *label64
   177 sensor *tmp52 @unit @controlled
   178 jump *label69 equal *tmp52 0
-    * label *label70
   179 sensor *tmp54 @unit @controller
   180 jump *label67 notEqual *tmp54 @this
   181 label *label69
 
   345 set .UNIT_P1 *tmp98
   346 sensor *tmp116 *tmp80 @firstItem
   347 jump *label119 equal *tmp116 @phase-fabric
-    * label *label120
   348 sensor *tmp118 *tmp98 @firstItem
   349 jump *label117 notEqual *tmp118 @silicon
   350 label *label119
 
   446 set .UNIT_P2 *tmp153
   447 sensor *tmp171 .UNIT_S1 @firstItem
   448 jump *label155 notEqual *tmp171 @phase-fabric
-    * label *label158
   449 sensor *tmp173 *tmp153 @firstItem
   450 jump *label155 equal *tmp173 @phase-fabric
-    * label *label157
   451 set :swap.1:t .UNIT_S1
   452 label *label159
   453 set .UNIT_S1 *tmp153
 
   456 label *label156
   457 sensor *tmp176 *tmp135 @firstItem
   458 jump *label162 equal *tmp176 @phase-fabric
-    * label *label163
   459 sensor *tmp178 .UNIT_P2 @firstItem
   460 jump *label160 notEqual *tmp178 @silicon
   461 label *label162
 
   476 set .UNIT_P2 null
   477 set .GROUP1 "unit"
   478 label *label126
-    * jump *label167 equal *tmp126 false
-    * label *label168
-    * sensor *tmp182 .UNIT_S1 @totalItems
-    * sensor *tmp183 .UNIT_S2 @totalItems
-    * jump *label165 greaterThanEq *tmp182 *tmp183
+  479 jump *label165 notEqual *tmp126 false
   480 label *label167
   481 set *tmp185 true
   482 jump *label166 always
   483 label *label165
-    * set *tmp185 false
+  484 sensor *tmp182 .UNIT_S1 @totalItems
+  485 sensor *tmp183 .UNIT_S2 @totalItems
+  486 op lessThan *tmp185 *tmp182 *tmp183
   487 label *label166
   488 set .SUPPLY_S_FIRST *tmp185
-    * jump *label171 equal *tmp126 false
-    * label *label172
-    * sensor *tmp187 .UNIT_P1 @totalItems
-    * sensor *tmp188 .UNIT_P2 @totalItems
-    * jump *label169 greaterThanEq *tmp187 *tmp188
+  489 jump *label169 notEqual *tmp126 false
   490 label *label171
   491 set *tmp190 true
   492 jump *label170 always
   493 label *label169
-    * set *tmp190 false
+  494 sensor *tmp187 .UNIT_P1 @totalItems
+  495 sensor *tmp188 .UNIT_P2 @totalItems
+  496 op lessThan *tmp190 *tmp187 *tmp188
   497 label *label170
   498 set .SUPPLY_P_FIRST *tmp190
   499 op add :unitCheck @time 5000
 
   561 sensor :processUnit:state @unit @flag
   562 set :processUnit:distance -1
   563 jump *label195 lessThan :processUnit:state 2
-    * label *label196
   564 jump *label193 lessThanEq :processUnit:state 3
   565 label *label195
   566 sensor *tmp217 @unit @firstItem
 
   702 sensor :processUnit.1:state @unit @flag
   703 set :processUnit.1:distance -1
   704 jump *label237 lessThan :processUnit.1:state 2
-    * label *label238
   705 jump *label235 lessThanEq :processUnit.1:state 3
   706 label *label237
   707 sensor *tmp281 @unit @firstItem
 
   869 sensor :processUnit.2:state @unit @flag
   870 set :processUnit.2:distance -1
   871 jump *label282 lessThan :processUnit.2:state 2
-    * label *label283
   872 jump *label280 lessThanEq :processUnit.2:state 3
   873 label *label282
   874 sensor *tmp351 @unit @firstItem
 
  1010 sensor :processUnit.3:state @unit @flag
  1011 set :processUnit.3:distance -1
  1012 jump *label324 lessThan :processUnit.3:state 2
-    * label *label325
  1013 jump *label322 lessThanEq :processUnit.3:state 3
  1014 label *label324
  1015 sensor *tmp415 @unit @firstItem
 
  1134 print "ms"
  1135 printflush message1
  1136 jump *label350 equal *tmp9 UNIT_TYPE
-    * label *label353
  1137 jump *label350 lessThanEq :unitCheck @time
-    * label *label352
  1138 set :areUnitsAvailable.2:free 0
  1139 set :areUnitsAvailable.2:occupied 0
  1140 set :areUnitsAvailable.2:needed 0
 
  1157 label *label362
  1158 sensor *tmp478 @unit @controlled
  1159 jump *label367 equal *tmp478 0
-    * label *label368
  1160 sensor *tmp480 @unit @controller
  1161 jump *label365 notEqual *tmp480 @this
  1162 label *label367
 
  1212 ubind :locateCore:type
  1213 sensor *tmp494 @unit @controlled
  1214 jump *label379 equal *tmp494 0
-    * label *label380
  1215 sensor *tmp496 @unit @controller
  1216 jump *label377 notEqual *tmp496 @this
  1217 label *label379

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 1 (-4 instructions):
 
   477 set .GROUP1 "unit"
   478 label *label126
   479 jump *label165 notEqual *tmp126 false
-    * set *tmp185 true
+  480 set .SUPPLY_S_FIRST true
   481 jump *label166 always
   482 label *label165
   483 sensor *tmp182 .UNIT_S1 @totalItems
   484 sensor *tmp183 .UNIT_S2 @totalItems
-    * op lessThan *tmp185 *tmp182 *tmp183
+  485 op lessThan .SUPPLY_S_FIRST *tmp182 *tmp183
   486 label *label166
-    * set .SUPPLY_S_FIRST *tmp185
   487 jump *label169 notEqual *tmp126 false
-    * set *tmp190 true
+  488 set .SUPPLY_P_FIRST true
   489 jump *label170 always
   490 label *label169
   491 sensor *tmp187 .UNIT_P1 @totalItems
   492 sensor *tmp188 .UNIT_P2 @totalItems
-    * op lessThan *tmp190 *tmp187 *tmp188
+  493 op lessThan .SUPPLY_P_FIRST *tmp187 *tmp188
   494 label *label170
-    * set .SUPPLY_P_FIRST *tmp190
   495 op add :unitCheck @time 5000
   496 label *label173
   497 sensor *tmp192 switch1 @enabled
 
   804 set .UNIT_S2 :processUnit.1:unit
   805 jump *label261 equal .SUPPLY_S_FIRST false
   806 sensor *tmp323 :processUnit:unit @totalItems
-    * op greaterThan *tmp322 *tmp323 0
+  807 op greaterThan .SUPPLY_S_FIRST *tmp323 0
   808 jump *label262 always
   809 label *label261
   810 sensor *tmp325 :processUnit.1:unit @totalItems
-    * op equal *tmp322 *tmp325 0
+  811 op equal .SUPPLY_S_FIRST *tmp325 0
   812 label *label262
-    * set .SUPPLY_S_FIRST *tmp322
   813 label *label219
   814 label *label220
   815 print "\n[green]Phase fabric[] status:\n"
 
  1111 set .UNIT_P2 :processUnit.3:unit
  1112 jump *label348 equal .SUPPLY_P_FIRST false
  1113 sensor *tmp457 :processUnit.2:unit @totalItems
-    * op greaterThan *tmp456 *tmp457 0
+ 1114 op greaterThan .SUPPLY_P_FIRST *tmp457 0
  1115 jump *label349 always
  1116 label *label348
  1117 sensor *tmp459 :processUnit.3:unit @totalItems
-    * op equal *tmp456 *tmp459 0
+ 1118 op equal .SUPPLY_P_FIRST *tmp459 0
  1119 label *label349
-    * set .SUPPLY_P_FIRST *tmp456
  1120 label *label306
  1121 label *label307
  1122 op sub *tmp461 @time :start

Modifications by Unroll iteration loop at line 169:9 (+7 instructions):
 
    15 printflush message1
    16 set .CORE null
    17 label *label5
-    * set :locateDomeAndCore:type @flare
-    * setaddr *tmp1 *label11
-    * jump *label8 always
-    * multilabel *label11 (m:marker0)
-    * set :locateDomeAndCore:type @poly
-    * setaddr *tmp1 *label12
-    * jump *label8 always
-    * multilabel *label12 (m:marker0)
-    * set :locateDomeAndCore:type @mega
-    * setaddr *tmp1 *label13
-    * jump *label8 always
-    * multilabel *label13 (m:marker0)
-    * set :locateDomeAndCore:type @mono
-    * setaddr *tmp1 *label14
-    * label *label8
-    * set :locateCore:type :locateDomeAndCore:type
-    * setaddr :locateCore*retaddr *label17 (h:*label17)
-    * call *label0 *invalid :locateCore*retval (m:*label17) (h:*label17)
-    * label *label17
-    * jump *label15 equal :locateCore*retval false
-    * jump *label1 always
-    * label *label15
-    * label *label16
-    * label *label9
-    * multijump *tmp1 0 0 (m:marker0)
-    * multilabel *label14 (m:marker0)
-    * label *label10
+   18 set :locateDomeAndCore:type @flare
+   19 label *label384
+   20 set :locateCore:type :locateDomeAndCore:type
+   21 setaddr :locateCore*retaddr *label385 (h:*label385)
+   22 call *label0 *invalid :locateCore*retval (m:*label385) (h:*label385)
+   23 label *label385
+   24 jump *label386 equal :locateCore*retval false
+   25 jump *label1 always
+   26 label *label386
+   27 label *label387
+   28 label *label388
+   29 set :locateDomeAndCore:type @poly
+   30 label *label391
+   31 set :locateCore:type :locateDomeAndCore:type
+   32 setaddr :locateCore*retaddr *label392 (h:*label392)
+   33 call *label0 *invalid :locateCore*retval (m:*label392) (h:*label392)
+   34 label *label392
+   35 jump *label393 equal :locateCore*retval false
+   36 jump *label1 always
+   37 label *label393
+   38 label *label394
+   39 label *label395
+   40 set :locateDomeAndCore:type @mega
+   41 label *label398
+   42 set :locateCore:type :locateDomeAndCore:type
+   43 setaddr :locateCore*retaddr *label399 (h:*label399)
+   44 call *label0 *invalid :locateCore*retval (m:*label399) (h:*label399)
+   45 label *label399
+   46 jump *label400 equal :locateCore*retval false
+   47 jump *label1 always
+   48 label *label400
+   49 label *label401
+   50 label *label402
+   51 set :locateDomeAndCore:type @mono
+   52 label *label405
+   53 set :locateCore:type :locateDomeAndCore:type
+   54 setaddr :locateCore*retaddr *label406 (h:*label406)
+   55 call *label0 *invalid :locateCore*retval (m:*label406) (h:*label406)
+   56 label *label406
+   57 jump *label407 equal :locateCore*retval false
+   58 jump *label1 always
+   59 label *label407
+   60 label *label408
+   61 label *label409
+   62 label *label10
    63 label *label6
    64 jump *label5 always
    65 label *label7

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
     3 remark "Do not modify anything below this line."
     4 set .DOME dome1
     5 label *label2
-    * jump *label4 notEqual .DOME null
+    6 jump *label4 notEqual dome1 null
     7 label *label381
     8 print "[gold]Waiting for an overdrive dome to be connected..."
     9 printflush message1
    10 set .DOME dome1
    11 label *label3
-    * jump *label381 equal .DOME null
+   12 jump *label381 equal dome1 null
    13 label *label4
    14 print "[gold]Locating core..."
    15 printflush message1
 
    17 label *label5
    18 set :locateDomeAndCore:type @flare
    19 label *label384
-    * set :locateCore:type :locateDomeAndCore:type
+   20 set :locateCore:type @flare
    21 setaddr :locateCore*retaddr *label385 (h:*label385)
    22 call *label0 *invalid :locateCore*retval (m:*label385) (h:*label385)
    23 label *label385
 
    28 label *label388
    29 set :locateDomeAndCore:type @poly
    30 label *label391
-    * set :locateCore:type :locateDomeAndCore:type
+   31 set :locateCore:type @poly
    32 setaddr :locateCore*retaddr *label392 (h:*label392)
    33 call *label0 *invalid :locateCore*retval (m:*label392) (h:*label392)
    34 label *label392
 
    39 label *label395
    40 set :locateDomeAndCore:type @mega
    41 label *label398
-    * set :locateCore:type :locateDomeAndCore:type
+   42 set :locateCore:type @mega
    43 setaddr :locateCore*retaddr *label399 (h:*label399)
    44 call *label0 *invalid :locateCore*retval (m:*label399) (h:*label399)
    45 label *label399
 
    50 label *label402
    51 set :locateDomeAndCore:type @mono
    52 label *label405
-    * set :locateCore:type :locateDomeAndCore:type
+   53 set :locateCore:type @mono
    54 setaddr :locateCore*retaddr *label406 (h:*label406)
    55 call *label0 *invalid :locateCore*retval (m:*label406) (h:*label406)
    56 label *label406

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-4 instructions):
 
    15 printflush message1
    16 set .CORE null
    17 label *label5
-    * set :locateDomeAndCore:type @flare
    18 label *label384
    19 set :locateCore:type @flare
    20 setaddr :locateCore*retaddr *label385 (h:*label385)
 
    25 label *label386
    26 label *label387
    27 label *label388
-    * set :locateDomeAndCore:type @poly
    28 label *label391
    29 set :locateCore:type @poly
    30 setaddr :locateCore*retaddr *label392 (h:*label392)
 
    35 label *label393
    36 label *label394
    37 label *label395
-    * set :locateDomeAndCore:type @mega
    38 label *label398
    39 set :locateCore:type @mega
    40 setaddr :locateCore*retaddr *label399 (h:*label399)
 
    45 label *label400
    46 label *label401
    47 label *label402
-    * set :locateDomeAndCore:type @mono
    48 label *label405
    49 set :locateCore:type @mono
    50 setaddr :locateCore*retaddr *label406 (h:*label406)

Modifications by Partial loop rotation at line 54:5 (+1 instructions):
 
    67 label *label18
    68 sensor *tmp7 switch1 @enabled
    69 jump *label20 notEqual *tmp7 false
+   70 label *label413
    71 print "[coral]Activate switch to begin supplying overdrive dome..."
    72 print "\n"
    73 printflush message1
    74 label *label19
-    * jump *label18 always
+   75 sensor *tmp7 switch1 @enabled
+   76 jump *label413 equal *tmp7 false
    77 label *label20
    78 label *label22
    79 printflush null

Modifications by Partial loop rotation at line 119:5 (+1 instructions):
 
   512 label *label173
   513 sensor *tmp192 switch1 @enabled
   514 jump *label175 equal *tmp192 false
+  515 label *label414
   516 set :start @time
   517 print " === [gold]Supplying Overdrive Dome[] === "
   518 print "\n"
 
  1216 label *label350
  1217 label *label351
  1218 label *label174
-    * jump *label173 always
+ 1219 sensor *tmp192 switch1 @enabled
+ 1220 jump *label414 notEqual *tmp192 false
  1221 label *label175
  1222 end
  1223 label *label0

Modifications by Unroll iteration loop at line 201:9 (+151 instructions):
 
   150 jump *label21 always
   151 label *label25
   152 label *label26
-    * set :chooseUnitType:type @flare
-    * setaddr *tmp37 *label50
-    * jump *label47 always
-    * multilabel *label50 (m:marker1)
-    * set :chooseUnitType:type @poly
-    * setaddr *tmp37 *label51
-    * jump *label47 always
-    * multilabel *label51 (m:marker1)
-    * set :chooseUnitType:type @mega
-    * setaddr *tmp37 *label52
-    * jump *label47 always
-    * multilabel *label52 (m:marker1)
-    * set :chooseUnitType:type @mono
-    * setaddr *tmp37 *label53
-    * label *label47
-    * jump *label54 equal :chooseUnitType:type UNIT_TYPE
-    * set :areUnitsAvailable.1:free 0
-    * set :areUnitsAvailable.1:occupied 0
-    * set :areUnitsAvailable.1:needed 0
-    * ubind :chooseUnitType:type
-    * set :areUnitsAvailable.1:firstUnit @unit
-    * jump *label59 equal :areUnitsAvailable.1:firstUnit null
-    * set :needsFourUnits.1:unit @unit
-    * op sub *tmp44 .DOME_X .CORE_X
-    * op sub *tmp45 .DOME_Y .CORE_Y
-    * op len *tmp46 *tmp44 *tmp45
-    * op mul *tmp47 2 *tmp46
-    * sensor *tmp48 :needsFourUnits.1:unit @speed
-    * op div :needsFourUnits.1:travel_time *tmp47 *tmp48
-    * op greaterThanEq *tmp43 :needsFourUnits.1:travel_time 47
-    * jump *label63 always
-    * label *label63
-    * jump *label61 equal *tmp43 false
-    * set *tmp51 4
-    * jump *label62 always
-    * label *label61
-    * set *tmp51 2
-    * label *label62
-    * set :areUnitsAvailable.1:needed *tmp51
-    * label *label64
-    * sensor *tmp52 @unit @controlled
-    * jump *label69 equal *tmp52 0
-    * sensor *tmp54 @unit @controller
-    * jump *label67 notEqual *tmp54 @this
-    * label *label69
-    * op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
-    * jump *label71 lessThan :areUnitsAvailable.1:free *tmp51
-    * set *tmp40 true
-    * jump *label58 always
-    * label *label71
-    * label *label72
-    * jump *label68 always
-    * label *label67
-    * op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
-    * label *label68
-    * ubind :chooseUnitType:type
-    * label *label65
-    * jump *label66 equal @unit :areUnitsAvailable.1:firstUnit
-    * sensor *tmp61 :areUnitsAvailable.1:firstUnit @dead
-    * jump *label64 equal *tmp61 0
-    * label *label66
-    * label *label59
-    * label *label60
-    * jump *label74 equal true false
-    * print :chooseUnitType:type
-    * print ":"
-    * print " occupied: "
-    * print :areUnitsAvailable.1:occupied
-    * print ","
-    * print " free: "
-    * print :areUnitsAvailable.1:free
-    * jump *label76 lessThanEq :areUnitsAvailable.1:needed 0
-    * print ", needed: "
-    * print :areUnitsAvailable.1:needed
-    * label *label76
-    * label *label77
-    * print "\n"
-    * label *label74
-    * label *label75
-    * set *tmp40 false
-    * jump *label58 always
-    * label *label58
-    * jump *label56 equal *tmp40 false
-    * printflush null
-    * set *tmp9 :chooseUnitType:type
-    * jump *label21 always
-    * label *label56
-    * label *label57
-    * label *label54
-    * label *label55
-    * label *label48
-    * multijump *tmp37 0 0 (m:marker1)
-    * multilabel *label53 (m:marker1)
-    * label *label49
+  153 set :chooseUnitType:type @flare
+  154 label *label415
+  155 jump *label436 equal :chooseUnitType:type UNIT_TYPE
+  156 set :areUnitsAvailable.1:free 0
+  157 set :areUnitsAvailable.1:occupied 0
+  158 set :areUnitsAvailable.1:needed 0
+  159 ubind :chooseUnitType:type
+  160 set :areUnitsAvailable.1:firstUnit @unit
+  161 jump *label427 equal :areUnitsAvailable.1:firstUnit null
+  162 set :needsFourUnits.1:unit @unit
+  163 op sub *tmp44 .DOME_X .CORE_X
+  164 op sub *tmp45 .DOME_Y .CORE_Y
+  165 op len *tmp46 *tmp44 *tmp45
+  166 op mul *tmp47 2 *tmp46
+  167 sensor *tmp48 :needsFourUnits.1:unit @speed
+  168 op div :needsFourUnits.1:travel_time *tmp47 *tmp48
+  169 op greaterThanEq *tmp43 :needsFourUnits.1:travel_time 47
+  170 jump *label416 always
+  171 label *label416
+  172 jump *label417 equal *tmp43 false
+  173 set *tmp51 4
+  174 jump *label418 always
+  175 label *label417
+  176 set *tmp51 2
+  177 label *label418
+  178 set :areUnitsAvailable.1:needed *tmp51
+  179 label *label419
+  180 sensor *tmp52 @unit @controlled
+  181 jump *label420 equal *tmp52 0
+  182 sensor *tmp54 @unit @controller
+  183 jump *label423 notEqual *tmp54 @this
+  184 label *label420
+  185 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
+  186 jump *label421 lessThan :areUnitsAvailable.1:free *tmp51
+  187 set *tmp40 true
+  188 jump *label433 always
+  189 label *label421
+  190 label *label422
+  191 jump *label424 always
+  192 label *label423
+  193 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
+  194 label *label424
+  195 ubind :chooseUnitType:type
+  196 label *label425
+  197 jump *label426 equal @unit :areUnitsAvailable.1:firstUnit
+  198 sensor *tmp61 :areUnitsAvailable.1:firstUnit @dead
+  199 jump *label419 equal *tmp61 0
+  200 label *label426
+  201 label *label427
+  202 label *label428
+  203 jump *label431 equal true false
+  204 print :chooseUnitType:type
+  205 print ":"
+  206 print " occupied: "
+  207 print :areUnitsAvailable.1:occupied
+  208 print ","
+  209 print " free: "
+  210 print :areUnitsAvailable.1:free
+  211 jump *label429 lessThanEq :areUnitsAvailable.1:needed 0
+  212 print ", needed: "
+  213 print :areUnitsAvailable.1:needed
+  214 label *label429
+  215 label *label430
+  216 print "\n"
+  217 label *label431
+  218 label *label432
+  219 set *tmp40 false
+  220 jump *label433 always
+  221 label *label433
+  222 jump *label434 equal *tmp40 false
+  223 printflush null
+  224 set *tmp9 :chooseUnitType:type
+  225 jump *label21 always
+  226 label *label434
+  227 label *label435
+  228 label *label436
+  229 label *label437
+  230 label *label438
+  231 set :chooseUnitType:type @poly
+  232 label *label441
+  233 jump *label462 equal :chooseUnitType:type UNIT_TYPE
+  234 set :areUnitsAvailable.1:free 0
+  235 set :areUnitsAvailable.1:occupied 0
+  236 set :areUnitsAvailable.1:needed 0
+  237 ubind :chooseUnitType:type
+  238 set :areUnitsAvailable.1:firstUnit @unit
+  239 jump *label453 equal :areUnitsAvailable.1:firstUnit null
+  240 set :needsFourUnits.1:unit @unit
+  241 op sub *tmp44 .DOME_X .CORE_X
+  242 op sub *tmp45 .DOME_Y .CORE_Y
+  243 op len *tmp46 *tmp44 *tmp45
+  244 op mul *tmp47 2 *tmp46
+  245 sensor *tmp48 :needsFourUnits.1:unit @speed
+  246 op div :needsFourUnits.1:travel_time *tmp47 *tmp48
+  247 op greaterThanEq *tmp43 :needsFourUnits.1:travel_time 47
+  248 jump *label442 always
+  249 label *label442
+  250 jump *label443 equal *tmp43 false
+  251 set *tmp51 4
+  252 jump *label444 always
+  253 label *label443
+  254 set *tmp51 2
+  255 label *label444
+  256 set :areUnitsAvailable.1:needed *tmp51
+  257 label *label445
+  258 sensor *tmp52 @unit @controlled
+  259 jump *label446 equal *tmp52 0
+  260 sensor *tmp54 @unit @controller
+  261 jump *label449 notEqual *tmp54 @this
+  262 label *label446
+  263 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
+  264 jump *label447 lessThan :areUnitsAvailable.1:free *tmp51
+  265 set *tmp40 true
+  266 jump *label459 always
+  267 label *label447
+  268 label *label448
+  269 jump *label450 always
+  270 label *label449
+  271 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
+  272 label *label450
+  273 ubind :chooseUnitType:type
+  274 label *label451
+  275 jump *label452 equal @unit :areUnitsAvailable.1:firstUnit
+  276 sensor *tmp61 :areUnitsAvailable.1:firstUnit @dead
+  277 jump *label445 equal *tmp61 0
+  278 label *label452
+  279 label *label453
+  280 label *label454
+  281 jump *label457 equal true false
+  282 print :chooseUnitType:type
+  283 print ":"
+  284 print " occupied: "
+  285 print :areUnitsAvailable.1:occupied
+  286 print ","
+  287 print " free: "
+  288 print :areUnitsAvailable.1:free
+  289 jump *label455 lessThanEq :areUnitsAvailable.1:needed 0
+  290 print ", needed: "
+  291 print :areUnitsAvailable.1:needed
+  292 label *label455
+  293 label *label456
+  294 print "\n"
+  295 label *label457
+  296 label *label458
+  297 set *tmp40 false
+  298 jump *label459 always
+  299 label *label459
+  300 jump *label460 equal *tmp40 false
+  301 printflush null
+  302 set *tmp9 :chooseUnitType:type
+  303 jump *label21 always
+  304 label *label460
+  305 label *label461
+  306 label *label462
+  307 label *label463
+  308 label *label464
+  309 set :chooseUnitType:type @mega
+  310 label *label467
+  311 jump *label488 equal :chooseUnitType:type UNIT_TYPE
+  312 set :areUnitsAvailable.1:free 0
+  313 set :areUnitsAvailable.1:occupied 0
+  314 set :areUnitsAvailable.1:needed 0
+  315 ubind :chooseUnitType:type
+  316 set :areUnitsAvailable.1:firstUnit @unit
+  317 jump *label479 equal :areUnitsAvailable.1:firstUnit null
+  318 set :needsFourUnits.1:unit @unit
+  319 op sub *tmp44 .DOME_X .CORE_X
+  320 op sub *tmp45 .DOME_Y .CORE_Y
+  321 op len *tmp46 *tmp44 *tmp45
+  322 op mul *tmp47 2 *tmp46
+  323 sensor *tmp48 :needsFourUnits.1:unit @speed
+  324 op div :needsFourUnits.1:travel_time *tmp47 *tmp48
+  325 op greaterThanEq *tmp43 :needsFourUnits.1:travel_time 47
+  326 jump *label468 always
+  327 label *label468
+  328 jump *label469 equal *tmp43 false
+  329 set *tmp51 4
+  330 jump *label470 always
+  331 label *label469
+  332 set *tmp51 2
+  333 label *label470
+  334 set :areUnitsAvailable.1:needed *tmp51
+  335 label *label471
+  336 sensor *tmp52 @unit @controlled
+  337 jump *label472 equal *tmp52 0
+  338 sensor *tmp54 @unit @controller
+  339 jump *label475 notEqual *tmp54 @this
+  340 label *label472
+  341 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
+  342 jump *label473 lessThan :areUnitsAvailable.1:free *tmp51
+  343 set *tmp40 true
+  344 jump *label485 always
+  345 label *label473
+  346 label *label474
+  347 jump *label476 always
+  348 label *label475
+  349 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
+  350 label *label476
+  351 ubind :chooseUnitType:type
+  352 label *label477
+  353 jump *label478 equal @unit :areUnitsAvailable.1:firstUnit
+  354 sensor *tmp61 :areUnitsAvailable.1:firstUnit @dead
+  355 jump *label471 equal *tmp61 0
+  356 label *label478
+  357 label *label479
+  358 label *label480
+  359 jump *label483 equal true false
+  360 print :chooseUnitType:type
+  361 print ":"
+  362 print " occupied: "
+  363 print :areUnitsAvailable.1:occupied
+  364 print ","
+  365 print " free: "
+  366 print :areUnitsAvailable.1:free
+  367 jump *label481 lessThanEq :areUnitsAvailable.1:needed 0
+  368 print ", needed: "
+  369 print :areUnitsAvailable.1:needed
+  370 label *label481
+  371 label *label482
+  372 print "\n"
+  373 label *label483
+  374 label *label484
+  375 set *tmp40 false
+  376 jump *label485 always
+  377 label *label485
+  378 jump *label486 equal *tmp40 false
+  379 printflush null
+  380 set *tmp9 :chooseUnitType:type
+  381 jump *label21 always
+  382 label *label486
+  383 label *label487
+  384 label *label488
+  385 label *label489
+  386 label *label490
+  387 set :chooseUnitType:type @mono
+  388 label *label493
+  389 jump *label514 equal :chooseUnitType:type UNIT_TYPE
+  390 set :areUnitsAvailable.1:free 0
+  391 set :areUnitsAvailable.1:occupied 0
+  392 set :areUnitsAvailable.1:needed 0
+  393 ubind :chooseUnitType:type
+  394 set :areUnitsAvailable.1:firstUnit @unit
+  395 jump *label505 equal :areUnitsAvailable.1:firstUnit null
+  396 set :needsFourUnits.1:unit @unit
+  397 op sub *tmp44 .DOME_X .CORE_X
+  398 op sub *tmp45 .DOME_Y .CORE_Y
+  399 op len *tmp46 *tmp44 *tmp45
+  400 op mul *tmp47 2 *tmp46
+  401 sensor *tmp48 :needsFourUnits.1:unit @speed
+  402 op div :needsFourUnits.1:travel_time *tmp47 *tmp48
+  403 op greaterThanEq *tmp43 :needsFourUnits.1:travel_time 47
+  404 jump *label494 always
+  405 label *label494
+  406 jump *label495 equal *tmp43 false
+  407 set *tmp51 4
+  408 jump *label496 always
+  409 label *label495
+  410 set *tmp51 2
+  411 label *label496
+  412 set :areUnitsAvailable.1:needed *tmp51
+  413 label *label497
+  414 sensor *tmp52 @unit @controlled
+  415 jump *label498 equal *tmp52 0
+  416 sensor *tmp54 @unit @controller
+  417 jump *label501 notEqual *tmp54 @this
+  418 label *label498
+  419 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
+  420 jump *label499 lessThan :areUnitsAvailable.1:free *tmp51
+  421 set *tmp40 true
+  422 jump *label511 always
+  423 label *label499
+  424 label *label500
+  425 jump *label502 always
+  426 label *label501
+  427 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
+  428 label *label502
+  429 ubind :chooseUnitType:type
+  430 label *label503
+  431 jump *label504 equal @unit :areUnitsAvailable.1:firstUnit
+  432 sensor *tmp61 :areUnitsAvailable.1:firstUnit @dead
+  433 jump *label497 equal *tmp61 0
+  434 label *label504
+  435 label *label505
+  436 label *label506
+  437 jump *label509 equal true false
+  438 print :chooseUnitType:type
+  439 print ":"
+  440 print " occupied: "
+  441 print :areUnitsAvailable.1:occupied
+  442 print ","
+  443 print " free: "
+  444 print :areUnitsAvailable.1:free
+  445 jump *label507 lessThanEq :areUnitsAvailable.1:needed 0
+  446 print ", needed: "
+  447 print :areUnitsAvailable.1:needed
+  448 label *label507
+  449 label *label508
+  450 print "\n"
+  451 label *label509
+  452 label *label510
+  453 set *tmp40 false
+  454 jump *label511 always
+  455 label *label511
+  456 jump *label512 equal *tmp40 false
+  457 printflush null
+  458 set *tmp9 :chooseUnitType:type
+  459 jump *label21 always
+  460 label *label512
+  461 label *label513
+  462 label *label514
+  463 label *label515
+  464 label *label516
+  465 label *label49
   466 printflush message1
   467 label *label23
   468 jump *label22 always

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
   152 label *label26
   153 set :chooseUnitType:type @flare
   154 label *label415
-    * jump *label436 equal :chooseUnitType:type UNIT_TYPE
+  155 jump *label436 equal @flare UNIT_TYPE
   156 set :areUnitsAvailable.1:free 0
   157 set :areUnitsAvailable.1:occupied 0
   158 set :areUnitsAvailable.1:needed 0
-    * ubind :chooseUnitType:type
+  159 ubind @flare
   160 set :areUnitsAvailable.1:firstUnit @unit
   161 jump *label427 equal :areUnitsAvailable.1:firstUnit null
   162 set :needsFourUnits.1:unit @unit
 
   192 label *label423
   193 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   194 label *label424
-    * ubind :chooseUnitType:type
+  195 ubind @flare
   196 label *label425
   197 jump *label426 equal @unit :areUnitsAvailable.1:firstUnit
   198 sensor *tmp61 :areUnitsAvailable.1:firstUnit @dead
 
   201 label *label427
   202 label *label428
   203 jump *label431 equal true false
-    * print :chooseUnitType:type
+  204 print @flare
   205 print ":"
   206 print " occupied: "
   207 print :areUnitsAvailable.1:occupied
 
   221 label *label433
   222 jump *label434 equal *tmp40 false
   223 printflush null
-    * set *tmp9 :chooseUnitType:type
+  224 set *tmp9 @flare
   225 jump *label21 always
   226 label *label434
   227 label *label435
 
   230 label *label438
   231 set :chooseUnitType:type @poly
   232 label *label441
-    * jump *label462 equal :chooseUnitType:type UNIT_TYPE
+  233 jump *label462 equal @poly UNIT_TYPE
   234 set :areUnitsAvailable.1:free 0
   235 set :areUnitsAvailable.1:occupied 0
   236 set :areUnitsAvailable.1:needed 0
-    * ubind :chooseUnitType:type
+  237 ubind @poly
   238 set :areUnitsAvailable.1:firstUnit @unit
   239 jump *label453 equal :areUnitsAvailable.1:firstUnit null
   240 set :needsFourUnits.1:unit @unit
 
   270 label *label449
   271 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   272 label *label450
-    * ubind :chooseUnitType:type
+  273 ubind @poly
   274 label *label451
   275 jump *label452 equal @unit :areUnitsAvailable.1:firstUnit
   276 sensor *tmp61 :areUnitsAvailable.1:firstUnit @dead
 
   279 label *label453
   280 label *label454
   281 jump *label457 equal true false
-    * print :chooseUnitType:type
+  282 print @poly
   283 print ":"
   284 print " occupied: "
   285 print :areUnitsAvailable.1:occupied
 
   299 label *label459
   300 jump *label460 equal *tmp40 false
   301 printflush null
-    * set *tmp9 :chooseUnitType:type
+  302 set *tmp9 @poly
   303 jump *label21 always
   304 label *label460
   305 label *label461
 
   308 label *label464
   309 set :chooseUnitType:type @mega
   310 label *label467
-    * jump *label488 equal :chooseUnitType:type UNIT_TYPE
+  311 jump *label488 equal @mega UNIT_TYPE
   312 set :areUnitsAvailable.1:free 0
   313 set :areUnitsAvailable.1:occupied 0
   314 set :areUnitsAvailable.1:needed 0
-    * ubind :chooseUnitType:type
+  315 ubind @mega
   316 set :areUnitsAvailable.1:firstUnit @unit
   317 jump *label479 equal :areUnitsAvailable.1:firstUnit null
   318 set :needsFourUnits.1:unit @unit
 
   348 label *label475
   349 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   350 label *label476
-    * ubind :chooseUnitType:type
+  351 ubind @mega
   352 label *label477
   353 jump *label478 equal @unit :areUnitsAvailable.1:firstUnit
   354 sensor *tmp61 :areUnitsAvailable.1:firstUnit @dead
 
   357 label *label479
   358 label *label480
   359 jump *label483 equal true false
-    * print :chooseUnitType:type
+  360 print @mega
   361 print ":"
   362 print " occupied: "
   363 print :areUnitsAvailable.1:occupied
 
   377 label *label485
   378 jump *label486 equal *tmp40 false
   379 printflush null
-    * set *tmp9 :chooseUnitType:type
+  380 set *tmp9 @mega
   381 jump *label21 always
   382 label *label486
   383 label *label487
 
   386 label *label490
   387 set :chooseUnitType:type @mono
   388 label *label493
-    * jump *label514 equal :chooseUnitType:type UNIT_TYPE
+  389 jump *label514 equal @mono UNIT_TYPE
   390 set :areUnitsAvailable.1:free 0
   391 set :areUnitsAvailable.1:occupied 0
   392 set :areUnitsAvailable.1:needed 0
-    * ubind :chooseUnitType:type
+  393 ubind @mono
   394 set :areUnitsAvailable.1:firstUnit @unit
   395 jump *label505 equal :areUnitsAvailable.1:firstUnit null
   396 set :needsFourUnits.1:unit @unit
 
   426 label *label501
   427 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   428 label *label502
-    * ubind :chooseUnitType:type
+  429 ubind @mono
   430 label *label503
   431 jump *label504 equal @unit :areUnitsAvailable.1:firstUnit
   432 sensor *tmp61 :areUnitsAvailable.1:firstUnit @dead
 
   435 label *label505
   436 label *label506
   437 jump *label509 equal true false
-    * print :chooseUnitType:type
+  438 print @mono
   439 print ":"
   440 print " occupied: "
   441 print :areUnitsAvailable.1:occupied
 
   455 label *label511
   456 jump *label512 equal *tmp40 false
   457 printflush null
-    * set *tmp9 :chooseUnitType:type
+  458 set *tmp9 @mono
   459 jump *label21 always
   460 label *label512
   461 label *label513

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-4 instructions):
 
   150 jump *label21 always
   151 label *label25
   152 label *label26
-    * set :chooseUnitType:type @flare
   153 label *label415
   154 jump *label436 equal @flare UNIT_TYPE
   155 set :areUnitsAvailable.1:free 0
 
   227 label *label436
   228 label *label437
   229 label *label438
-    * set :chooseUnitType:type @poly
   230 label *label441
   231 jump *label462 equal @poly UNIT_TYPE
   232 set :areUnitsAvailable.1:free 0
 
   304 label *label462
   305 label *label463
   306 label *label464
-    * set :chooseUnitType:type @mega
   307 label *label467
   308 jump *label488 equal @mega UNIT_TYPE
   309 set :areUnitsAvailable.1:free 0
 
   381 label *label488
   382 label *label489
   383 label *label490
-    * set :chooseUnitType:type @mono
   384 label *label493
   385 jump *label514 equal @mono UNIT_TYPE
   386 set :areUnitsAvailable.1:free 0

Modifications by Iterated phase, Jump Normalization, pass 2, iteration 1 (-5 instructions):
 
   126 label *label35
   127 label *label28
   128 label *label29
-    * jump *label43 equal true false
   129 print UNIT_TYPE
   130 print ":"
   131 print " occupied: "
 
   198 label *label426
   199 label *label427
   200 label *label428
-    * jump *label431 equal true false
   201 print @flare
   202 print ":"
   203 print " occupied: "
 
   274 label *label452
   275 label *label453
   276 label *label454
-    * jump *label457 equal true false
   277 print @poly
   278 print ":"
   279 print " occupied: "
 
   350 label *label478
   351 label *label479
   352 label *label480
-    * jump *label483 equal true false
   353 print @mega
   354 print ":"
   355 print " occupied: "
 
   426 label *label504
   427 label *label505
   428 label *label506
-    * jump *label509 equal true false
   429 print @mono
   430 print ":"
   431 print " occupied: "
 
  1399 label *label364
  1400 label *label357
  1401 label *label358
-    * jump *label372 equal false false
+ 1402 jump *label372 always
  1403 print UNIT_TYPE
  1404 print ":"
  1405 print " occupied: "

Modifications by Iterated phase, Condition Optimization, pass 2, iteration 1 (-4 instructions):
 
    92 op mul *tmp17 2 *tmp16
    93 sensor *tmp18 :needsFourUnits:unit @speed
    94 op div :needsFourUnits:travel_time *tmp17 *tmp18
-    * op greaterThanEq *tmp13 :needsFourUnits:travel_time 47
    95 jump *label32 always
    96 label *label32
-    * jump *label30 equal *tmp13 false
+   97 jump *label30 lessThan :needsFourUnits:travel_time 47
    98 set *tmp21 4
    99 jump *label31 always
   100 label *label30
 
   166 op greaterThanEq *tmp43 :needsFourUnits.1:travel_time 47
   167 jump *label416 always
   168 label *label416
-    * jump *label417 equal *tmp43 false
+  169 jump *label417 lessThan :needsFourUnits.1:travel_time 47
   170 set *tmp51 4
   171 jump *label418 always
   172 label *label417
 
   242 op greaterThanEq *tmp43 :needsFourUnits.1:travel_time 47
   243 jump *label442 always
   244 label *label442
-    * jump *label443 equal *tmp43 false
+  245 jump *label443 lessThan :needsFourUnits.1:travel_time 47
   246 set *tmp51 4
   247 jump *label444 always
   248 label *label443
 
   318 op greaterThanEq *tmp43 :needsFourUnits.1:travel_time 47
   319 jump *label468 always
   320 label *label468
-    * jump *label469 equal *tmp43 false
+  321 jump *label469 lessThan :needsFourUnits.1:travel_time 47
   322 set *tmp51 4
   323 jump *label470 always
   324 label *label469
 
   394 op greaterThanEq *tmp43 :needsFourUnits.1:travel_time 47
   395 jump *label494 always
   396 label *label494
-    * jump *label495 equal *tmp43 false
+  397 jump *label495 lessThan :needsFourUnits.1:travel_time 47
   398 set *tmp51 4
   399 jump *label496 always
   400 label *label495
 
   594 op greaterThanEq *tmp126 :needsFourUnits.2:travel_time 47
   595 jump *label124 always
   596 label *label124
-    * jump *label125 equal *tmp126 false
+  597 jump *label125 lessThan :needsFourUnits.2:travel_time 47
   598 jump *label129 equal .UNIT_S2 null
   599 ubind .UNIT_S2
   600 sensor *tmp139 @unit @dead
 
   888 label *label179
   889 set .UNIT_S1 :processUnit:unit
   890 jump *label219 equal *tmp126 false
-    * op equal *tmp259 .SUPPLY_S_FIRST false
   891 jump *label223 equal .UNIT_S2 null
   892 ubind .UNIT_S2
   893 sensor *tmp263 @unit @dead
 
   975 jump *label251 notEqual :processUnit.1:state 3
   976 ucontrol within .DOME_X .DOME_Y 8 *tmp305
   977 jump *label253 equal *tmp305 false
-    * jump *label255 equal *tmp259 false
+  978 jump *label255 notEqual .SUPPLY_S_FIRST false
   979 ucontrol itemDrop .DOME .UNIT_CAPACITY
   980 set .MSG ", supplying\n"
   981 jump *label256 always
 
  1194 label *label266
  1195 set .UNIT_P1 :processUnit.2:unit
  1196 jump *label306 equal *tmp126 false
-    * op equal *tmp393 .SUPPLY_P_FIRST false
  1197 jump *label310 equal .UNIT_P2 null
  1198 ubind .UNIT_P2
  1199 sensor *tmp397 @unit @dead
 
  1281 jump *label338 notEqual :processUnit.3:state 3
  1282 ucontrol within .DOME_X .DOME_Y 8 *tmp439
  1283 jump *label340 equal *tmp439 false
-    * jump *label342 equal *tmp393 false
+ 1284 jump *label342 notEqual .SUPPLY_P_FIRST false
  1285 ucontrol itemDrop .DOME .UNIT_CAPACITY
  1286 set .MSG ", supplying\n"
  1287 jump *label343 always
 
  1362 set :needsFourUnits.3:unit @unit
  1363 sensor *tmp474 :needsFourUnits.3:unit @speed
  1364 op div :needsFourUnits.3:travel_time *tmp130 *tmp474
-    * op greaterThanEq *tmp469 :needsFourUnits.3:travel_time 47
  1365 jump *label361 always
  1366 label *label361
-    * jump *label359 equal *tmp469 false
+ 1367 jump *label359 lessThan :needsFourUnits.3:travel_time 47
  1368 set *tmp477 4
  1369 jump *label360 always
  1370 label *label359

Modifications by Iterated phase, Single Step Elimination, pass 2, iteration 1 (-17 instructions):
 
    92 op mul *tmp17 2 *tmp16
    93 sensor *tmp18 :needsFourUnits:unit @speed
    94 op div :needsFourUnits:travel_time *tmp17 *tmp18
-    * jump *label32 always
    95 label *label32
    96 jump *label30 lessThan :needsFourUnits:travel_time 47
    97 set *tmp21 4
 
   140 label *label43
   141 label *label44
   142 set *tmp10 false
-    * jump *label27 always
   143 label *label27
   144 jump *label25 equal *tmp10 false
   145 set *tmp9 UNIT_TYPE
 
   162 sensor *tmp48 :needsFourUnits.1:unit @speed
   163 op div :needsFourUnits.1:travel_time *tmp47 *tmp48
   164 op greaterThanEq *tmp43 :needsFourUnits.1:travel_time 47
-    * jump *label416 always
   165 label *label416
   166 jump *label417 lessThan :needsFourUnits.1:travel_time 47
   167 set *tmp51 4
 
   210 label *label431
   211 label *label432
   212 set *tmp40 false
-    * jump *label433 always
   213 label *label433
   214 jump *label434 equal *tmp40 false
   215 printflush null
 
   236 sensor *tmp48 :needsFourUnits.1:unit @speed
   237 op div :needsFourUnits.1:travel_time *tmp47 *tmp48
   238 op greaterThanEq *tmp43 :needsFourUnits.1:travel_time 47
-    * jump *label442 always
   239 label *label442
   240 jump *label443 lessThan :needsFourUnits.1:travel_time 47
   241 set *tmp51 4
 
   284 label *label457
   285 label *label458
   286 set *tmp40 false
-    * jump *label459 always
   287 label *label459
   288 jump *label460 equal *tmp40 false
   289 printflush null
 
   310 sensor *tmp48 :needsFourUnits.1:unit @speed
   311 op div :needsFourUnits.1:travel_time *tmp47 *tmp48
   312 op greaterThanEq *tmp43 :needsFourUnits.1:travel_time 47
-    * jump *label468 always
   313 label *label468
   314 jump *label469 lessThan :needsFourUnits.1:travel_time 47
   315 set *tmp51 4
 
   358 label *label483
   359 label *label484
   360 set *tmp40 false
-    * jump *label485 always
   361 label *label485
   362 jump *label486 equal *tmp40 false
   363 printflush null
 
   384 sensor *tmp48 :needsFourUnits.1:unit @speed
   385 op div :needsFourUnits.1:travel_time *tmp47 *tmp48
   386 op greaterThanEq *tmp43 :needsFourUnits.1:travel_time 47
-    * jump *label494 always
   387 label *label494
   388 jump *label495 lessThan :needsFourUnits.1:travel_time 47
   389 set *tmp51 4
 
   432 label *label509
   433 label *label510
   434 set *tmp40 false
-    * jump *label511 always
   435 label *label511
   436 jump *label512 equal *tmp40 false
   437 printflush null
 
   518 label *label90
   519 ucontrol flag 1
   520 set *tmp80 @unit
-    * jump *label89 always
   521 label *label89
   522 set .UNIT_S1 *tmp80
   523 jump *label105 equal .UNIT_P1 null
 
   554 label *label104
   555 ucontrol flag 1
   556 set *tmp98 @unit
-    * jump *label103 always
   557 label *label103
   558 set .UNIT_P1 *tmp98
   559 sensor *tmp116 *tmp80 @firstItem
 
   580 op mul *tmp130 2 *tmp129
   581 op div :needsFourUnits.2:travel_time *tmp130 .SPEED
   582 op greaterThanEq *tmp126 :needsFourUnits.2:travel_time 47
-    * jump *label124 always
   583 label *label124
   584 jump *label125 lessThan :needsFourUnits.2:travel_time 47
   585 jump *label129 equal .UNIT_S2 null
 
   616 label *label128
   617 ucontrol flag 1
   618 set *tmp135 @unit
-    * jump *label127 always
   619 label *label127
   620 set .UNIT_S2 *tmp135
   621 jump *label143 equal .UNIT_P2 null
 
   652 label *label142
   653 ucontrol flag 1
   654 set *tmp153 @unit
-    * jump *label141 always
   655 label *label141
   656 set .UNIT_P2 *tmp153
   657 sensor *tmp171 .UNIT_S1 @firstItem
 
  1347 set :needsFourUnits.3:unit @unit
  1348 sensor *tmp474 :needsFourUnits.3:unit @speed
  1349 op div :needsFourUnits.3:travel_time *tmp130 *tmp474
-    * jump *label361 always
  1350 label *label361
  1351 jump *label359 lessThan :needsFourUnits.3:travel_time 47
  1352 set *tmp477 4
 
  1396 label *label372
  1397 label *label373
  1398 set *tmp466 false
-    * jump *label356 always
  1399 label *label356
  1400 jump *label354 equal *tmp466 false
  1401 end

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1 (-6 instructions):
 
   161 op mul *tmp47 2 *tmp46
   162 sensor *tmp48 :needsFourUnits.1:unit @speed
   163 op div :needsFourUnits.1:travel_time *tmp47 *tmp48
-    * op greaterThanEq *tmp43 :needsFourUnits.1:travel_time 47
   164 label *label416
   165 jump *label417 lessThan :needsFourUnits.1:travel_time 47
   166 set *tmp51 4
 
   234 op mul *tmp47 2 *tmp46
   235 sensor *tmp48 :needsFourUnits.1:unit @speed
   236 op div :needsFourUnits.1:travel_time *tmp47 *tmp48
-    * op greaterThanEq *tmp43 :needsFourUnits.1:travel_time 47
   237 label *label442
   238 jump *label443 lessThan :needsFourUnits.1:travel_time 47
   239 set *tmp51 4
 
   307 op mul *tmp47 2 *tmp46
   308 sensor *tmp48 :needsFourUnits.1:unit @speed
   309 op div :needsFourUnits.1:travel_time *tmp47 *tmp48
-    * op greaterThanEq *tmp43 :needsFourUnits.1:travel_time 47
   310 label *label468
   311 jump *label469 lessThan :needsFourUnits.1:travel_time 47
   312 set *tmp51 4
 
   380 op mul *tmp47 2 *tmp46
   381 sensor *tmp48 :needsFourUnits.1:unit @speed
   382 op div :needsFourUnits.1:travel_time *tmp47 *tmp48
-    * op greaterThanEq *tmp43 :needsFourUnits.1:travel_time 47
   383 label *label494
   384 jump *label495 lessThan :needsFourUnits.1:travel_time 47
   385 set *tmp51 4
 
  1336 jump *label350 lessThanEq :unitCheck @time
  1337 set :areUnitsAvailable.2:free 0
  1338 set :areUnitsAvailable.2:occupied 0
-    * set :areUnitsAvailable.2:needed 0
  1339 ubind UNIT_TYPE
  1340 set :areUnitsAvailable.2:firstUnit @unit
  1341 jump *label357 equal :areUnitsAvailable.2:firstUnit null
 
  1349 label *label359
  1350 set *tmp477 2
  1351 label *label360
-    * set :areUnitsAvailable.2:needed *tmp477
  1352 label *label362
  1353 sensor *tmp478 @unit @controlled
  1354 jump *label367 equal *tmp478 0

Modifications by Iterated phase, If Expression Optimization, pass 2, iteration 1:
 
    85 ubind UNIT_TYPE
    86 set :areUnitsAvailable:firstUnit @unit
    87 jump *label28 equal :areUnitsAvailable:firstUnit null
+   88 set *tmp21 2
    89 set :needsFourUnits:unit @unit
    90 op sub *tmp14 .DOME_X .CORE_X
    91 op sub *tmp15 .DOME_Y .CORE_Y
 
    94 sensor *tmp18 :needsFourUnits:unit @speed
    95 op div :needsFourUnits:travel_time *tmp17 *tmp18
    96 label *label32
-    * jump *label30 lessThan :needsFourUnits:travel_time 47
+   97 jump *label31 lessThan :needsFourUnits:travel_time 47
    98 set *tmp21 4
    99 jump *label31 always
-    * label *label30
-    * set *tmp21 2
   100 label *label31
   101 set :areUnitsAvailable:needed *tmp21
   102 label *label33
 
   153 ubind @flare
   154 set :areUnitsAvailable.1:firstUnit @unit
   155 jump *label427 equal :areUnitsAvailable.1:firstUnit null
+  156 set *tmp51 2
   157 set :needsFourUnits.1:unit @unit
   158 op sub *tmp44 .DOME_X .CORE_X
   159 op sub *tmp45 .DOME_Y .CORE_Y
 
   162 sensor *tmp48 :needsFourUnits.1:unit @speed
   163 op div :needsFourUnits.1:travel_time *tmp47 *tmp48
   164 label *label416
-    * jump *label417 lessThan :needsFourUnits.1:travel_time 47
+  165 jump *label418 lessThan :needsFourUnits.1:travel_time 47
   166 set *tmp51 4
   167 jump *label418 always
-    * label *label417
-    * set *tmp51 2
   168 label *label418
   169 set :areUnitsAvailable.1:needed *tmp51
   170 label *label419
 
   225 ubind @poly
   226 set :areUnitsAvailable.1:firstUnit @unit
   227 jump *label453 equal :areUnitsAvailable.1:firstUnit null
+  228 set *tmp51 2
   229 set :needsFourUnits.1:unit @unit
   230 op sub *tmp44 .DOME_X .CORE_X
   231 op sub *tmp45 .DOME_Y .CORE_Y
 
   234 sensor *tmp48 :needsFourUnits.1:unit @speed
   235 op div :needsFourUnits.1:travel_time *tmp47 *tmp48
   236 label *label442
-    * jump *label443 lessThan :needsFourUnits.1:travel_time 47
+  237 jump *label444 lessThan :needsFourUnits.1:travel_time 47
   238 set *tmp51 4
   239 jump *label444 always
-    * label *label443
-    * set *tmp51 2
   240 label *label444
   241 set :areUnitsAvailable.1:needed *tmp51
   242 label *label445
 
   297 ubind @mega
   298 set :areUnitsAvailable.1:firstUnit @unit
   299 jump *label479 equal :areUnitsAvailable.1:firstUnit null
+  300 set *tmp51 2
   301 set :needsFourUnits.1:unit @unit
   302 op sub *tmp44 .DOME_X .CORE_X
   303 op sub *tmp45 .DOME_Y .CORE_Y
 
   306 sensor *tmp48 :needsFourUnits.1:unit @speed
   307 op div :needsFourUnits.1:travel_time *tmp47 *tmp48
   308 label *label468
-    * jump *label469 lessThan :needsFourUnits.1:travel_time 47
+  309 jump *label470 lessThan :needsFourUnits.1:travel_time 47
   310 set *tmp51 4
   311 jump *label470 always
-    * label *label469
-    * set *tmp51 2
   312 label *label470
   313 set :areUnitsAvailable.1:needed *tmp51
   314 label *label471
 
   369 ubind @mono
   370 set :areUnitsAvailable.1:firstUnit @unit
   371 jump *label505 equal :areUnitsAvailable.1:firstUnit null
+  372 set *tmp51 2
   373 set :needsFourUnits.1:unit @unit
   374 op sub *tmp44 .DOME_X .CORE_X
   375 op sub *tmp45 .DOME_Y .CORE_Y
 
   378 sensor *tmp48 :needsFourUnits.1:unit @speed
   379 op div :needsFourUnits.1:travel_time *tmp47 *tmp48
   380 label *label494
-    * jump *label495 lessThan :needsFourUnits.1:travel_time 47
+  381 jump *label496 lessThan :needsFourUnits.1:travel_time 47
   382 set *tmp51 4
   383 jump *label496 always
-    * label *label495
-    * set *tmp51 2
   384 label *label496
   385 set :areUnitsAvailable.1:needed *tmp51
   386 label *label497
 
  1334 ubind UNIT_TYPE
  1335 set :areUnitsAvailable.2:firstUnit @unit
  1336 jump *label357 equal :areUnitsAvailable.2:firstUnit null
+ 1337 set *tmp477 2
  1338 set :needsFourUnits.3:unit @unit
  1339 sensor *tmp474 :needsFourUnits.3:unit @speed
  1340 op div :needsFourUnits.3:travel_time *tmp130 *tmp474
  1341 label *label361
-    * jump *label359 lessThan :needsFourUnits.3:travel_time 47
+ 1342 jump *label360 lessThan :needsFourUnits.3:travel_time 47
  1343 set *tmp477 4
  1344 jump *label360 always
-    * label *label359
-    * set *tmp477 2
  1345 label *label360
  1346 label *label362
  1347 sensor *tmp478 @unit @controlled

Modifications by Iterated phase, Single Step Elimination, pass 3, iteration 1 (-6 instructions):
 
    96 label *label32
    97 jump *label31 lessThan :needsFourUnits:travel_time 47
    98 set *tmp21 4
-    * jump *label31 always
    99 label *label31
   100 set :areUnitsAvailable:needed *tmp21
   101 label *label33
 
   163 label *label416
   164 jump *label418 lessThan :needsFourUnits.1:travel_time 47
   165 set *tmp51 4
-    * jump *label418 always
   166 label *label418
   167 set :areUnitsAvailable.1:needed *tmp51
   168 label *label419
 
   234 label *label442
   235 jump *label444 lessThan :needsFourUnits.1:travel_time 47
   236 set *tmp51 4
-    * jump *label444 always
   237 label *label444
   238 set :areUnitsAvailable.1:needed *tmp51
   239 label *label445
 
   305 label *label468
   306 jump *label470 lessThan :needsFourUnits.1:travel_time 47
   307 set *tmp51 4
-    * jump *label470 always
   308 label *label470
   309 set :areUnitsAvailable.1:needed *tmp51
   310 label *label471
 
   376 label *label494
   377 jump *label496 lessThan :needsFourUnits.1:travel_time 47
   378 set *tmp51 4
-    * jump *label496 always
   379 label *label496
   380 set :areUnitsAvailable.1:needed *tmp51
   381 label *label497
 
  1336 label *label361
  1337 jump *label360 lessThan :needsFourUnits.3:travel_time 47
  1338 set *tmp477 4
-    * jump *label360 always
  1339 label *label360
  1340 label *label362
  1341 sensor *tmp478 @unit @controlled

Modifications by Jumps phase, Unreachable Code Elimination, pass 5, iteration 1 (-13 instructions):
 
     2 set UNIT_TYPE @flare
     3 remark "Do not modify anything below this line."
     4 set .DOME dome1
-    * label *label2
     5 jump *label4 notEqual dome1 null
     6 label *label381
     7 print "[gold]Waiting for an overdrive dome to be connected..."
     8 printflush message1
     9 set .DOME dome1
-    * label *label3
    10 jump *label381 equal dome1 null
    11 label *label4
    12 print "[gold]Locating core..."
    13 printflush message1
    14 set .CORE null
    15 label *label5
-    * label *label384
    16 set :locateCore:type @flare
    17 setaddr :locateCore*retaddr *label385 (h:*label385)
    18 call *label0 *invalid :locateCore*retval (m:*label385) (h:*label385)
 
    20 jump *label386 equal :locateCore*retval false
    21 jump *label1 always
    22 label *label386
-    * label *label387
-    * label *label388
-    * label *label391
    23 set :locateCore:type @poly
    24 setaddr :locateCore*retaddr *label392 (h:*label392)
    25 call *label0 *invalid :locateCore*retval (m:*label392) (h:*label392)
 
    27 jump *label393 equal :locateCore*retval false
    28 jump *label1 always
    29 label *label393
-    * label *label394
-    * label *label395
-    * label *label398
    30 set :locateCore:type @mega
    31 setaddr :locateCore*retaddr *label399 (h:*label399)
    32 call *label0 *invalid :locateCore*retval (m:*label399) (h:*label399)
 
    34 jump *label400 equal :locateCore*retval false
    35 jump *label1 always
    36 label *label400
-    * label *label401
-    * label *label402
-    * label *label405
    37 set :locateCore:type @mono
    38 setaddr :locateCore*retaddr *label406 (h:*label406)
    39 call *label0 *invalid :locateCore*retval (m:*label406) (h:*label406)
 
    41 jump *label407 equal :locateCore*retval false
    42 jump *label1 always
    43 label *label407
-    * label *label408
-    * label *label409
-    * label *label10
-    * label *label6
    44 jump *label5 always
-    * label *label7
    45 label *label1
    46 sensor .CORE_X .CORE @x
    47 sensor .CORE_Y .CORE @y
    48 sensor .DOME_X .DOME @x
    49 sensor .DOME_Y .DOME @y
-    * label *label18
    50 sensor *tmp7 switch1 @enabled
    51 jump *label20 notEqual *tmp7 false
    52 label *label413
    53 print "[coral]Activate switch to begin supplying overdrive dome..."
    54 print "\n"
    55 printflush message1
-    * label *label19
    56 sensor *tmp7 switch1 @enabled
    57 jump *label413 equal *tmp7 false
    58 label *label20
 
    74 op mul *tmp17 2 *tmp16
    75 sensor *tmp18 :needsFourUnits:unit @speed
    76 op div :needsFourUnits:travel_time *tmp17 *tmp18
-    * label *label32
    77 jump *label31 lessThan :needsFourUnits:travel_time 47
    78 set *tmp21 4
    79 label *label31
 
    89 set *tmp10 true
    90 jump *label27 always
    91 label *label40
-    * label *label41
    92 jump *label37 always
    93 label *label36
    94 op add :areUnitsAvailable:occupied :areUnitsAvailable:occupied 1
    95 label *label37
    96 ubind UNIT_TYPE
-    * label *label34
    97 jump *label35 equal @unit :areUnitsAvailable:firstUnit
    98 sensor *tmp31 :areUnitsAvailable:firstUnit @dead
    99 jump *label33 equal *tmp31 0
   100 label *label35
   101 label *label28
-    * label *label29
   102 print UNIT_TYPE
   103 print ":"
   104 print " occupied: "
 
   110 print ", needed: "
   111 print :areUnitsAvailable:needed
   112 label *label45
-    * label *label46
   113 print "\n"
-    * label *label43
-    * label *label44
   114 set *tmp10 false
   115 label *label27
   116 jump *label25 equal *tmp10 false
   117 set *tmp9 UNIT_TYPE
   118 jump *label21 always
   119 label *label25
-    * label *label26
-    * label *label415
   120 jump *label436 equal @flare UNIT_TYPE
   121 set :areUnitsAvailable.1:free 0
   122 set :areUnitsAvailable.1:occupied 0
 
   132 op mul *tmp47 2 *tmp46
   133 sensor *tmp48 :needsFourUnits.1:unit @speed
   134 op div :needsFourUnits.1:travel_time *tmp47 *tmp48
-    * label *label416
   135 jump *label418 lessThan :needsFourUnits.1:travel_time 47
   136 set *tmp51 4
   137 label *label418
 
   147 set *tmp40 true
   148 jump *label433 always
   149 label *label421
-    * label *label422
   150 jump *label424 always
   151 label *label423
   152 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   153 label *label424
   154 ubind @flare
-    * label *label425
   155 jump *label426 equal @unit :areUnitsAvailable.1:firstUnit
   156 sensor *tmp61 :areUnitsAvailable.1:firstUnit @dead
   157 jump *label419 equal *tmp61 0
   158 label *label426
   159 label *label427
-    * label *label428
   160 print @flare
   161 print ":"
   162 print " occupied: "
 
   168 print ", needed: "
   169 print :areUnitsAvailable.1:needed
   170 label *label429
-    * label *label430
   171 print "\n"
-    * label *label431
-    * label *label432
   172 set *tmp40 false
   173 label *label433
   174 jump *label434 equal *tmp40 false
 
   176 set *tmp9 @flare
   177 jump *label21 always
   178 label *label434
-    * label *label435
   179 label *label436
-    * label *label437
-    * label *label438
-    * label *label441
   180 jump *label462 equal @poly UNIT_TYPE
   181 set :areUnitsAvailable.1:free 0
   182 set :areUnitsAvailable.1:occupied 0
 
   192 op mul *tmp47 2 *tmp46
   193 sensor *tmp48 :needsFourUnits.1:unit @speed
   194 op div :needsFourUnits.1:travel_time *tmp47 *tmp48
-    * label *label442
   195 jump *label444 lessThan :needsFourUnits.1:travel_time 47
   196 set *tmp51 4
   197 label *label444
 
   207 set *tmp40 true
   208 jump *label459 always
   209 label *label447
-    * label *label448
   210 jump *label450 always
   211 label *label449
   212 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   213 label *label450
   214 ubind @poly
-    * label *label451
   215 jump *label452 equal @unit :areUnitsAvailable.1:firstUnit
   216 sensor *tmp61 :areUnitsAvailable.1:firstUnit @dead
   217 jump *label445 equal *tmp61 0
   218 label *label452
   219 label *label453
-    * label *label454
   220 print @poly
   221 print ":"
   222 print " occupied: "
 
   228 print ", needed: "
   229 print :areUnitsAvailable.1:needed
   230 label *label455
-    * label *label456
   231 print "\n"
-    * label *label457
-    * label *label458
   232 set *tmp40 false
   233 label *label459
   234 jump *label460 equal *tmp40 false
 
   236 set *tmp9 @poly
   237 jump *label21 always
   238 label *label460
-    * label *label461
   239 label *label462
-    * label *label463
-    * label *label464
-    * label *label467
   240 jump *label488 equal @mega UNIT_TYPE
   241 set :areUnitsAvailable.1:free 0
   242 set :areUnitsAvailable.1:occupied 0
 
   252 op mul *tmp47 2 *tmp46
   253 sensor *tmp48 :needsFourUnits.1:unit @speed
   254 op div :needsFourUnits.1:travel_time *tmp47 *tmp48
-    * label *label468
   255 jump *label470 lessThan :needsFourUnits.1:travel_time 47
   256 set *tmp51 4
   257 label *label470
 
   267 set *tmp40 true
   268 jump *label485 always
   269 label *label473
-    * label *label474
   270 jump *label476 always
   271 label *label475
   272 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   273 label *label476
   274 ubind @mega
-    * label *label477
   275 jump *label478 equal @unit :areUnitsAvailable.1:firstUnit
   276 sensor *tmp61 :areUnitsAvailable.1:firstUnit @dead
   277 jump *label471 equal *tmp61 0
   278 label *label478
   279 label *label479
-    * label *label480
   280 print @mega
   281 print ":"
   282 print " occupied: "
 
   288 print ", needed: "
   289 print :areUnitsAvailable.1:needed
   290 label *label481
-    * label *label482
   291 print "\n"
-    * label *label483
-    * label *label484
   292 set *tmp40 false
   293 label *label485
   294 jump *label486 equal *tmp40 false
 
   296 set *tmp9 @mega
   297 jump *label21 always
   298 label *label486
-    * label *label487
   299 label *label488
-    * label *label489
-    * label *label490
-    * label *label493
   300 jump *label514 equal @mono UNIT_TYPE
   301 set :areUnitsAvailable.1:free 0
   302 set :areUnitsAvailable.1:occupied 0
 
   312 op mul *tmp47 2 *tmp46
   313 sensor *tmp48 :needsFourUnits.1:unit @speed
   314 op div :needsFourUnits.1:travel_time *tmp47 *tmp48
-    * label *label494
   315 jump *label496 lessThan :needsFourUnits.1:travel_time 47
   316 set *tmp51 4
   317 label *label496
 
   327 set *tmp40 true
   328 jump *label511 always
   329 label *label499
-    * label *label500
   330 jump *label502 always
   331 label *label501
   332 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   333 label *label502
   334 ubind @mono
-    * label *label503
   335 jump *label504 equal @unit :areUnitsAvailable.1:firstUnit
   336 sensor *tmp61 :areUnitsAvailable.1:firstUnit @dead
   337 jump *label497 equal *tmp61 0
   338 label *label504
   339 label *label505
-    * label *label506
   340 print @mono
   341 print ":"
   342 print " occupied: "
 
   348 print ", needed: "
   349 print :areUnitsAvailable.1:needed
   350 label *label507
-    * label *label508
   351 print "\n"
-    * label *label509
-    * label *label510
   352 set *tmp40 false
   353 label *label511
   354 jump *label512 equal *tmp40 false
 
   356 set *tmp9 @mono
   357 jump *label21 always
   358 label *label512
-    * label *label513
   359 label *label514
-    * label *label515
-    * label *label516
-    * label *label49
   360 printflush message1
-    * label *label23
   361 jump *label22 always
-    * label *label24
-    * set *tmp9 null
   362 label *label21
   363 print "[gold]Binding units..."
   364 printflush message1
 
   372 jump *label79 notEqual :rebindUnits:firstUnit null
   373 end
   374 label *label79
-    * label *label80
   375 label *label81
   376 sensor *tmp70 @unit @controller
   377 jump *label84 notEqual *tmp70 @this
 
   384 jump *label86 equal .UNIT_S2 null
   385 jump *label83 always
   386 label *label86
-    * label *label87
   387 label *label84
-    * label *label85
   388 ubind *tmp9
-    * label *label82
   389 jump *label83 equal @unit :rebindUnits:firstUnit
   390 sensor *tmp78 :rebindUnits:firstUnit @dead
   391 jump *label81 equal *tmp78 0
   392 label *label83
-    * label *label78
   393 jump *label91 equal .UNIT_S1 null
   394 ubind .UNIT_S1
   395 sensor *tmp84 @unit @dead
 
   400 jump *label93 equal *tmp88 false
   401 jump *label90 always
   402 label *label93
-    * label *label94
   403 label *label91
-    * label *label92
   404 ubind *tmp9
   405 set :rebindUnit:firstUnit @unit
   406 jump *label95 equal :rebindUnit:firstUnit null
 
   409 jump *label100 notEqual *tmp92 0
   410 jump *label90 always
   411 label *label100
-    * label *label101
   412 ubind *tmp9
-    * label *label98
   413 jump *label99 equal @unit :rebindUnit:firstUnit
   414 sensor *tmp96 :rebindUnit:firstUnit @dead
   415 jump *label97 equal *tmp96 0
   416 label *label99
   417 label *label95
-    * label *label96
   418 end
   419 label *label90
   420 ucontrol flag 1
   421 set *tmp80 @unit
-    * label *label89
   422 set .UNIT_S1 *tmp80
   423 jump *label105 equal .UNIT_P1 null
   424 ubind .UNIT_P1
 
   430 jump *label107 equal *tmp106 false
   431 jump *label104 always
   432 label *label107
-    * label *label108
   433 label *label105
-    * label *label106
   434 ubind *tmp9
   435 set :rebindUnit.1:firstUnit @unit
   436 jump *label109 equal :rebindUnit.1:firstUnit null
 
   439 jump *label114 notEqual *tmp110 0
   440 jump *label104 always
   441 label *label114
-    * label *label115
   442 ubind *tmp9
-    * label *label112
   443 jump *label113 equal @unit :rebindUnit.1:firstUnit
   444 sensor *tmp114 :rebindUnit.1:firstUnit @dead
   445 jump *label111 equal *tmp114 0
   446 label *label113
   447 label *label109
-    * label *label110
   448 end
   449 label *label104
   450 ucontrol flag 1
   451 set *tmp98 @unit
-    * label *label103
   452 set .UNIT_P1 *tmp98
   453 sensor *tmp116 *tmp80 @firstItem
   454 jump *label119 equal *tmp116 @phase-fabric
   455 sensor *tmp118 *tmp98 @firstItem
   456 jump *label117 notEqual *tmp118 @silicon
   457 label *label119
-    * label *label121
   458 set .UNIT_S1 *tmp98
   459 set .UNIT_P1 *tmp80
   460 label *label117
-    * label *label118
   461 sensor .UNIT_CAPACITY .UNIT_S1 @itemCapacity
   462 sensor .SPEED .UNIT_S1 @speed
   463 op div .SPEED_TENTHS .SPEED 10
 
   465 jump *label122 equal *tmp124 false
   466 stop
   467 label *label122
-    * label *label123
   468 op sub *tmp127 .DOME_X .CORE_X
   469 op sub *tmp128 .DOME_Y .CORE_Y
   470 op len *tmp129 *tmp127 *tmp128
   471 op mul *tmp130 2 *tmp129
   472 op div :needsFourUnits.2:travel_time *tmp130 .SPEED
   473 op greaterThanEq *tmp126 :needsFourUnits.2:travel_time 47
-    * label *label124
   474 jump *label125 lessThan :needsFourUnits.2:travel_time 47
   475 jump *label129 equal .UNIT_S2 null
   476 ubind .UNIT_S2
 
   482 jump *label131 equal *tmp143 false
   483 jump *label128 always
   484 label *label131
-    * label *label132
   485 label *label129
-    * label *label130
   486 ubind *tmp9
   487 set :rebindUnit.2:firstUnit @unit
   488 jump *label133 equal :rebindUnit.2:firstUnit null
 
   491 jump *label138 notEqual *tmp147 0
   492 jump *label128 always
   493 label *label138
-    * label *label139
   494 ubind *tmp9
-    * label *label136
   495 jump *label137 equal @unit :rebindUnit.2:firstUnit
   496 sensor *tmp151 :rebindUnit.2:firstUnit @dead
   497 jump *label135 equal *tmp151 0
   498 label *label137
   499 label *label133
-    * label *label134
   500 end
   501 label *label128
   502 ucontrol flag 1
   503 set *tmp135 @unit
-    * label *label127
   504 set .UNIT_S2 *tmp135
   505 jump *label143 equal .UNIT_P2 null
   506 ubind .UNIT_P2
 
   512 jump *label145 equal *tmp161 false
   513 jump *label142 always
   514 label *label145
-    * label *label146
   515 label *label143
-    * label *label144
   516 ubind *tmp9
   517 set :rebindUnit.3:firstUnit @unit
   518 jump *label147 equal :rebindUnit.3:firstUnit null
 
   521 jump *label152 notEqual *tmp165 0
   522 jump *label142 always
   523 label *label152
-    * label *label153
   524 ubind *tmp9
-    * label *label150
   525 jump *label151 equal @unit :rebindUnit.3:firstUnit
   526 sensor *tmp169 :rebindUnit.3:firstUnit @dead
   527 jump *label149 equal *tmp169 0
   528 label *label151
   529 label *label147
-    * label *label148
   530 end
   531 label *label142
   532 ucontrol flag 1
   533 set *tmp153 @unit
-    * label *label141
   534 set .UNIT_P2 *tmp153
   535 sensor *tmp171 .UNIT_S1 @firstItem
   536 jump *label155 notEqual *tmp171 @phase-fabric
   537 sensor *tmp173 *tmp153 @firstItem
   538 jump *label155 equal *tmp173 @phase-fabric
   539 set :swap.1:t .UNIT_S1
-    * label *label159
   540 set .UNIT_S1 *tmp153
   541 set .UNIT_P2 :swap.1:t
   542 label *label155
-    * label *label156
   543 sensor *tmp176 *tmp135 @firstItem
   544 jump *label162 equal *tmp176 @phase-fabric
   545 sensor *tmp178 .UNIT_P2 @firstItem
   546 jump *label160 notEqual *tmp178 @silicon
   547 label *label162
-    * label *label164
   548 set .UNIT_S2 .UNIT_P2
   549 set .UNIT_P2 *tmp135
   550 label *label160
-    * label *label161
   551 set .GROUP1 "unit  1"
   552 set .GROUP2 "unit 2"
   553 jump *label126 always
 
   577 op lessThan .SUPPLY_P_FIRST *tmp187 *tmp188
   578 label *label170
   579 op add :unitCheck @time 5000
-    * label *label173
   580 sensor *tmp192 switch1 @enabled
   581 jump *label175 equal *tmp192 false
   582 label *label414
 
   605 print "]"
   606 print "\n"
   607 label *label178
-    * label *label176
   608 jump *label181 equal .UNIT_S1 null
   609 ubind .UNIT_S1
   610 sensor *tmp199 @unit @dead
 
   615 jump *label183 equal *tmp203 false
   616 jump *label180 always
   617 label *label183
-    * label *label184
   618 label *label181
-    * label *label182
   619 ubind *tmp9
   620 set :rebindUnit.4:firstUnit @unit
   621 jump *label185 equal :rebindUnit.4:firstUnit null
 
   624 jump *label190 notEqual *tmp207 0
   625 jump *label180 always
   626 label *label190
-    * label *label191
   627 ubind *tmp9
-    * label *label188
   628 jump *label189 equal @unit :rebindUnit.4:firstUnit
   629 sensor *tmp211 :rebindUnit.4:firstUnit @dead
   630 jump *label187 equal *tmp211 0
   631 label *label189
   632 label *label185
-    * label *label186
   633 end
   634 label *label180
   635 sensor :processUnit:state @unit @flag
 
   653 jump *label201 equal *tmp223 false
   654 ucontrol itemDrop .CORE .UNIT_CAPACITY
   655 label *label201
-    * label *label202
   656 label *label200
   657 label *label198
   658 label *label193
-    * label *label194
   659 jump *label203 notEqual :processUnit:state 2
   660 ucontrol within .CORE_X .CORE_Y 8 *tmp227
   661 jump *label205 equal *tmp227 false
 
   681 op div :processUnit:distance *tmp237 10
   682 label *label206
   683 label *label203
-    * label *label204
   684 jump *label209 notEqual :processUnit:state 3
   685 ucontrol within .DOME_X .DOME_Y 8 *tmp241
   686 jump *label211 equal *tmp241 false
 
   697 ucontrol approach .CORE_X .CORE_Y 6
   698 set :processUnit:state 2
   699 label *label215
-    * label *label216
   700 jump *label212 always
   701 label *label211
   702 ucontrol approach .DOME_X .DOME_Y 6
 
   710 op div :processUnit:distance *tmp252 10
   711 label *label212
   712 label *label209
-    * label *label210
   713 ucontrol flag :processUnit:state
   714 sensor *tmp254 @unit @totalItems
   715 print "  "
 
   732 print .MSG
   733 label *label218
   734 set :processUnit:unit @unit
-    * label *label179
   735 set .UNIT_S1 :processUnit:unit
   736 jump *label219 equal *tmp126 false
   737 jump *label223 equal .UNIT_S2 null
 
   744 jump *label225 equal *tmp267 false
   745 jump *label222 always
   746 label *label225
-    * label *label226
   747 label *label223
-    * label *label224
   748 ubind *tmp9
   749 set :rebindUnit.5:firstUnit @unit
   750 jump *label227 equal :rebindUnit.5:firstUnit null
 
   753 jump *label232 notEqual *tmp271 0
   754 jump *label222 always
   755 label *label232
-    * label *label233
   756 ubind *tmp9
-    * label *label230
   757 jump *label231 equal @unit :rebindUnit.5:firstUnit
   758 sensor *tmp275 :rebindUnit.5:firstUnit @dead
   759 jump *label229 equal *tmp275 0
   760 label *label231
   761 label *label227
-    * label *label228
   762 end
   763 label *label222
   764 sensor :processUnit.1:state @unit @flag
 
   782 jump *label243 equal *tmp287 false
   783 ucontrol itemDrop .CORE .UNIT_CAPACITY
   784 label *label243
-    * label *label244
   785 label *label242
   786 label *label240
   787 label *label235
-    * label *label236
   788 jump *label245 notEqual :processUnit.1:state 2
   789 ucontrol within .CORE_X .CORE_Y 8 *tmp291
   790 jump *label247 equal *tmp291 false
 
   810 op div :processUnit.1:distance *tmp301 10
   811 label *label248
   812 label *label245
-    * label *label246
   813 jump *label251 notEqual :processUnit.1:state 3
   814 ucontrol within .DOME_X .DOME_Y 8 *tmp305
   815 jump *label253 equal *tmp305 false
 
   826 ucontrol approach .CORE_X .CORE_Y 6
   827 set :processUnit.1:state 2
   828 label *label257
-    * label *label258
   829 jump *label254 always
   830 label *label253
   831 ucontrol approach .DOME_X .DOME_Y 6
 
   839 op div :processUnit.1:distance *tmp316 10
   840 label *label254
   841 label *label251
-    * label *label252
   842 ucontrol flag :processUnit.1:state
   843 sensor *tmp318 @unit @totalItems
   844 print "  "
 
   861 print .MSG
   862 label *label260
   863 set :processUnit.1:unit @unit
-    * label *label221
   864 set .UNIT_S2 :processUnit.1:unit
   865 jump *label261 equal .SUPPLY_S_FIRST false
   866 sensor *tmp323 :processUnit:unit @totalItems
 
   871 op equal .SUPPLY_S_FIRST *tmp325 0
   872 label *label262
   873 label *label219
-    * label *label220
   874 print "\n[green]Phase fabric[] status:\n"
   875 sensor :printDomeStatus.1:level .DOME @phase-fabric
   876 jump *label264 lessThanEq :printDomeStatus.1:level 3
 
   887 print "]"
   888 print "\n"
   889 label *label265
-    * label *label263
   890 jump *label268 equal .UNIT_P1 null
   891 ubind .UNIT_P1
   892 sensor *tmp333 @unit @dead
 
   897 jump *label270 equal *tmp337 false
   898 jump *label267 always
   899 label *label270
-    * label *label271
   900 label *label268
-    * label *label269
   901 ubind *tmp9
   902 set :rebindUnit.6:firstUnit @unit
   903 jump *label272 equal :rebindUnit.6:firstUnit null
 
   906 jump *label277 notEqual *tmp341 0
   907 jump *label267 always
   908 label *label277
-    * label *label278
   909 ubind *tmp9
-    * label *label275
   910 jump *label276 equal @unit :rebindUnit.6:firstUnit
   911 sensor *tmp345 :rebindUnit.6:firstUnit @dead
   912 jump *label274 equal *tmp345 0
   913 label *label276
   914 label *label272
-    * label *label273
   915 end
   916 label *label267
   917 sensor :processUnit.2:state @unit @flag
 
   935 jump *label288 equal *tmp357 false
   936 ucontrol itemDrop .CORE .UNIT_CAPACITY
   937 label *label288
-    * label *label289
   938 label *label287
   939 label *label285
   940 label *label280
-    * label *label281
   941 jump *label290 notEqual :processUnit.2:state 2
   942 ucontrol within .CORE_X .CORE_Y 8 *tmp361
   943 jump *label292 equal *tmp361 false
 
   963 op div :processUnit.2:distance *tmp371 10
   964 label *label293
   965 label *label290
-    * label *label291
   966 jump *label296 notEqual :processUnit.2:state 3
   967 ucontrol within .DOME_X .DOME_Y 8 *tmp375
   968 jump *label298 equal *tmp375 false
 
   979 ucontrol approach .CORE_X .CORE_Y 6
   980 set :processUnit.2:state 2
   981 label *label302
-    * label *label303
   982 jump *label299 always
   983 label *label298
   984 ucontrol approach .DOME_X .DOME_Y 6
 
   992 op div :processUnit.2:distance *tmp386 10
   993 label *label299
   994 label *label296
-    * label *label297
   995 ucontrol flag :processUnit.2:state
   996 sensor *tmp388 @unit @totalItems
   997 print "  "
 
  1014 print .MSG
  1015 label *label305
  1016 set :processUnit.2:unit @unit
-    * label *label266
  1017 set .UNIT_P1 :processUnit.2:unit
  1018 jump *label306 equal *tmp126 false
  1019 jump *label310 equal .UNIT_P2 null
 
  1026 jump *label312 equal *tmp401 false
  1027 jump *label309 always
  1028 label *label312
-    * label *label313
  1029 label *label310
-    * label *label311
  1030 ubind *tmp9
  1031 set :rebindUnit.7:firstUnit @unit
  1032 jump *label314 equal :rebindUnit.7:firstUnit null
 
  1035 jump *label319 notEqual *tmp405 0
  1036 jump *label309 always
  1037 label *label319
-    * label *label320
  1038 ubind *tmp9
-    * label *label317
  1039 jump *label318 equal @unit :rebindUnit.7:firstUnit
  1040 sensor *tmp409 :rebindUnit.7:firstUnit @dead
  1041 jump *label316 equal *tmp409 0
  1042 label *label318
  1043 label *label314
-    * label *label315
  1044 end
  1045 label *label309
  1046 sensor :processUnit.3:state @unit @flag
 
  1064 jump *label330 equal *tmp421 false
  1065 ucontrol itemDrop .CORE .UNIT_CAPACITY
  1066 label *label330
-    * label *label331
  1067 label *label329
  1068 label *label327
  1069 label *label322
-    * label *label323
  1070 jump *label332 notEqual :processUnit.3:state 2
  1071 ucontrol within .CORE_X .CORE_Y 8 *tmp425
  1072 jump *label334 equal *tmp425 false
 
  1092 op div :processUnit.3:distance *tmp435 10
  1093 label *label335
  1094 label *label332
-    * label *label333
  1095 jump *label338 notEqual :processUnit.3:state 3
  1096 ucontrol within .DOME_X .DOME_Y 8 *tmp439
  1097 jump *label340 equal *tmp439 false
 
  1108 ucontrol approach .CORE_X .CORE_Y 6
  1109 set :processUnit.3:state 2
  1110 label *label344
-    * label *label345
  1111 jump *label341 always
  1112 label *label340
  1113 ucontrol approach .DOME_X .DOME_Y 6
 
  1121 op div :processUnit.3:distance *tmp450 10
  1122 label *label341
  1123 label *label338
-    * label *label339
  1124 ucontrol flag :processUnit.3:state
  1125 sensor *tmp452 @unit @totalItems
  1126 print "  "
 
  1143 print .MSG
  1144 label *label347
  1145 set :processUnit.3:unit @unit
-    * label *label308
  1146 set .UNIT_P2 :processUnit.3:unit
  1147 jump *label348 equal .SUPPLY_P_FIRST false
  1148 sensor *tmp457 :processUnit.2:unit @totalItems
 
  1153 op equal .SUPPLY_P_FIRST *tmp459 0
  1154 label *label349
  1155 label *label306
-    * label *label307
  1156 op sub *tmp461 @time :start
  1157 op floor *tmp462 *tmp461
  1158 print "\n"
 
  1172 set :needsFourUnits.3:unit @unit
  1173 sensor *tmp474 :needsFourUnits.3:unit @speed
  1174 op div :needsFourUnits.3:travel_time *tmp130 *tmp474
-    * label *label361
  1175 jump *label360 lessThan :needsFourUnits.3:travel_time 47
  1176 set *tmp477 4
  1177 label *label360
 
  1186 set *tmp466 true
  1187 jump *label356 always
  1188 label *label369
-    * label *label370
  1189 jump *label366 always
  1190 label *label365
  1191 op add :areUnitsAvailable.2:occupied :areUnitsAvailable.2:occupied 1
  1192 label *label366
  1193 ubind UNIT_TYPE
-    * label *label363
  1194 jump *label364 equal @unit :areUnitsAvailable.2:firstUnit
  1195 sensor *tmp487 :areUnitsAvailable.2:firstUnit @dead
  1196 jump *label362 equal *tmp487 0
  1197 label *label364
  1198 label *label357
-    * label *label358
  1199 jump *label372 always
-    * print UNIT_TYPE
-    * print ":"
-    * print " occupied: "
-    * print :areUnitsAvailable.2:occupied
-    * print ","
-    * print " free: "
-    * print :areUnitsAvailable.2:free
-    * jump *label374 lessThanEq :areUnitsAvailable.2:needed 0
-    * print ", needed: "
-    * print :areUnitsAvailable.2:needed
-    * label *label374
-    * label *label375
-    * print "\n"
  1200 label *label372
-    * label *label373
  1201 set *tmp466 false
  1202 label *label356
  1203 jump *label354 equal *tmp466 false
  1204 end
  1205 label *label354
-    * label *label355
  1206 op add :unitCheck @time 5000
  1207 label *label350
-    * label *label351
-    * label *label174
  1208 sensor *tmp192 switch1 @enabled
  1209 jump *label414 notEqual *tmp192 false
  1210 label *label175
 
  1218 label *label379
  1219 ulocate building core false @copper *tmp500 *tmp501 *tmp502 .CORE
  1220 label *label377
-    * label *label378
  1221 set :locateCore*retval .CORE
-    * label *label376
  1222 return :locateCore*retaddr
-    * end

Modifications by Jumps phase, Jump Straightening, pass 5, iteration 1 (-21 instructions):
 
    17 setaddr :locateCore*retaddr *label385 (h:*label385)
    18 call *label0 *invalid :locateCore*retval (m:*label385) (h:*label385)
    19 label *label385
-    * jump *label386 equal :locateCore*retval false
-    * jump *label1 always
+   20 jump *label1 notEqual :locateCore*retval false
    21 label *label386
    22 set :locateCore:type @poly
    23 setaddr :locateCore*retaddr *label392 (h:*label392)
    24 call *label0 *invalid :locateCore*retval (m:*label392) (h:*label392)
    25 label *label392
-    * jump *label393 equal :locateCore*retval false
-    * jump *label1 always
+   26 jump *label1 notEqual :locateCore*retval false
    27 label *label393
    28 set :locateCore:type @mega
    29 setaddr :locateCore*retaddr *label399 (h:*label399)
    30 call *label0 *invalid :locateCore*retval (m:*label399) (h:*label399)
    31 label *label399
-    * jump *label400 equal :locateCore*retval false
-    * jump *label1 always
+   32 jump *label1 notEqual :locateCore*retval false
    33 label *label400
    34 set :locateCore:type @mono
    35 setaddr :locateCore*retaddr *label406 (h:*label406)
    36 call *label0 *invalid :locateCore*retval (m:*label406) (h:*label406)
    37 label *label406
-    * jump *label407 equal :locateCore*retval false
-    * jump *label1 always
+   38 jump *label1 notEqual :locateCore*retval false
    39 label *label407
    40 jump *label5 always
    41 label *label1
 
   377 set .UNIT_P2 .UNIT_S1
   378 set .UNIT_S1 .UNIT_P1
   379 set .UNIT_P1 @unit
-    * jump *label86 equal .UNIT_S2 null
-    * jump *label83 always
+  380 jump *label83 notEqual .UNIT_S2 null
   381 label *label86
   382 label *label84
   383 ubind *tmp9
 
   392 sensor *tmp86 @unit @controller
   393 op equal *tmp87 *tmp86 @this
   394 op land *tmp88 *tmp85 *tmp87
-    * jump *label93 equal *tmp88 false
-    * jump *label90 always
+  395 jump *label90 notEqual *tmp88 false
   396 label *label93
   397 label *label91
   398 ubind *tmp9
 
   400 jump *label95 equal :rebindUnit:firstUnit null
   401 label *label97
   402 sensor *tmp92 @unit @controlled
-    * jump *label100 notEqual *tmp92 0
-    * jump *label90 always
+  403 jump *label90 equal *tmp92 0
   404 label *label100
   405 ubind *tmp9
   406 jump *label99 equal @unit :rebindUnit:firstUnit
 
   420 sensor *tmp104 @unit @controller
   421 op equal *tmp105 *tmp104 @this
   422 op land *tmp106 *tmp103 *tmp105
-    * jump *label107 equal *tmp106 false
-    * jump *label104 always
+  423 jump *label104 notEqual *tmp106 false
   424 label *label107
   425 label *label105
   426 ubind *tmp9
 
   428 jump *label109 equal :rebindUnit.1:firstUnit null
   429 label *label111
   430 sensor *tmp110 @unit @controlled
-    * jump *label114 notEqual *tmp110 0
-    * jump *label104 always
+  431 jump *label104 equal *tmp110 0
   432 label *label114
   433 ubind *tmp9
   434 jump *label113 equal @unit :rebindUnit.1:firstUnit
 
   470 sensor *tmp141 @unit @controller
   471 op equal *tmp142 *tmp141 @this
   472 op land *tmp143 *tmp140 *tmp142
-    * jump *label131 equal *tmp143 false
-    * jump *label128 always
+  473 jump *label128 notEqual *tmp143 false
   474 label *label131
   475 label *label129
   476 ubind *tmp9
 
   478 jump *label133 equal :rebindUnit.2:firstUnit null
   479 label *label135
   480 sensor *tmp147 @unit @controlled
-    * jump *label138 notEqual *tmp147 0
-    * jump *label128 always
+  481 jump *label128 equal *tmp147 0
   482 label *label138
   483 ubind *tmp9
   484 jump *label137 equal @unit :rebindUnit.2:firstUnit
 
   498 sensor *tmp159 @unit @controller
   499 op equal *tmp160 *tmp159 @this
   500 op land *tmp161 *tmp158 *tmp160
-    * jump *label145 equal *tmp161 false
-    * jump *label142 always
+  501 jump *label142 notEqual *tmp161 false
   502 label *label145
   503 label *label143
   504 ubind *tmp9
 
   506 jump *label147 equal :rebindUnit.3:firstUnit null
   507 label *label149
   508 sensor *tmp165 @unit @controlled
-    * jump *label152 notEqual *tmp165 0
-    * jump *label142 always
+  509 jump *label142 equal *tmp165 0
   510 label *label152
   511 ubind *tmp9
   512 jump *label151 equal @unit :rebindUnit.3:firstUnit
 
   599 sensor *tmp201 @unit @controller
   600 op equal *tmp202 *tmp201 @this
   601 op land *tmp203 *tmp200 *tmp202
-    * jump *label183 equal *tmp203 false
-    * jump *label180 always
+  602 jump *label180 notEqual *tmp203 false
   603 label *label183
   604 label *label181
   605 ubind *tmp9
 
   607 jump *label185 equal :rebindUnit.4:firstUnit null
   608 label *label187
   609 sensor *tmp207 @unit @controlled
-    * jump *label190 notEqual *tmp207 0
-    * jump *label180 always
+  610 jump *label180 equal *tmp207 0
   611 label *label190
   612 ubind *tmp9
   613 jump *label189 equal @unit :rebindUnit.4:firstUnit
 
   726 sensor *tmp265 @unit @controller
   727 op equal *tmp266 *tmp265 @this
   728 op land *tmp267 *tmp264 *tmp266
-    * jump *label225 equal *tmp267 false
-    * jump *label222 always
+  729 jump *label222 notEqual *tmp267 false
   730 label *label225
   731 label *label223
   732 ubind *tmp9
 
   734 jump *label227 equal :rebindUnit.5:firstUnit null
   735 label *label229
   736 sensor *tmp271 @unit @controlled
-    * jump *label232 notEqual *tmp271 0
-    * jump *label222 always
+  737 jump *label222 equal *tmp271 0
   738 label *label232
   739 ubind *tmp9
   740 jump *label231 equal @unit :rebindUnit.5:firstUnit
 
   877 sensor *tmp335 @unit @controller
   878 op equal *tmp336 *tmp335 @this
   879 op land *tmp337 *tmp334 *tmp336
-    * jump *label270 equal *tmp337 false
-    * jump *label267 always
+  880 jump *label267 notEqual *tmp337 false
   881 label *label270
   882 label *label268
   883 ubind *tmp9
 
   885 jump *label272 equal :rebindUnit.6:firstUnit null
   886 label *label274
   887 sensor *tmp341 @unit @controlled
-    * jump *label277 notEqual *tmp341 0
-    * jump *label267 always
+  888 jump *label267 equal *tmp341 0
   889 label *label277
   890 ubind *tmp9
   891 jump *label276 equal @unit :rebindUnit.6:firstUnit
 
  1004 sensor *tmp399 @unit @controller
  1005 op equal *tmp400 *tmp399 @this
  1006 op land *tmp401 *tmp398 *tmp400
-    * jump *label312 equal *tmp401 false
-    * jump *label309 always
+ 1007 jump *label309 notEqual *tmp401 false
  1008 label *label312
  1009 label *label310
  1010 ubind *tmp9
 
  1012 jump *label314 equal :rebindUnit.7:firstUnit null
  1013 label *label316
  1014 sensor *tmp405 @unit @controlled
-    * jump *label319 notEqual *tmp405 0
-    * jump *label309 always
+ 1015 jump *label309 equal *tmp405 0
  1016 label *label319
  1017 ubind *tmp9
  1018 jump *label318 equal @unit :rebindUnit.7:firstUnit

Modifications by Jumps phase, Jump Threading, pass 5, iteration 1:
+    0 label __start__
     1 remark "This is the preferred unit type to use for bringing in supplies."
     2 remark "If no units of this type exist, we'll try using other types."
     3 set UNIT_TYPE @flare
 
    78 jump *label36 notEqual *tmp24 @this
    79 label *label38
    80 op add :areUnitsAvailable:free :areUnitsAvailable:free 1
-    * jump *label40 lessThan :areUnitsAvailable:free *tmp21
+   81 jump *label37 lessThan :areUnitsAvailable:free *tmp21
    82 set *tmp10 true
    83 jump *label27 always
    84 label *label40
 
   136 jump *label423 notEqual *tmp54 @this
   137 label *label420
   138 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
-    * jump *label421 lessThan :areUnitsAvailable.1:free *tmp51
+  139 jump *label424 lessThan :areUnitsAvailable.1:free *tmp51
   140 set *tmp40 true
   141 jump *label433 always
   142 label *label421
 
   196 jump *label449 notEqual *tmp54 @this
   197 label *label446
   198 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
-    * jump *label447 lessThan :areUnitsAvailable.1:free *tmp51
+  199 jump *label450 lessThan :areUnitsAvailable.1:free *tmp51
   200 set *tmp40 true
   201 jump *label459 always
   202 label *label447
 
   256 jump *label475 notEqual *tmp54 @this
   257 label *label472
   258 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
-    * jump *label473 lessThan :areUnitsAvailable.1:free *tmp51
+  259 jump *label476 lessThan :areUnitsAvailable.1:free *tmp51
   260 set *tmp40 true
   261 jump *label485 always
   262 label *label473
 
   316 jump *label501 notEqual *tmp54 @this
   317 label *label498
   318 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
-    * jump *label499 lessThan :areUnitsAvailable.1:free *tmp51
+  319 jump *label502 lessThan :areUnitsAvailable.1:free *tmp51
   320 set *tmp40 true
   321 jump *label511 always
   322 label *label499
 
   392 label *label91
   393 ubind *tmp9
   394 set :rebindUnit:firstUnit @unit
-    * jump *label95 equal :rebindUnit:firstUnit null
+  395 jump __start__ equal :rebindUnit:firstUnit null
   396 label *label97
   397 sensor *tmp92 @unit @controlled
   398 jump *label90 equal *tmp92 0
   399 ubind *tmp9
-    * jump *label99 equal @unit :rebindUnit:firstUnit
+  400 jump __start__ equal @unit :rebindUnit:firstUnit
   401 sensor *tmp96 :rebindUnit:firstUnit @dead
   402 jump *label97 equal *tmp96 0
   403 label *label99
 
   418 label *label105
   419 ubind *tmp9
   420 set :rebindUnit.1:firstUnit @unit
-    * jump *label109 equal :rebindUnit.1:firstUnit null
+  421 jump __start__ equal :rebindUnit.1:firstUnit null
   422 label *label111
   423 sensor *tmp110 @unit @controlled
   424 jump *label104 equal *tmp110 0
   425 ubind *tmp9
-    * jump *label113 equal @unit :rebindUnit.1:firstUnit
+  426 jump __start__ equal @unit :rebindUnit.1:firstUnit
   427 sensor *tmp114 :rebindUnit.1:firstUnit @dead
   428 jump *label111 equal *tmp114 0
   429 label *label113
 
   466 label *label129
   467 ubind *tmp9
   468 set :rebindUnit.2:firstUnit @unit
-    * jump *label133 equal :rebindUnit.2:firstUnit null
+  469 jump __start__ equal :rebindUnit.2:firstUnit null
   470 label *label135
   471 sensor *tmp147 @unit @controlled
   472 jump *label128 equal *tmp147 0
   473 ubind *tmp9
-    * jump *label137 equal @unit :rebindUnit.2:firstUnit
+  474 jump __start__ equal @unit :rebindUnit.2:firstUnit
   475 sensor *tmp151 :rebindUnit.2:firstUnit @dead
   476 jump *label135 equal *tmp151 0
   477 label *label137
 
   492 label *label143
   493 ubind *tmp9
   494 set :rebindUnit.3:firstUnit @unit
-    * jump *label147 equal :rebindUnit.3:firstUnit null
+  495 jump __start__ equal :rebindUnit.3:firstUnit null
   496 label *label149
   497 sensor *tmp165 @unit @controlled
   498 jump *label142 equal *tmp165 0
   499 ubind *tmp9
-    * jump *label151 equal @unit :rebindUnit.3:firstUnit
+  500 jump __start__ equal @unit :rebindUnit.3:firstUnit
   501 sensor *tmp169 :rebindUnit.3:firstUnit @dead
   502 jump *label149 equal *tmp169 0
   503 label *label151
 
   553 label *label170
   554 op add :unitCheck @time 5000
   555 sensor *tmp192 switch1 @enabled
-    * jump *label175 equal *tmp192 false
+  556 jump __start__ equal *tmp192 false
   557 label *label414
   558 set :start @time
   559 print " === [gold]Supplying Overdrive Dome[] === "
 
   591 label *label181
   592 ubind *tmp9
   593 set :rebindUnit.4:firstUnit @unit
-    * jump *label185 equal :rebindUnit.4:firstUnit null
+  594 jump __start__ equal :rebindUnit.4:firstUnit null
   595 label *label187
   596 sensor *tmp207 @unit @controlled
   597 jump *label180 equal *tmp207 0
   598 ubind *tmp9
-    * jump *label189 equal @unit :rebindUnit.4:firstUnit
+  599 jump __start__ equal @unit :rebindUnit.4:firstUnit
   600 sensor *tmp211 :rebindUnit.4:firstUnit @dead
   601 jump *label187 equal *tmp211 0
   602 label *label189
 
   635 jump *label207 lessThan *tmp229 .UNIT_CAPACITY
   636 ucontrol approach .DOME_X .DOME_Y 6
   637 set :processUnit:state 3
-    * jump *label208 always
+  638 jump *label206 always
   639 label *label207
   640 set .MSG ", loading\n"
   641 label *label208
 
   664 set .MSG ", waiting\n"
   665 label *label214
   666 sensor *tmp244 @unit @totalItems
-    * jump *label215 greaterThan *tmp244 0
+  667 jump *label212 greaterThan *tmp244 0
   668 ucontrol approach .CORE_X .CORE_Y 6
   669 set :processUnit:state 2
   670 label *label215
 
   716 label *label223
   717 ubind *tmp9
   718 set :rebindUnit.5:firstUnit @unit
-    * jump *label227 equal :rebindUnit.5:firstUnit null
+  719 jump __start__ equal :rebindUnit.5:firstUnit null
   720 label *label229
   721 sensor *tmp271 @unit @controlled
   722 jump *label222 equal *tmp271 0
   723 ubind *tmp9
-    * jump *label231 equal @unit :rebindUnit.5:firstUnit
+  724 jump __start__ equal @unit :rebindUnit.5:firstUnit
   725 sensor *tmp275 :rebindUnit.5:firstUnit @dead
   726 jump *label229 equal *tmp275 0
   727 label *label231
 
   760 jump *label249 lessThan *tmp293 .UNIT_CAPACITY
   761 ucontrol approach .DOME_X .DOME_Y 6
   762 set :processUnit.1:state 3
-    * jump *label250 always
+  763 jump *label248 always
   764 label *label249
   765 set .MSG ", loading\n"
   766 label *label250
 
   789 set .MSG ", waiting\n"
   790 label *label256
   791 sensor *tmp308 @unit @totalItems
-    * jump *label257 greaterThan *tmp308 0
+  792 jump *label254 greaterThan *tmp308 0
   793 ucontrol approach .CORE_X .CORE_Y 6
   794 set :processUnit.1:state 2
   795 label *label257
 
   865 label *label268
   866 ubind *tmp9
   867 set :rebindUnit.6:firstUnit @unit
-    * jump *label272 equal :rebindUnit.6:firstUnit null
+  868 jump __start__ equal :rebindUnit.6:firstUnit null
   869 label *label274
   870 sensor *tmp341 @unit @controlled
   871 jump *label267 equal *tmp341 0
   872 ubind *tmp9
-    * jump *label276 equal @unit :rebindUnit.6:firstUnit
+  873 jump __start__ equal @unit :rebindUnit.6:firstUnit
   874 sensor *tmp345 :rebindUnit.6:firstUnit @dead
   875 jump *label274 equal *tmp345 0
   876 label *label276
 
   909 jump *label294 lessThan *tmp363 .UNIT_CAPACITY
   910 ucontrol approach .DOME_X .DOME_Y 6
   911 set :processUnit.2:state 3
-    * jump *label295 always
+  912 jump *label293 always
   913 label *label294
   914 set .MSG ", loading\n"
   915 label *label295
 
   938 set .MSG ", waiting\n"
   939 label *label301
   940 sensor *tmp378 @unit @totalItems
-    * jump *label302 greaterThan *tmp378 0
+  941 jump *label299 greaterThan *tmp378 0
   942 ucontrol approach .CORE_X .CORE_Y 6
   943 set :processUnit.2:state 2
   944 label *label302
 
   990 label *label310
   991 ubind *tmp9
   992 set :rebindUnit.7:firstUnit @unit
-    * jump *label314 equal :rebindUnit.7:firstUnit null
+  993 jump __start__ equal :rebindUnit.7:firstUnit null
   994 label *label316
   995 sensor *tmp405 @unit @controlled
   996 jump *label309 equal *tmp405 0
   997 ubind *tmp9
-    * jump *label318 equal @unit :rebindUnit.7:firstUnit
+  998 jump __start__ equal @unit :rebindUnit.7:firstUnit
   999 sensor *tmp409 :rebindUnit.7:firstUnit @dead
  1000 jump *label316 equal *tmp409 0
  1001 label *label318
 
  1034 jump *label336 lessThan *tmp427 .UNIT_CAPACITY
  1035 ucontrol approach .DOME_X .DOME_Y 6
  1036 set :processUnit.3:state 3
-    * jump *label337 always
+ 1037 jump *label335 always
  1038 label *label336
  1039 set .MSG ", loading\n"
  1040 label *label337
 
  1063 set .MSG ", waiting\n"
  1064 label *label343
  1065 sensor *tmp442 @unit @totalItems
-    * jump *label344 greaterThan *tmp442 0
+ 1066 jump *label341 greaterThan *tmp442 0
  1067 ucontrol approach .CORE_X .CORE_Y 6
  1068 set :processUnit.3:state 2
  1069 label *label344
 
  1126 set :areUnitsAvailable.2:occupied 0
  1127 ubind UNIT_TYPE
  1128 set :areUnitsAvailable.2:firstUnit @unit
-    * jump *label357 equal :areUnitsAvailable.2:firstUnit null
+ 1129 jump *label372 equal :areUnitsAvailable.2:firstUnit null
  1130 set *tmp477 2
  1131 set :needsFourUnits.3:unit @unit
  1132 sensor *tmp474 :needsFourUnits.3:unit @speed
 
  1141 jump *label365 notEqual *tmp480 @this
  1142 label *label367
  1143 op add :areUnitsAvailable.2:free :areUnitsAvailable.2:free 1
-    * jump *label369 lessThan :areUnitsAvailable.2:free *tmp477
+ 1144 jump *label366 lessThan :areUnitsAvailable.2:free *tmp477
  1145 set *tmp466 true
  1146 jump *label356 always
  1147 label *label369
 
  1150 op add :areUnitsAvailable.2:occupied :areUnitsAvailable.2:occupied 1
  1151 label *label366
  1152 ubind UNIT_TYPE
-    * jump *label364 equal @unit :areUnitsAvailable.2:firstUnit
+ 1153 jump *label372 equal @unit :areUnitsAvailable.2:firstUnit
  1154 sensor *tmp487 :areUnitsAvailable.2:firstUnit @dead
  1155 jump *label362 equal *tmp487 0
  1156 label *label364

Modifications by Jumps phase, Single Step Elimination, pass 5, iteration 1 (-1 instructions):
 
  1123 jump *label372 equal @unit :areUnitsAvailable.2:firstUnit
  1124 sensor *tmp487 :areUnitsAvailable.2:firstUnit @dead
  1125 jump *label362 equal *tmp487 0
-    * jump *label372 always
  1126 label *label372
  1127 set *tmp466 false
  1128 label *label356

Modifications by Jumps phase, Unreachable Code Elimination, pass 6, iteration 1 (-6 instructions):
 
    81 jump *label37 lessThan :areUnitsAvailable:free *tmp21
    82 set *tmp10 true
    83 jump *label27 always
-    * jump *label37 always
    84 label *label36
    85 op add :areUnitsAvailable:occupied :areUnitsAvailable:occupied 1
    86 label *label37
 
   137 jump *label424 lessThan :areUnitsAvailable.1:free *tmp51
   138 set *tmp40 true
   139 jump *label433 always
-    * jump *label424 always
   140 label *label423
   141 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   142 label *label424
 
   195 jump *label450 lessThan :areUnitsAvailable.1:free *tmp51
   196 set *tmp40 true
   197 jump *label459 always
-    * jump *label450 always
   198 label *label449
   199 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   200 label *label450
 
   253 jump *label476 lessThan :areUnitsAvailable.1:free *tmp51
   254 set *tmp40 true
   255 jump *label485 always
-    * jump *label476 always
   256 label *label475
   257 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   258 label *label476
 
   311 jump *label502 lessThan :areUnitsAvailable.1:free *tmp51
   312 set *tmp40 true
   313 jump *label511 always
-    * jump *label502 always
   314 label *label501
   315 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   316 label *label502
 
  1110 jump *label366 lessThan :areUnitsAvailable.2:free *tmp477
  1111 set *tmp466 true
  1112 jump *label356 always
-    * jump *label366 always
  1113 label *label365
  1114 op add :areUnitsAvailable.2:occupied :areUnitsAvailable.2:occupied 1
  1115 label *label366

Modifications by Jumps phase, Jump Straightening, pass 6, iteration 1 (-1 instructions):
 
    33 setaddr :locateCore*retaddr *label406 (h:*label406)
    34 call *label0 *invalid :locateCore*retval (m:*label406) (h:*label406)
    35 label *label406
-    * jump *label1 notEqual :locateCore*retval false
-    * jump *label5 always
+   36 jump *label5 equal :locateCore*retval false
    37 label *label1
    38 sensor .CORE_X .CORE @x
    39 sensor .CORE_Y .CORE @y

Modifications by Final phase, Temp Variables Elimination, iteration 1:
 
  1134 sensor *tmp496 @unit @controller
  1135 jump *label377 notEqual *tmp496 @this
  1136 label *label379
-    * ulocate building core false @copper *tmp500 *tmp501 *tmp502 .CORE
+ 1137 ulocate building core false @copper 0 0 0 .CORE
  1138 label *label377
  1139 set :locateCore*retval .CORE
  1140 return :locateCore*retaddr

Modifications by Final phase, Print Merging, iteration 1 (-56 instructions):
 
    42 sensor *tmp7 switch1 @enabled
    43 jump *label20 notEqual *tmp7 false
    44 label *label413
-    * print "[coral]Activate switch to begin supplying overdrive dome..."
-    * print "\n"
+   45 print "[coral]Activate switch to begin supplying overdrive dome...\n"
    46 printflush message1
    47 sensor *tmp7 switch1 @enabled
    48 jump *label413 equal *tmp7 false
    49 label *label20
    50 label *label22
    51 printflush null
-    * print "[gold]Looking for suitable unit type:[]"
-    * print "\n"
+   52 print "[gold]Looking for suitable unit type:[]\n"
    53 set :areUnitsAvailable:free 0
    54 set :areUnitsAvailable:occupied 0
    55 set :areUnitsAvailable:needed 0
 
    88 label *label35
    89 label *label28
    90 print UNIT_TYPE
-    * print ":"
-    * print " occupied: "
+   91 print ": occupied: "
    92 print :areUnitsAvailable:occupied
-    * print ","
-    * print " free: "
+   93 print ", free: "
    94 print :areUnitsAvailable:free
    95 jump *label45 lessThanEq :areUnitsAvailable:needed 0
    96 print ", needed: "
 
   141 jump *label419 equal *tmp61 0
   142 label *label426
   143 label *label427
-    * print @flare
-    * print ":"
-    * print " occupied: "
+  144 print "flare: occupied: "
   145 print :areUnitsAvailable.1:occupied
-    * print ","
-    * print " free: "
+  146 print ", free: "
   147 print :areUnitsAvailable.1:free
   148 jump *label429 lessThanEq :areUnitsAvailable.1:needed 0
   149 print ", needed: "
 
   196 jump *label445 equal *tmp61 0
   197 label *label452
   198 label *label453
-    * print @poly
-    * print ":"
-    * print " occupied: "
+  199 print "poly: occupied: "
   200 print :areUnitsAvailable.1:occupied
-    * print ","
-    * print " free: "
+  201 print ", free: "
   202 print :areUnitsAvailable.1:free
   203 jump *label455 lessThanEq :areUnitsAvailable.1:needed 0
   204 print ", needed: "
 
   251 jump *label471 equal *tmp61 0
   252 label *label478
   253 label *label479
-    * print @mega
-    * print ":"
-    * print " occupied: "
+  254 print "mega: occupied: "
   255 print :areUnitsAvailable.1:occupied
-    * print ","
-    * print " free: "
+  256 print ", free: "
   257 print :areUnitsAvailable.1:free
   258 jump *label481 lessThanEq :areUnitsAvailable.1:needed 0
   259 print ", needed: "
 
   306 jump *label497 equal *tmp61 0
   307 label *label504
   308 label *label505
-    * print @mono
-    * print ":"
-    * print " occupied: "
+  309 print "mono: occupied: "
   310 print :areUnitsAvailable.1:occupied
-    * print ","
-    * print " free: "
+  311 print ", free: "
   312 print :areUnitsAvailable.1:free
   313 jump *label507 lessThanEq :areUnitsAvailable.1:needed 0
   314 print ", needed: "
 
   521 jump __start__ equal *tmp192 false
   522 label *label414
   523 set :start @time
-    * print " === [gold]Supplying Overdrive Dome[] === "
-    * print "\n"
-    * print "\n"
-    * print "Unit type: [green]"
+  524 print " === [gold]Supplying Overdrive Dome[] === \n\nUnit type: [green]"
   525 print *tmp9
-    * print "["
-    * print "]"
-    * print "\n"
-    * print "\n[green]Silicon[] status:\n"
+  526 print "[]\n\n[green]Silicon[] status:\n"
   527 sensor :printDomeStatus:level .DOME @silicon
   528 jump *label177 lessThanEq :printDomeStatus:level 3
   529 print "  dome:  [green]"
   530 print :printDomeStatus:level
-    * print "["
-    * print "]"
-    * print "\n"
+  531 print "[]\n"
   532 jump *label178 always
   533 label *label177
   534 print "  dome:  [coral]"
   535 print :printDomeStatus:level
-    * print "["
-    * print "]"
-    * print "\n"
+  536 print "[]\n"
   537 label *label178
   538 jump *label181 equal .UNIT_S1 null
   539 ubind .UNIT_S1
 
   636 sensor *tmp254 @unit @totalItems
   637 print "  "
   638 print .GROUP1
-    * print ":"
-    * print " ["
-    * print "gold"
-    * print "]"
+  639 print ": [gold]"
   640 print *tmp254
-    * print "["
-    * print "]"
+  641 print "[]"
   642 jump *label217 lessThan :processUnit:distance 0
   643 print .MSG
   644 print :processUnit:distance
-    * print "["
-    * print "] sec"
-    * print "\n"
+  645 print "[] sec\n"
   646 jump *label218 always
   647 label *label217
   648 print .MSG
 
   751 sensor *tmp318 @unit @totalItems
   752 print "  "
   753 print .GROUP2
-    * print ":"
-    * print " ["
-    * print "gold"
-    * print "]"
+  754 print ": [gold]"
   755 print *tmp318
-    * print "["
-    * print "]"
+  756 print "[]"
   757 jump *label259 lessThan :processUnit.1:distance 0
   758 print .MSG
   759 print :processUnit.1:distance
-    * print "["
-    * print "] sec"
-    * print "\n"
+  760 print "[] sec\n"
   761 jump *label260 always
   762 label *label259
   763 print .MSG
 
   778 jump *label264 lessThanEq :printDomeStatus.1:level 3
   779 print "  dome:  [green]"
   780 print :printDomeStatus.1:level
-    * print "["
-    * print "]"
-    * print "\n"
+  781 print "[]\n"
   782 jump *label265 always
   783 label *label264
   784 print "  dome:  [coral]"
   785 print :printDomeStatus.1:level
-    * print "["
-    * print "]"
-    * print "\n"
+  786 print "[]\n"
   787 label *label265
   788 jump *label268 equal .UNIT_P1 null
   789 ubind .UNIT_P1
 
   886 sensor *tmp388 @unit @totalItems
   887 print "  "
   888 print .GROUP1
-    * print ":"
-    * print " ["
-    * print "gold"
-    * print "]"
+  889 print ": [gold]"
   890 print *tmp388
-    * print "["
-    * print "]"
+  891 print "[]"
   892 jump *label304 lessThan :processUnit.2:distance 0
   893 print .MSG
   894 print :processUnit.2:distance
-    * print "["
-    * print "] sec"
-    * print "\n"
+  895 print "[] sec\n"
   896 jump *label305 always
   897 label *label304
   898 print .MSG
 
  1001 sensor *tmp452 @unit @totalItems
  1002 print "  "
  1003 print .GROUP2
-    * print ":"
-    * print " ["
-    * print "gold"
-    * print "]"
+ 1004 print ": [gold]"
  1005 print *tmp452
-    * print "["
-    * print "]"
+ 1006 print "[]"
  1007 jump *label346 lessThan :processUnit.3:distance 0
  1008 print .MSG
  1009 print :processUnit.3:distance
-    * print "["
-    * print "] sec"
-    * print "\n"
+ 1010 print "[] sec\n"
  1011 jump *label347 always
  1012 label *label346
  1013 print .MSG
 
  1025 label *label306
  1026 op sub *tmp461 @time :start
  1027 op floor *tmp462 *tmp461
-    * print "\n"
-    * print "[lightgray]Loop time: "
+ 1028 print "\n[lightgray]Loop time: "
  1029 print *tmp462
-    * print " "
-    * print "ms"
+ 1030 print " ms"
  1031 printflush message1
  1032 jump *label350 equal *tmp9 UNIT_TYPE
  1033 jump *label350 lessThanEq :unitCheck @time

Final code before resolving virtual instructions:

        label __start__
    0:  remark "This is the preferred unit type to use for bringing  /// This is the preferred unit type to use for bringing in supplies.
    2:  remark "If no units of this type exist, we'll try using othe /// If no units of this type exist, we'll try using other types.
    3:  set UNIT_TYPE @flare                                         param UNIT_TYPE         = @flare;  // Which unit to use
    4:  remark "Do not modify anything below this line."             /// Do not modify anything below this line.
    6:  set .DOME dome1                                              DOME = dome1;
    7:  jump *label4 notEqual dome1 null                             while DOME == null do
        label *label381                                              ...
    8:  print "[gold]Waiting for an overdrive dome to be connected.. print("[gold]Waiting for an overdrive dome to be connected...");
    9:  printflush message1                                          printflush(message1);
   10:  set .DOME dome1                                              DOME = dome1;
   11:  jump *label381 equal dome1 null                              while DOME == null do
        label *label4                                                ...
   12:  print "[gold]Locating core..."                               print("[gold]Locating core...");
   13:  printflush message1                                          printflush(message1);
   14:  set .CORE null                                               CORE = null;
        label *label5                                                while true do
   15:  set :locateCore:type @flare                                  if locateCore(type) then return; end;
   16:  setaddr :locateCore*retaddr *label385                        ...
   17:  call *label0 *invalid :locateCore*retval                     ...
        label *label385                                              ...
   18:  jump *label1 notEqual :locateCore*retval false               ...
   19:  set :locateCore:type @poly                                   ...
   20:  setaddr :locateCore*retaddr *label392                        ...
   21:  call *label0 *invalid :locateCore*retval                     ...
        label *label392                                              ...
   22:  jump *label1 notEqual :locateCore*retval false               ...
   23:  set :locateCore:type @mega                                   ...
   24:  setaddr :locateCore*retaddr *label399                        ...
   25:  call *label0 *invalid :locateCore*retval                     ...
        label *label399                                              ...
   26:  jump *label1 notEqual :locateCore*retval false               ...
   27:  set :locateCore:type @mono                                   ...
   28:  setaddr :locateCore*retaddr *label406                        ...
   29:  call *label0 *invalid :locateCore*retval                     ...
        label *label406                                              ...
   30:  jump *label5 equal :locateCore*retval false                  ...
        label *label1                                                locateDomeAndCore();
   31:  sensor .CORE_X .CORE @x                                      CORE_X = CORE.@x;
   32:  sensor .CORE_Y .CORE @y                                      CORE_Y = CORE.@y;
   33:  sensor .DOME_X .DOME @x                                      DOME_X = DOME.@x;
   34:  sensor .DOME_Y .DOME @y                                      DOME_Y = DOME.@y;
   35:  sensor *tmp7 switch1 @enabled                                while not switch1.@enabled do
   36:  jump *label20 notEqual *tmp7 false                           ...
        label *label413                                              ...
   37:  print "[coral]Activate switch to begin supplying overdrive d println("[coral]Activate switch to begin supplying overdrive dome...");
   38:  printflush message1                                          printflush(message1);
   39:  sensor *tmp7 switch1 @enabled                                while not switch1.@enabled do
   40:  jump *label413 equal *tmp7 false                             ...
        label *label20                                               ...
        label *label22                                               while true do
   41:  printflush null                                              printflush(null);       // empty text buffer
   42:  print "[gold]Looking for suitable unit type:[]\n"            println("[gold]Looking for suitable unit type:[]");
   43:  set :areUnitsAvailable:free 0                                var free = 0, occupied = 0, needed = 0;
   44:  set :areUnitsAvailable:occupied 0                            ...
   45:  set :areUnitsAvailable:needed 0                              ...
   46:  ubind UNIT_TYPE                                              var firstUnit = ubind(type);
   47:  set :areUnitsAvailable:firstUnit @unit                       ...
   48:  jump *label28 equal :areUnitsAvailable:firstUnit null        if firstUnit != null then
   49:  set *tmp21 2                                                 needed = needsFourUnits(@unit) ? 4 : 2;
   50:  set :needsFourUnits:unit @unit                               ...
   51:  op sub *tmp14 .DOME_X .CORE_X                                var travel_time = 2 * len(DOME_X - CORE_X, DOME_Y - CORE_Y) / unit.@speed;
   52:  op sub *tmp15 .DOME_Y .CORE_Y                                ...
   53:  op len *tmp16 *tmp14 *tmp15                                  ...
   54:  op mul *tmp17 2 *tmp16                                       ...
   55:  sensor *tmp18 :needsFourUnits:unit @speed                    ...
   56:  op div :needsFourUnits:travel_time *tmp17 *tmp18             ...
   57:  jump *label31 lessThan :needsFourUnits:travel_time 47        needed = needsFourUnits(@unit) ? 4 : 2;
   58:  set *tmp21 4                                                 ...
        label *label31                                               ...
   59:  set :areUnitsAvailable:needed *tmp21                         ...
        label *label33                                               do
   60:  sensor *tmp22 @unit @controlled                              if @unit.@controlled == 0 or @unit.@controller == @this then
   61:  jump *label38 equal *tmp22 0                                 ...
   62:  sensor *tmp24 @unit @controller                              ...
   63:  jump *label36 notEqual *tmp24 @this                          ...
        label *label38                                               ...
   64:  op add :areUnitsAvailable:free :areUnitsAvailable:free 1     if ++free >= needed then
   65:  jump *label37 lessThan :areUnitsAvailable:free *tmp21        ...
   66:  set *tmp10 true                                              return true;
   67:  jump *label27 always 0 0                                     ...
        label *label36                                               if @unit.@controlled == 0 or @unit.@controller == @this then
   68:  op add :areUnitsAvailable:occupied :areUnitsAvailable:occupi ...
        label *label37                                               ...
   69:  ubind UNIT_TYPE                                              ubind(type);
   70:  jump *label35 equal @unit :areUnitsAvailable:firstUnit       while @unit != firstUnit and firstUnit.@dead == 0;
   71:  sensor *tmp31 :areUnitsAvailable:firstUnit @dead             ...
   72:  jump *label33 equal *tmp31 0                                 ...
        label *label35                                               do
        label *label28                                               if firstUnit != null then
   73:  print UNIT_TYPE                                              print($"$type: occupied: $occupied, free: $free");
   74:  print ": occupied: "                                         ...
   75:  print :areUnitsAvailable:occupied                            ...
   76:  print ", free: "                                             ...
   77:  print :areUnitsAvailable:free                                ...
   78:  jump *label45 lessThanEq :areUnitsAvailable:needed 0         if needed > 0 then print($", needed: $needed"); end;
   79:  print ", needed: "                                           ...
   80:  print :areUnitsAvailable:needed                              ...
        label *label45                                               ...
   81:  print "\n"                                                   println();
   82:  set *tmp10 false                                             return false;
        label *label27                                               if areUnitsAvailable(UNIT_TYPE, true) then
   83:  jump *label25 equal *tmp10 false                             ...
   84:  set *tmp9 UNIT_TYPE                                          return UNIT_TYPE;
   85:  jump *label21 always 0 0                                     ...
        label *label25                                               if areUnitsAvailable(UNIT_TYPE, true) then
   86:  jump *label436 equal @flare UNIT_TYPE                        if type != UNIT_TYPE then
   87:  set :areUnitsAvailable.1:free 0                              var free = 0, occupied = 0, needed = 0;
   88:  set :areUnitsAvailable.1:occupied 0                          ...
   89:  set :areUnitsAvailable.1:needed 0                            ...
   90:  ubind @flare                                                 var firstUnit = ubind(type);
   91:  set :areUnitsAvailable.1:firstUnit @unit                     ...
   92:  jump *label427 equal :areUnitsAvailable.1:firstUnit null     if firstUnit != null then
   93:  set *tmp51 2                                                 needed = needsFourUnits(@unit) ? 4 : 2;
   94:  set :needsFourUnits.1:unit @unit                             ...
   95:  op sub *tmp44 .DOME_X .CORE_X                                var travel_time = 2 * len(DOME_X - CORE_X, DOME_Y - CORE_Y) / unit.@speed;
   96:  op sub *tmp45 .DOME_Y .CORE_Y                                ...
   97:  op len *tmp46 *tmp44 *tmp45                                  ...
   98:  op mul *tmp47 2 *tmp46                                       ...
   99:  sensor *tmp48 :needsFourUnits.1:unit @speed                  ...
  100:  op div :needsFourUnits.1:travel_time *tmp47 *tmp48           ...
  101:  jump *label418 lessThan :needsFourUnits.1:travel_time 47     needed = needsFourUnits(@unit) ? 4 : 2;
  102:  set *tmp51 4                                                 ...
        label *label418                                              ...
  103:  set :areUnitsAvailable.1:needed *tmp51                       ...
        label *label419                                              do
  104:  sensor *tmp52 @unit @controlled                              if @unit.@controlled == 0 or @unit.@controller == @this then
  105:  jump *label420 equal *tmp52 0                                ...
  106:  sensor *tmp54 @unit @controller                              ...
  107:  jump *label423 notEqual *tmp54 @this                         ...
        label *label420                                              ...
  108:  op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1 if ++free >= needed then
  109:  jump *label424 lessThan :areUnitsAvailable.1:free *tmp51     ...
  110:  set *tmp40 true                                              return true;
  111:  jump *label433 always 0 0                                    ...
        label *label423                                              if @unit.@controlled == 0 or @unit.@controller == @this then
  112:  op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:oc ...
        label *label424                                              ...
  113:  ubind @flare                                                 ubind(type);
  114:  jump *label426 equal @unit :areUnitsAvailable.1:firstUnit    while @unit != firstUnit and firstUnit.@dead == 0;
  115:  sensor *tmp61 :areUnitsAvailable.1:firstUnit @dead           ...
  116:  jump *label419 equal *tmp61 0                                ...
        label *label426                                              do
        label *label427                                              if firstUnit != null then
  117:  print "flare: occupied: "                                    print($"$type: occupied: $occupied, free: $free");
  118:  print :areUnitsAvailable.1:occupied                          ...
  119:  print ", free: "                                             ...
  120:  print :areUnitsAvailable.1:free                              ...
  121:  jump *label429 lessThanEq :areUnitsAvailable.1:needed 0      if needed > 0 then print($", needed: $needed"); end;
  122:  print ", needed: "                                           ...
  123:  print :areUnitsAvailable.1:needed                            ...
        label *label429                                              ...
  124:  print "\n"                                                   println();
  125:  set *tmp40 false                                             return false;
        label *label433                                              if areUnitsAvailable(type, true) then
  126:  jump *label434 equal *tmp40 false                            ...
  127:  printflush null                                              printflush(null);
  128:  set *tmp9 @flare                                             return type;
  129:  jump *label21 always 0 0                                     ...
        label *label434                                              if areUnitsAvailable(type, true) then
        label *label436                                              if type != UNIT_TYPE then
  130:  jump *label462 equal @poly UNIT_TYPE                         ...
  131:  set :areUnitsAvailable.1:free 0                              var free = 0, occupied = 0, needed = 0;
  132:  set :areUnitsAvailable.1:occupied 0                          ...
  133:  set :areUnitsAvailable.1:needed 0                            ...
  134:  ubind @poly                                                  var firstUnit = ubind(type);
  135:  set :areUnitsAvailable.1:firstUnit @unit                     ...
  136:  jump *label453 equal :areUnitsAvailable.1:firstUnit null     if firstUnit != null then
  137:  set *tmp51 2                                                 needed = needsFourUnits(@unit) ? 4 : 2;
  138:  set :needsFourUnits.1:unit @unit                             ...
  139:  op sub *tmp44 .DOME_X .CORE_X                                var travel_time = 2 * len(DOME_X - CORE_X, DOME_Y - CORE_Y) / unit.@speed;
  140:  op sub *tmp45 .DOME_Y .CORE_Y                                ...
  141:  op len *tmp46 *tmp44 *tmp45                                  ...
  142:  op mul *tmp47 2 *tmp46                                       ...
  143:  sensor *tmp48 :needsFourUnits.1:unit @speed                  ...
  144:  op div :needsFourUnits.1:travel_time *tmp47 *tmp48           ...
  145:  jump *label444 lessThan :needsFourUnits.1:travel_time 47     needed = needsFourUnits(@unit) ? 4 : 2;
  146:  set *tmp51 4                                                 ...
        label *label444                                              ...
  147:  set :areUnitsAvailable.1:needed *tmp51                       ...
        label *label445                                              do
  148:  sensor *tmp52 @unit @controlled                              if @unit.@controlled == 0 or @unit.@controller == @this then
  149:  jump *label446 equal *tmp52 0                                ...
  150:  sensor *tmp54 @unit @controller                              ...
  151:  jump *label449 notEqual *tmp54 @this                         ...
        label *label446                                              ...
  152:  op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1 if ++free >= needed then
  153:  jump *label450 lessThan :areUnitsAvailable.1:free *tmp51     ...
  154:  set *tmp40 true                                              return true;
  155:  jump *label459 always 0 0                                    ...
        label *label449                                              if @unit.@controlled == 0 or @unit.@controller == @this then
  156:  op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:oc ...
        label *label450                                              ...
  157:  ubind @poly                                                  ubind(type);
  158:  jump *label452 equal @unit :areUnitsAvailable.1:firstUnit    while @unit != firstUnit and firstUnit.@dead == 0;
  159:  sensor *tmp61 :areUnitsAvailable.1:firstUnit @dead           ...
  160:  jump *label445 equal *tmp61 0                                ...
        label *label452                                              do
        label *label453                                              if firstUnit != null then
  161:  print "poly: occupied: "                                     print($"$type: occupied: $occupied, free: $free");
  162:  print :areUnitsAvailable.1:occupied                          ...
  163:  print ", free: "                                             ...
  164:  print :areUnitsAvailable.1:free                              ...
  165:  jump *label455 lessThanEq :areUnitsAvailable.1:needed 0      if needed > 0 then print($", needed: $needed"); end;
  166:  print ", needed: "                                           ...
  167:  print :areUnitsAvailable.1:needed                            ...
        label *label455                                              ...
  168:  print "\n"                                                   println();
  169:  set *tmp40 false                                             return false;
        label *label459                                              if areUnitsAvailable(type, true) then
  170:  jump *label460 equal *tmp40 false                            ...
  171:  printflush null                                              printflush(null);
  172:  set *tmp9 @poly                                              return type;
  173:  jump *label21 always 0 0                                     ...
        label *label460                                              if areUnitsAvailable(type, true) then
        label *label462                                              if type != UNIT_TYPE then
  174:  jump *label488 equal @mega UNIT_TYPE                         ...
  175:  set :areUnitsAvailable.1:free 0                              var free = 0, occupied = 0, needed = 0;
  176:  set :areUnitsAvailable.1:occupied 0                          ...
  177:  set :areUnitsAvailable.1:needed 0                            ...
  178:  ubind @mega                                                  var firstUnit = ubind(type);
  179:  set :areUnitsAvailable.1:firstUnit @unit                     ...
  180:  jump *label479 equal :areUnitsAvailable.1:firstUnit null     if firstUnit != null then
  181:  set *tmp51 2                                                 needed = needsFourUnits(@unit) ? 4 : 2;
  182:  set :needsFourUnits.1:unit @unit                             ...
  183:  op sub *tmp44 .DOME_X .CORE_X                                var travel_time = 2 * len(DOME_X - CORE_X, DOME_Y - CORE_Y) / unit.@speed;
  184:  op sub *tmp45 .DOME_Y .CORE_Y                                ...
  185:  op len *tmp46 *tmp44 *tmp45                                  ...
  186:  op mul *tmp47 2 *tmp46                                       ...
  187:  sensor *tmp48 :needsFourUnits.1:unit @speed                  ...
  188:  op div :needsFourUnits.1:travel_time *tmp47 *tmp48           ...
  189:  jump *label470 lessThan :needsFourUnits.1:travel_time 47     needed = needsFourUnits(@unit) ? 4 : 2;
  190:  set *tmp51 4                                                 ...
        label *label470                                              ...
  191:  set :areUnitsAvailable.1:needed *tmp51                       ...
        label *label471                                              do
  192:  sensor *tmp52 @unit @controlled                              if @unit.@controlled == 0 or @unit.@controller == @this then
  193:  jump *label472 equal *tmp52 0                                ...
  194:  sensor *tmp54 @unit @controller                              ...
  195:  jump *label475 notEqual *tmp54 @this                         ...
        label *label472                                              ...
  196:  op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1 if ++free >= needed then
  197:  jump *label476 lessThan :areUnitsAvailable.1:free *tmp51     ...
  198:  set *tmp40 true                                              return true;
  199:  jump *label485 always 0 0                                    ...
        label *label475                                              if @unit.@controlled == 0 or @unit.@controller == @this then
  200:  op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:oc ...
        label *label476                                              ...
  201:  ubind @mega                                                  ubind(type);
  202:  jump *label478 equal @unit :areUnitsAvailable.1:firstUnit    while @unit != firstUnit and firstUnit.@dead == 0;
  203:  sensor *tmp61 :areUnitsAvailable.1:firstUnit @dead           ...
  204:  jump *label471 equal *tmp61 0                                ...
        label *label478                                              do
        label *label479                                              if firstUnit != null then
  205:  print "mega: occupied: "                                     print($"$type: occupied: $occupied, free: $free");
  206:  print :areUnitsAvailable.1:occupied                          ...
  207:  print ", free: "                                             ...
  208:  print :areUnitsAvailable.1:free                              ...
  209:  jump *label481 lessThanEq :areUnitsAvailable.1:needed 0      if needed > 0 then print($", needed: $needed"); end;
  210:  print ", needed: "                                           ...
  211:  print :areUnitsAvailable.1:needed                            ...
        label *label481                                              ...
  212:  print "\n"                                                   println();
  213:  set *tmp40 false                                             return false;
        label *label485                                              if areUnitsAvailable(type, true) then
  214:  jump *label486 equal *tmp40 false                            ...
  215:  printflush null                                              printflush(null);
  216:  set *tmp9 @mega                                              return type;
  217:  jump *label21 always 0 0                                     ...
        label *label486                                              if areUnitsAvailable(type, true) then
        label *label488                                              if type != UNIT_TYPE then
  218:  jump *label514 equal @mono UNIT_TYPE                         ...
  219:  set :areUnitsAvailable.1:free 0                              var free = 0, occupied = 0, needed = 0;
  220:  set :areUnitsAvailable.1:occupied 0                          ...
  221:  set :areUnitsAvailable.1:needed 0                            ...
  222:  ubind @mono                                                  var firstUnit = ubind(type);
  223:  set :areUnitsAvailable.1:firstUnit @unit                     ...
  224:  jump *label505 equal :areUnitsAvailable.1:firstUnit null     if firstUnit != null then
  225:  set *tmp51 2                                                 needed = needsFourUnits(@unit) ? 4 : 2;
  226:  set :needsFourUnits.1:unit @unit                             ...
  227:  op sub *tmp44 .DOME_X .CORE_X                                var travel_time = 2 * len(DOME_X - CORE_X, DOME_Y - CORE_Y) / unit.@speed;
  228:  op sub *tmp45 .DOME_Y .CORE_Y                                ...
  229:  op len *tmp46 *tmp44 *tmp45                                  ...
  230:  op mul *tmp47 2 *tmp46                                       ...
  231:  sensor *tmp48 :needsFourUnits.1:unit @speed                  ...
  232:  op div :needsFourUnits.1:travel_time *tmp47 *tmp48           ...
  233:  jump *label496 lessThan :needsFourUnits.1:travel_time 47     needed = needsFourUnits(@unit) ? 4 : 2;
  234:  set *tmp51 4                                                 ...
        label *label496                                              ...
  235:  set :areUnitsAvailable.1:needed *tmp51                       ...
        label *label497                                              do
  236:  sensor *tmp52 @unit @controlled                              if @unit.@controlled == 0 or @unit.@controller == @this then
  237:  jump *label498 equal *tmp52 0                                ...
  238:  sensor *tmp54 @unit @controller                              ...
  239:  jump *label501 notEqual *tmp54 @this                         ...
        label *label498                                              ...
  240:  op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1 if ++free >= needed then
  241:  jump *label502 lessThan :areUnitsAvailable.1:free *tmp51     ...
  242:  set *tmp40 true                                              return true;
  243:  jump *label511 always 0 0                                    ...
        label *label501                                              if @unit.@controlled == 0 or @unit.@controller == @this then
  244:  op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:oc ...
        label *label502                                              ...
  245:  ubind @mono                                                  ubind(type);
  246:  jump *label504 equal @unit :areUnitsAvailable.1:firstUnit    while @unit != firstUnit and firstUnit.@dead == 0;
  247:  sensor *tmp61 :areUnitsAvailable.1:firstUnit @dead           ...
  248:  jump *label497 equal *tmp61 0                                ...
        label *label504                                              do
        label *label505                                              if firstUnit != null then
  249:  print "mono: occupied: "                                     print($"$type: occupied: $occupied, free: $free");
  250:  print :areUnitsAvailable.1:occupied                          ...
  251:  print ", free: "                                             ...
  252:  print :areUnitsAvailable.1:free                              ...
  253:  jump *label507 lessThanEq :areUnitsAvailable.1:needed 0      if needed > 0 then print($", needed: $needed"); end;
  254:  print ", needed: "                                           ...
  255:  print :areUnitsAvailable.1:needed                            ...
        label *label507                                              ...
  256:  print "\n"                                                   println();
  257:  set *tmp40 false                                             return false;
        label *label511                                              if areUnitsAvailable(type, true) then
  258:  jump *label512 equal *tmp40 false                            ...
  259:  printflush null                                              printflush(null);
  260:  set *tmp9 @mono                                              return type;
  261:  jump *label21 always 0 0                                     ...
        label *label512                                              if areUnitsAvailable(type, true) then
        label *label514                                              if type != UNIT_TYPE then
  262:  printflush message1                                          printflush(message1);
  263:  jump *label22 always 0 0                                     while true do
        label *label21                                               TYPE = chooseUnitType();
  264:  print "[gold]Binding units..."                               print("[gold]Binding units...");
  265:  printflush message1                                          printflush(message1);
  266:  set .UNIT_P2 null                                            UNIT_S1 = UNIT_P1 = UNIT_S2 = UNIT_P2 = null;
  267:  set .UNIT_S2 null                                            ...
  268:  set .UNIT_P1 null                                            ...
  269:  set .UNIT_S1 null                                            ...
  270:  set :rebindUnits:count 0                                     var count = 0;
  271:  ubind *tmp9                                                  var firstUnit = ubind(TYPE);
  272:  set :rebindUnits:firstUnit @unit                             ...
  273:  jump *label79 notEqual :rebindUnits:firstUnit null           if firstUnit == null then
  274:  end                                                          end();
        label *label79                                               if firstUnit == null then
        label *label81                                               do
  275:  sensor *tmp70 @unit @controller                              if @unit.@controller == @this then
  276:  jump *label84 notEqual *tmp70 @this                          ...
  277:  op add :rebindUnits:count :rebindUnits:count 1               ...
  278:  ucontrol flag 1 0 0 0 0                                      flag(S_INIT);
  279:  set .UNIT_S2 .UNIT_P2                                        UNIT_S2 = UNIT_P2;
  280:  set .UNIT_P2 .UNIT_S1                                        UNIT_P2 = UNIT_S1;
  281:  set .UNIT_S1 .UNIT_P1                                        UNIT_S1 = UNIT_P1;
  282:  set .UNIT_P1 @unit                                           UNIT_P1 = @unit;
  283:  jump *label83 notEqual .UNIT_S2 null                         if UNIT_S2 != null then
        label *label84                                               if @unit.@controller == @this then
  284:  ubind *tmp9                                                  ubind(TYPE);
  285:  jump *label83 equal @unit :rebindUnits:firstUnit             while @unit != firstUnit and firstUnit.@dead == 0;
  286:  sensor *tmp78 :rebindUnits:firstUnit @dead                   ...
  287:  jump *label81 equal *tmp78 0                                 ...
        label *label83                                               do
  288:  jump *label91 equal .UNIT_S1 null                            if currentUnit != null then
  289:  ubind .UNIT_S1                                               ubind(currentUnit);
  290:  sensor *tmp84 @unit @dead                                    if @unit.@dead == 0 && @unit.@controller == @this then
  291:  op equal *tmp85 *tmp84 0                                     ...
  292:  sensor *tmp86 @unit @controller                              ...
  293:  op equal *tmp87 *tmp86 @this                                 ...
  294:  op land *tmp88 *tmp85 *tmp87                                 ...
  295:  jump *label90 notEqual *tmp88 false                          ...
        label *label91                                               if currentUnit != null then
  296:  ubind *tmp9                                                  var firstUnit = ubind(TYPE);
  297:  set :rebindUnit:firstUnit @unit                              ...
  298:  jump __start__ equal :rebindUnit:firstUnit null              if firstUnit != null then
        label *label97                                               do
  299:  sensor *tmp92 @unit @controlled                              if @unit.@controlled == 0 then
  300:  jump *label90 equal *tmp92 0                                 ...
  301:  ubind *tmp9                                                  ubind(TYPE);
  302:  jump __start__ equal @unit :rebindUnit:firstUnit             while @unit != firstUnit and firstUnit.@dead == 0;
  303:  sensor *tmp96 :rebindUnit:firstUnit @dead                    ...
  304:  jump *label97 equal *tmp96 0                                 ...
  305:  end                                                          end();
        label *label90                                               rebindUnit(currentUnit);
  306:  ucontrol flag 1 0 0 0 0                                      flag(S_INIT);
  307:  set *tmp80 @unit                                             return @unit;
  308:  set .UNIT_S1 *tmp80                                          UNIT_S1 = acquireUnit(UNIT_S1);
  309:  jump *label105 equal .UNIT_P1 null                           if currentUnit != null then
  310:  ubind .UNIT_P1                                               ubind(currentUnit);
  311:  sensor *tmp102 @unit @dead                                   if @unit.@dead == 0 && @unit.@controller == @this then
  312:  op equal *tmp103 *tmp102 0                                   ...
  313:  sensor *tmp104 @unit @controller                             ...
  314:  op equal *tmp105 *tmp104 @this                               ...
  315:  op land *tmp106 *tmp103 *tmp105                              ...
  316:  jump *label104 notEqual *tmp106 false                        ...
        label *label105                                              if currentUnit != null then
  317:  ubind *tmp9                                                  var firstUnit = ubind(TYPE);
  318:  set :rebindUnit.1:firstUnit @unit                            ...
  319:  jump __start__ equal :rebindUnit.1:firstUnit null            if firstUnit != null then
        label *label111                                              do
  320:  sensor *tmp110 @unit @controlled                             if @unit.@controlled == 0 then
  321:  jump *label104 equal *tmp110 0                               ...
  322:  ubind *tmp9                                                  ubind(TYPE);
  323:  jump __start__ equal @unit :rebindUnit.1:firstUnit           while @unit != firstUnit and firstUnit.@dead == 0;
  324:  sensor *tmp114 :rebindUnit.1:firstUnit @dead                 ...
  325:  jump *label111 equal *tmp114 0                               ...
  326:  end                                                          end();
        label *label104                                              rebindUnit(currentUnit);
  327:  ucontrol flag 1 0 0 0 0                                      flag(S_INIT);
  328:  set *tmp98 @unit                                             return @unit;
  329:  set .UNIT_P1 *tmp98                                          UNIT_P1 = acquireUnit(UNIT_P1);
  330:  sensor *tmp116 *tmp80 @firstItem                             if UNIT_S1.@firstItem == @phase-fabric or UNIT_P1.@firstItem == @silicon then
  331:  jump *label119 equal *tmp116 @phase-fabric                   ...
  332:  sensor *tmp118 *tmp98 @firstItem                             ...
  333:  jump *label117 notEqual *tmp118 @silicon                     ...
        label *label119                                              ...
  334:  set .UNIT_S1 *tmp98                                          swap(out UNIT_S1, out UNIT_P1);
  335:  set .UNIT_P1 *tmp80                                          ...
        label *label117                                              if UNIT_S1.@firstItem == @phase-fabric or UNIT_P1.@firstItem == @silicon then
  336:  sensor .UNIT_CAPACITY .UNIT_S1 @itemCapacity                 UNIT_CAPACITY = UNIT_S1.@itemCapacity;
  337:  sensor .SPEED .UNIT_S1 @speed                                SPEED = UNIT_S1.@speed;
  338:  op div .SPEED_TENTHS .SPEED 10                               SPEED_TENTHS = SPEED / 10;
  339:  op strictEqual *tmp124 .SPEED null                           if SPEED === null then
  340:  jump *label122 equal *tmp124 false                           ...
  341:  stop                                                         stopProcessor();
        label *label122                                              if SPEED === null then
  342:  op sub *tmp127 .DOME_X .CORE_X                               var travel_time = 2 * len(DOME_X - CORE_X, DOME_Y - CORE_Y) / unit.@speed;
  343:  op sub *tmp128 .DOME_Y .CORE_Y                               ...
  344:  op len *tmp129 *tmp127 *tmp128                               ...
  345:  op mul *tmp130 2 *tmp129                                     ...
  346:  op div :needsFourUnits.2:travel_time *tmp130 .SPEED          ...
  347:  op greaterThanEq *tmp126 :needsFourUnits.2:travel_time 47    return travel_time >= SUPPLY_INTERVAL;
  348:  jump *label125 lessThan :needsFourUnits.2:travel_time 47     if FOUR_UNITS then
  349:  jump *label129 equal .UNIT_S2 null                           if currentUnit != null then
  350:  ubind .UNIT_S2                                               ubind(currentUnit);
  351:  sensor *tmp139 @unit @dead                                   if @unit.@dead == 0 && @unit.@controller == @this then
  352:  op equal *tmp140 *tmp139 0                                   ...
  353:  sensor *tmp141 @unit @controller                             ...
  354:  op equal *tmp142 *tmp141 @this                               ...
  355:  op land *tmp143 *tmp140 *tmp142                              ...
  356:  jump *label128 notEqual *tmp143 false                        ...
        label *label129                                              if currentUnit != null then
  357:  ubind *tmp9                                                  var firstUnit = ubind(TYPE);
  358:  set :rebindUnit.2:firstUnit @unit                            ...
  359:  jump __start__ equal :rebindUnit.2:firstUnit null            if firstUnit != null then
        label *label135                                              do
  360:  sensor *tmp147 @unit @controlled                             if @unit.@controlled == 0 then
  361:  jump *label128 equal *tmp147 0                               ...
  362:  ubind *tmp9                                                  ubind(TYPE);
  363:  jump __start__ equal @unit :rebindUnit.2:firstUnit           while @unit != firstUnit and firstUnit.@dead == 0;
  364:  sensor *tmp151 :rebindUnit.2:firstUnit @dead                 ...
  365:  jump *label135 equal *tmp151 0                               ...
  366:  end                                                          end();
        label *label128                                              rebindUnit(currentUnit);
  367:  ucontrol flag 1 0 0 0 0                                      flag(S_INIT);
  368:  set *tmp135 @unit                                            return @unit;
  369:  set .UNIT_S2 *tmp135                                         UNIT_S2 = acquireUnit(UNIT_S2);
  370:  jump *label143 equal .UNIT_P2 null                           if currentUnit != null then
  371:  ubind .UNIT_P2                                               ubind(currentUnit);
  372:  sensor *tmp157 @unit @dead                                   if @unit.@dead == 0 && @unit.@controller == @this then
  373:  op equal *tmp158 *tmp157 0                                   ...
  374:  sensor *tmp159 @unit @controller                             ...
  375:  op equal *tmp160 *tmp159 @this                               ...
  376:  op land *tmp161 *tmp158 *tmp160                              ...
  377:  jump *label142 notEqual *tmp161 false                        ...
        label *label143                                              if currentUnit != null then
  378:  ubind *tmp9                                                  var firstUnit = ubind(TYPE);
  379:  set :rebindUnit.3:firstUnit @unit                            ...
  380:  jump __start__ equal :rebindUnit.3:firstUnit null            if firstUnit != null then
        label *label149                                              do
  381:  sensor *tmp165 @unit @controlled                             if @unit.@controlled == 0 then
  382:  jump *label142 equal *tmp165 0                               ...
  383:  ubind *tmp9                                                  ubind(TYPE);
  384:  jump __start__ equal @unit :rebindUnit.3:firstUnit           while @unit != firstUnit and firstUnit.@dead == 0;
  385:  sensor *tmp169 :rebindUnit.3:firstUnit @dead                 ...
  386:  jump *label149 equal *tmp169 0                               ...
  387:  end                                                          end();
        label *label142                                              rebindUnit(currentUnit);
  388:  ucontrol flag 1 0 0 0 0                                      flag(S_INIT);
  389:  set *tmp153 @unit                                            return @unit;
  390:  set .UNIT_P2 *tmp153                                         UNIT_P2 = acquireUnit(UNIT_P2);
  391:  sensor *tmp171 .UNIT_S1 @firstItem                           if UNIT_S1.@firstItem == @phase-fabric and UNIT_P2.@firstItem != @phase-fabric then
  392:  jump *label155 notEqual *tmp171 @phase-fabric                ...
  393:  sensor *tmp173 *tmp153 @firstItem                            ...
  394:  jump *label155 equal *tmp173 @phase-fabric                   ...
  395:  set :swap.1:t .UNIT_S1                                       var t = a; a = b; b = t;
  396:  set .UNIT_S1 *tmp153                                         swap(out UNIT_S1, out UNIT_P2);
  397:  set .UNIT_P2 :swap.1:t                                       ...
        label *label155                                              if UNIT_S1.@firstItem == @phase-fabric and UNIT_P2.@firstItem != @phase-fabric then
  398:  sensor *tmp176 *tmp135 @firstItem                            if UNIT_S2.@firstItem == @phase-fabric or UNIT_P2.@firstItem == @silicon then
  399:  jump *label162 equal *tmp176 @phase-fabric                   ...
  400:  sensor *tmp178 .UNIT_P2 @firstItem                           ...
  401:  jump *label160 notEqual *tmp178 @silicon                     ...
        label *label162                                              ...
  402:  set .UNIT_S2 .UNIT_P2                                        swap(out UNIT_S2, out UNIT_P2);
  403:  set .UNIT_P2 *tmp135                                         ...
        label *label160                                              if UNIT_S2.@firstItem == @phase-fabric or UNIT_P2.@firstItem == @silicon then
  404:  set .GROUP1 "unit  1"                                        GROUP1 = "unit  1";
  405:  set .GROUP2 "unit 2"                                         GROUP2 = "unit 2";
  406:  jump *label126 always 0 0                                    if FOUR_UNITS then
        label *label125                                              ...
  407:  ubind .UNIT_S2                                               ubind(UNIT_S2); unbind(); UNIT_S2 = null;
  408:  ucontrol unbind 0 0 0 0 0                                    ...
  409:  set .UNIT_S2 null                                            ...
  410:  ubind .UNIT_P2                                               ubind(UNIT_P2); unbind(); UNIT_P2 = null;
  411:  ucontrol unbind 0 0 0 0 0                                    ...
  412:  set .UNIT_P2 null                                            ...
  413:  set .GROUP1 "unit"                                           GROUP1 = "unit";
        label *label126                                              if FOUR_UNITS then
  414:  jump *label165 notEqual *tmp126 false                        SUPPLY_S_FIRST = not FOUR_UNITS or UNIT_S1.@totalItems < UNIT_S2.@totalItems;
  415:  set .SUPPLY_S_FIRST true                                     ...
  416:  jump *label166 always 0 0                                    ...
        label *label165                                              ...
  417:  sensor *tmp182 .UNIT_S1 @totalItems                          ...
  418:  sensor *tmp183 .UNIT_S2 @totalItems                          ...
  419:  op lessThan .SUPPLY_S_FIRST *tmp182 *tmp183                  ...
        label *label166                                              ...
  420:  jump *label169 notEqual *tmp126 false                        SUPPLY_P_FIRST = not FOUR_UNITS or UNIT_P1.@totalItems < UNIT_P2.@totalItems;
  421:  set .SUPPLY_P_FIRST true                                     ...
  422:  jump *label170 always 0 0                                    ...
        label *label169                                              ...
  423:  sensor *tmp187 .UNIT_P1 @totalItems                          ...
  424:  sensor *tmp188 .UNIT_P2 @totalItems                          ...
  425:  op lessThan .SUPPLY_P_FIRST *tmp187 *tmp188                  ...
        label *label170                                              ...
  426:  op add :unitCheck @time 5000                                 var unitCheck = @time + UNIT_CHECK_TIME;
  427:  sensor *tmp192 switch1 @enabled                              while switch1.@enabled do
  428:  jump __start__ equal *tmp192 false                           ...
        label *label414                                              ...
  429:  set :start @time                                             var start = @time;
  430:  print " === [gold]Supplying Overdrive Dome[] === \n\nUnit ty println($"Unit type: [green]$TYPE[]");
  431:  print *tmp9                                                  ...
  432:  print "[]\n\n[green]Silicon[] status:\n"                     print(text);
  433:  sensor :printDomeStatus:level .DOME @silicon                 var level = DOME.sensor(item);
  434:  jump *label177 lessThanEq :printDomeStatus:level 3           if level > 3 then
  435:  print "  dome:  [green]"                                     println($"  dome:  [green]$level[]");
  436:  print :printDomeStatus:level                                 ...
  437:  print "[]\n"                                                 ...
  438:  jump *label178 always 0 0                                    if level > 3 then
        label *label177                                              ...
  439:  print "  dome:  [coral]"                                     println($"  dome:  [coral]$level[]");
  440:  print :printDomeStatus:level                                 ...
  441:  print "[]\n"                                                 ...
        label *label178                                              if level > 3 then
  442:  jump *label181 equal .UNIT_S1 null                           if currentUnit != null then
  443:  ubind .UNIT_S1                                               ubind(currentUnit);
  444:  sensor *tmp199 @unit @dead                                   if @unit.@dead == 0 && @unit.@controller == @this then
  445:  op equal *tmp200 *tmp199 0                                   ...
  446:  sensor *tmp201 @unit @controller                             ...
  447:  op equal *tmp202 *tmp201 @this                               ...
  448:  op land *tmp203 *tmp200 *tmp202                              ...
  449:  jump *label180 notEqual *tmp203 false                        ...
        label *label181                                              if currentUnit != null then
  450:  ubind *tmp9                                                  var firstUnit = ubind(TYPE);
  451:  set :rebindUnit.4:firstUnit @unit                            ...
  452:  jump __start__ equal :rebindUnit.4:firstUnit null            if firstUnit != null then
        label *label187                                              do
  453:  sensor *tmp207 @unit @controlled                             if @unit.@controlled == 0 then
  454:  jump *label180 equal *tmp207 0                               ...
  455:  ubind *tmp9                                                  ubind(TYPE);
  456:  jump __start__ equal @unit :rebindUnit.4:firstUnit           while @unit != firstUnit and firstUnit.@dead == 0;
  457:  sensor *tmp211 :rebindUnit.4:firstUnit @dead                 ...
  458:  jump *label187 equal *tmp211 0                               ...
  459:  end                                                          end();
        label *label180                                              rebindUnit(unit);
  460:  sensor :processUnit:state @unit @flag                        var state = @unit.@flag;
  461:  set :processUnit:distance -1                                 var distance = -1;
  462:  jump *label195 lessThan :processUnit:state 2                 if state < S_APPROACH_SRC or state > S_APPROACH_DST then
  463:  jump *label193 lessThanEq :processUnit:state 3               ...
        label *label195                                              ...
  464:  sensor *tmp217 @unit @firstItem                              if @unit.@firstItem == item then
  465:  jump *label197 notEqual *tmp217 @silicon                     ...
  466:  set :processUnit:state 3                                     state = S_APPROACH_DST;
  467:  jump *label198 always 0 0                                    if @unit.@firstItem == item then
        label *label197                                              ...
  468:  sensor *tmp220 @unit @totalItems                             elsif @unit.@totalItems == 0 then
  469:  jump *label199 notEqual *tmp220 0                            ...
  470:  set :processUnit:state 2                                     state = S_APPROACH_SRC;
  471:  jump *label200 always 0 0                                    elsif @unit.@totalItems == 0 then
        label *label199                                              ...
  472:  set .MSG ", initializing\n"                                  MSG = ", initializing\n";
  473:  ucontrol approach .CORE_X .CORE_Y 6 0 0                      approach(CORE_X, CORE_Y, RADIUS_APPROACH);
  474:  ucontrol within .CORE_X .CORE_Y 8 *tmp223 0                  if within(CORE_X, CORE_Y, RADIUS_WITHIN) then
  475:  jump *label201 equal *tmp223 false                           ...
  476:  ucontrol itemDrop .CORE .UNIT_CAPACITY 0 0 0                 itemDrop(CORE, UNIT_CAPACITY);
        label *label201                                              if within(CORE_X, CORE_Y, RADIUS_WITHIN) then
        label *label200                                              elsif @unit.@totalItems == 0 then
        label *label198                                              if @unit.@firstItem == item then
        label *label193                                              if state < S_APPROACH_SRC or state > S_APPROACH_DST then
  477:  jump *label203 notEqual :processUnit:state 2                 if state == S_APPROACH_SRC then
  478:  ucontrol within .CORE_X .CORE_Y 8 *tmp227 0                  if within(CORE_X, CORE_Y, RADIUS_WITHIN) then
  479:  jump *label205 equal *tmp227 false                           ...
  480:  ucontrol itemTake .CORE @silicon .UNIT_CAPACITY 0 0          itemTake(CORE, item, UNIT_CAPACITY);
  481:  sensor *tmp229 @unit @totalItems                             if @unit.@totalItems >= UNIT_CAPACITY then
  482:  jump *label207 lessThan *tmp229 .UNIT_CAPACITY               ...
  483:  ucontrol approach .DOME_X .DOME_Y 6 0 0                      approach(DOME_X, DOME_Y, RADIUS_APPROACH);
  484:  set :processUnit:state 3                                     state = S_APPROACH_DST;
  485:  jump *label206 always 0 0                                    if @unit.@totalItems >= UNIT_CAPACITY then
        label *label207                                              ...
  486:  set .MSG ", loading\n"                                       MSG = ", loading\n";
  487:  jump *label206 always 0 0                                    if within(CORE_X, CORE_Y, RADIUS_WITHIN) then
        label *label205                                              ...
  488:  ucontrol approach .CORE_X .CORE_Y 6 0 0                      approach(CORE_X, CORE_Y, RADIUS_APPROACH);
  489:  set .MSG ", fetching in [gold]"                              MSG = ", fetching in [gold]";
  490:  sensor *tmp232 @unit @x                                      distance = len(CORE_X - @unit.@x, CORE_Y - @unit.@y) \ SPEED_TENTHS / 10;
  491:  op sub *tmp233 .CORE_X *tmp232                               ...
  492:  sensor *tmp234 @unit @y                                      ...
  493:  op sub *tmp235 .CORE_Y *tmp234                               ...
  494:  op len *tmp236 *tmp233 *tmp235                               ...
  495:  op idiv *tmp237 *tmp236 .SPEED_TENTHS                        ...
  496:  op div :processUnit:distance *tmp237 10                      ...
        label *label206                                              if within(CORE_X, CORE_Y, RADIUS_WITHIN) then
        label *label203                                              if state == S_APPROACH_SRC then
  497:  jump *label209 notEqual :processUnit:state 3                 if state == S_APPROACH_DST then
  498:  ucontrol within .DOME_X .DOME_Y 8 *tmp241 0                  if within(DOME_X, DOME_Y, RADIUS_WITHIN) then
  499:  jump *label211 equal *tmp241 false                           ...
  500:  jump *label213 equal .SUPPLY_S_FIRST false                   if supply then
  501:  ucontrol itemDrop .DOME .UNIT_CAPACITY 0 0 0                 itemDrop(DOME, UNIT_CAPACITY);
  502:  set .MSG ", supplying\n"                                     MSG = ", supplying\n";
  503:  jump *label214 always 0 0                                    if supply then
        label *label213                                              ...
  504:  ucontrol approach .DOME_X .DOME_Y 6 0 0                      approach(DOME_X, DOME_Y, RADIUS_APPROACH);   // Keep the unit active
  505:  set .MSG ", waiting\n"                                       MSG = ", waiting\n";
        label *label214                                              if supply then
  506:  sensor *tmp244 @unit @totalItems                             if @unit.@totalItems <= 0 then
  507:  jump *label212 greaterThan *tmp244 0                         ...
  508:  ucontrol approach .CORE_X .CORE_Y 6 0 0                      approach(CORE_X, CORE_Y, RADIUS_APPROACH);
  509:  set :processUnit:state 2                                     state = S_APPROACH_SRC;
  510:  jump *label212 always 0 0                                    if within(DOME_X, DOME_Y, RADIUS_WITHIN) then
        label *label211                                              ...
  511:  ucontrol approach .DOME_X .DOME_Y 6 0 0                      approach(DOME_X, DOME_Y, RADIUS_APPROACH);
  512:  set .MSG ", returning in [gold]"                             MSG = ", returning in [gold]";
  513:  sensor *tmp247 @unit @x                                      distance = len(DOME_X - @unit.@x, DOME_Y - @unit.@y) \ SPEED_TENTHS / 10;
  514:  op sub *tmp248 .DOME_X *tmp247                               ...
  515:  sensor *tmp249 @unit @y                                      ...
  516:  op sub *tmp250 .DOME_Y *tmp249                               ...
  517:  op len *tmp251 *tmp248 *tmp250                               ...
  518:  op idiv *tmp252 *tmp251 .SPEED_TENTHS                        ...
  519:  op div :processUnit:distance *tmp252 10                      ...
        label *label212                                              if within(DOME_X, DOME_Y, RADIUS_WITHIN) then
        label *label209                                              if state == S_APPROACH_DST then
  520:  ucontrol flag :processUnit:state 0 0 0 0                     flag(state);
  521:  sensor *tmp254 @unit @totalItems                             print($"  $group: [$color]$[]", @unit.@totalItems);
  522:  print "  "                                                   ...
  523:  print .GROUP1                                                ...
  524:  print ": [gold]"                                             ...
  525:  print *tmp254                                                ...
  526:  print "[]"                                                   ...
  527:  jump *label217 lessThan :processUnit:distance 0              if distance >= 0 then
  528:  print .MSG                                                   println($"$MSG$distance[] sec");
  529:  print :processUnit:distance                                  ...
  530:  print "[] sec\n"                                             ...
  531:  jump *label218 always 0 0                                    if distance >= 0 then
        label *label217                                              ...
  532:  print .MSG                                                   print(MSG);
        label *label218                                              if distance >= 0 then
  533:  set :processUnit:unit @unit                                  unit = @unit;
  534:  set .UNIT_S1 :processUnit:unit                               processUnit(out UNIT_S1, @silicon, GROUP1, SUPPLY_S_FIRST);
  535:  jump *label219 equal *tmp126 false                           if FOUR_UNITS then
  536:  jump *label223 equal .UNIT_S2 null                           if currentUnit != null then
  537:  ubind .UNIT_S2                                               ubind(currentUnit);
  538:  sensor *tmp263 @unit @dead                                   if @unit.@dead == 0 && @unit.@controller == @this then
  539:  op equal *tmp264 *tmp263 0                                   ...
  540:  sensor *tmp265 @unit @controller                             ...
  541:  op equal *tmp266 *tmp265 @this                               ...
  542:  op land *tmp267 *tmp264 *tmp266                              ...
  543:  jump *label222 notEqual *tmp267 false                        ...
        label *label223                                              if currentUnit != null then
  544:  ubind *tmp9                                                  var firstUnit = ubind(TYPE);
  545:  set :rebindUnit.5:firstUnit @unit                            ...
  546:  jump __start__ equal :rebindUnit.5:firstUnit null            if firstUnit != null then
        label *label229                                              do
  547:  sensor *tmp271 @unit @controlled                             if @unit.@controlled == 0 then
  548:  jump *label222 equal *tmp271 0                               ...
  549:  ubind *tmp9                                                  ubind(TYPE);
  550:  jump __start__ equal @unit :rebindUnit.5:firstUnit           while @unit != firstUnit and firstUnit.@dead == 0;
  551:  sensor *tmp275 :rebindUnit.5:firstUnit @dead                 ...
  552:  jump *label229 equal *tmp275 0                               ...
  553:  end                                                          end();
        label *label222                                              rebindUnit(unit);
  554:  sensor :processUnit.1:state @unit @flag                      var state = @unit.@flag;
  555:  set :processUnit.1:distance -1                               var distance = -1;
  556:  jump *label237 lessThan :processUnit.1:state 2               if state < S_APPROACH_SRC or state > S_APPROACH_DST then
  557:  jump *label235 lessThanEq :processUnit.1:state 3             ...
        label *label237                                              ...
  558:  sensor *tmp281 @unit @firstItem                              if @unit.@firstItem == item then
  559:  jump *label239 notEqual *tmp281 @silicon                     ...
  560:  set :processUnit.1:state 3                                   state = S_APPROACH_DST;
  561:  jump *label240 always 0 0                                    if @unit.@firstItem == item then
        label *label239                                              ...
  562:  sensor *tmp284 @unit @totalItems                             elsif @unit.@totalItems == 0 then
  563:  jump *label241 notEqual *tmp284 0                            ...
  564:  set :processUnit.1:state 2                                   state = S_APPROACH_SRC;
  565:  jump *label242 always 0 0                                    elsif @unit.@totalItems == 0 then
        label *label241                                              ...
  566:  set .MSG ", initializing\n"                                  MSG = ", initializing\n";
  567:  ucontrol approach .CORE_X .CORE_Y 6 0 0                      approach(CORE_X, CORE_Y, RADIUS_APPROACH);
  568:  ucontrol within .CORE_X .CORE_Y 8 *tmp287 0                  if within(CORE_X, CORE_Y, RADIUS_WITHIN) then
  569:  jump *label243 equal *tmp287 false                           ...
  570:  ucontrol itemDrop .CORE .UNIT_CAPACITY 0 0 0                 itemDrop(CORE, UNIT_CAPACITY);
        label *label243                                              if within(CORE_X, CORE_Y, RADIUS_WITHIN) then
        label *label242                                              elsif @unit.@totalItems == 0 then
        label *label240                                              if @unit.@firstItem == item then
        label *label235                                              if state < S_APPROACH_SRC or state > S_APPROACH_DST then
  571:  jump *label245 notEqual :processUnit.1:state 2               if state == S_APPROACH_SRC then
  572:  ucontrol within .CORE_X .CORE_Y 8 *tmp291 0                  if within(CORE_X, CORE_Y, RADIUS_WITHIN) then
  573:  jump *label247 equal *tmp291 false                           ...
  574:  ucontrol itemTake .CORE @silicon .UNIT_CAPACITY 0 0          itemTake(CORE, item, UNIT_CAPACITY);
  575:  sensor *tmp293 @unit @totalItems                             if @unit.@totalItems >= UNIT_CAPACITY then
  576:  jump *label249 lessThan *tmp293 .UNIT_CAPACITY               ...
  577:  ucontrol approach .DOME_X .DOME_Y 6 0 0                      approach(DOME_X, DOME_Y, RADIUS_APPROACH);
  578:  set :processUnit.1:state 3                                   state = S_APPROACH_DST;
  579:  jump *label248 always 0 0                                    if @unit.@totalItems >= UNIT_CAPACITY then
        label *label249                                              ...
  580:  set .MSG ", loading\n"                                       MSG = ", loading\n";
  581:  jump *label248 always 0 0                                    if within(CORE_X, CORE_Y, RADIUS_WITHIN) then
        label *label247                                              ...
  582:  ucontrol approach .CORE_X .CORE_Y 6 0 0                      approach(CORE_X, CORE_Y, RADIUS_APPROACH);
  583:  set .MSG ", fetching in [gold]"                              MSG = ", fetching in [gold]";
  584:  sensor *tmp296 @unit @x                                      distance = len(CORE_X - @unit.@x, CORE_Y - @unit.@y) \ SPEED_TENTHS / 10;
  585:  op sub *tmp297 .CORE_X *tmp296                               ...
  586:  sensor *tmp298 @unit @y                                      ...
  587:  op sub *tmp299 .CORE_Y *tmp298                               ...
  588:  op len *tmp300 *tmp297 *tmp299                               ...
  589:  op idiv *tmp301 *tmp300 .SPEED_TENTHS                        ...
  590:  op div :processUnit.1:distance *tmp301 10                    ...
        label *label248                                              if within(CORE_X, CORE_Y, RADIUS_WITHIN) then
        label *label245                                              if state == S_APPROACH_SRC then
  591:  jump *label251 notEqual :processUnit.1:state 3               if state == S_APPROACH_DST then
  592:  ucontrol within .DOME_X .DOME_Y 8 *tmp305 0                  if within(DOME_X, DOME_Y, RADIUS_WITHIN) then
  593:  jump *label253 equal *tmp305 false                           ...
  594:  jump *label255 notEqual .SUPPLY_S_FIRST false                if supply then
  595:  ucontrol itemDrop .DOME .UNIT_CAPACITY 0 0 0                 itemDrop(DOME, UNIT_CAPACITY);
  596:  set .MSG ", supplying\n"                                     MSG = ", supplying\n";
  597:  jump *label256 always 0 0                                    if supply then
        label *label255                                              ...
  598:  ucontrol approach .DOME_X .DOME_Y 6 0 0                      approach(DOME_X, DOME_Y, RADIUS_APPROACH);   // Keep the unit active
  599:  set .MSG ", waiting\n"                                       MSG = ", waiting\n";
        label *label256                                              if supply then
  600:  sensor *tmp308 @unit @totalItems                             if @unit.@totalItems <= 0 then
  601:  jump *label254 greaterThan *tmp308 0                         ...
  602:  ucontrol approach .CORE_X .CORE_Y 6 0 0                      approach(CORE_X, CORE_Y, RADIUS_APPROACH);
  603:  set :processUnit.1:state 2                                   state = S_APPROACH_SRC;
  604:  jump *label254 always 0 0                                    if within(DOME_X, DOME_Y, RADIUS_WITHIN) then
        label *label253                                              ...
  605:  ucontrol approach .DOME_X .DOME_Y 6 0 0                      approach(DOME_X, DOME_Y, RADIUS_APPROACH);
  606:  set .MSG ", returning in [gold]"                             MSG = ", returning in [gold]";
  607:  sensor *tmp311 @unit @x                                      distance = len(DOME_X - @unit.@x, DOME_Y - @unit.@y) \ SPEED_TENTHS / 10;
  608:  op sub *tmp312 .DOME_X *tmp311                               ...
  609:  sensor *tmp313 @unit @y                                      ...
  610:  op sub *tmp314 .DOME_Y *tmp313                               ...
  611:  op len *tmp315 *tmp312 *tmp314                               ...
  612:  op idiv *tmp316 *tmp315 .SPEED_TENTHS                        ...
  613:  op div :processUnit.1:distance *tmp316 10                    ...
        label *label254                                              if within(DOME_X, DOME_Y, RADIUS_WITHIN) then
        label *label251                                              if state == S_APPROACH_DST then
  614:  ucontrol flag :processUnit.1:state 0 0 0 0                   flag(state);
  615:  sensor *tmp318 @unit @totalItems                             print($"  $group: [$color]$[]", @unit.@totalItems);
  616:  print "  "                                                   ...
  617:  print .GROUP2                                                ...
  618:  print ": [gold]"                                             ...
  619:  print *tmp318                                                ...
  620:  print "[]"                                                   ...
  621:  jump *label259 lessThan :processUnit.1:distance 0            if distance >= 0 then
  622:  print .MSG                                                   println($"$MSG$distance[] sec");
  623:  print :processUnit.1:distance                                ...
  624:  print "[] sec\n"                                             ...
  625:  jump *label260 always 0 0                                    if distance >= 0 then
        label *label259                                              ...
  626:  print .MSG                                                   print(MSG);
        label *label260                                              if distance >= 0 then
  627:  set :processUnit.1:unit @unit                                unit = @unit;
  628:  set .UNIT_S2 :processUnit.1:unit                             processUnit(out UNIT_S2, @silicon, GROUP2, not SUPPLY_S_FIRST);
  629:  jump *label261 equal .SUPPLY_S_FIRST false                   SUPPLY_S_FIRST = SUPPLY_S_FIRST ? UNIT_S1.@totalItems > 0 : UNIT_S2.@totalItems == 0;
  630:  sensor *tmp323 :processUnit:unit @totalItems                 ...
  631:  op greaterThan .SUPPLY_S_FIRST *tmp323 0                     ...
  632:  jump *label262 always 0 0                                    ...
        label *label261                                              ...
  633:  sensor *tmp325 :processUnit.1:unit @totalItems               ...
  634:  op equal .SUPPLY_S_FIRST *tmp325 0                           ...
        label *label262                                              ...
        label *label219                                              if FOUR_UNITS then
  635:  print "\n[green]Phase fabric[] status:\n"                    print(text);
  636:  sensor :printDomeStatus.1:level .DOME @phase-fabric          var level = DOME.sensor(item);
  637:  jump *label264 lessThanEq :printDomeStatus.1:level 3         if level > 3 then
  638:  print "  dome:  [green]"                                     println($"  dome:  [green]$level[]");
  639:  print :printDomeStatus.1:level                               ...
  640:  print "[]\n"                                                 ...
  641:  jump *label265 always 0 0                                    if level > 3 then
        label *label264                                              ...
  642:  print "  dome:  [coral]"                                     println($"  dome:  [coral]$level[]");
  643:  print :printDomeStatus.1:level                               ...
  644:  print "[]\n"                                                 ...
        label *label265                                              if level > 3 then
  645:  jump *label268 equal .UNIT_P1 null                           if currentUnit != null then
  646:  ubind .UNIT_P1                                               ubind(currentUnit);
  647:  sensor *tmp333 @unit @dead                                   if @unit.@dead == 0 && @unit.@controller == @this then
  648:  op equal *tmp334 *tmp333 0                                   ...
  649:  sensor *tmp335 @unit @controller                             ...
  650:  op equal *tmp336 *tmp335 @this                               ...
  651:  op land *tmp337 *tmp334 *tmp336                              ...
  652:  jump *label267 notEqual *tmp337 false                        ...
        label *label268                                              if currentUnit != null then
  653:  ubind *tmp9                                                  var firstUnit = ubind(TYPE);
  654:  set :rebindUnit.6:firstUnit @unit                            ...
  655:  jump __start__ equal :rebindUnit.6:firstUnit null            if firstUnit != null then
        label *label274                                              do
  656:  sensor *tmp341 @unit @controlled                             if @unit.@controlled == 0 then
  657:  jump *label267 equal *tmp341 0                               ...
  658:  ubind *tmp9                                                  ubind(TYPE);
  659:  jump __start__ equal @unit :rebindUnit.6:firstUnit           while @unit != firstUnit and firstUnit.@dead == 0;
  660:  sensor *tmp345 :rebindUnit.6:firstUnit @dead                 ...
  661:  jump *label274 equal *tmp345 0                               ...
  662:  end                                                          end();
        label *label267                                              rebindUnit(unit);
  663:  sensor :processUnit.2:state @unit @flag                      var state = @unit.@flag;
  664:  set :processUnit.2:distance -1                               var distance = -1;
  665:  jump *label282 lessThan :processUnit.2:state 2               if state < S_APPROACH_SRC or state > S_APPROACH_DST then
  666:  jump *label280 lessThanEq :processUnit.2:state 3             ...
        label *label282                                              ...
  667:  sensor *tmp351 @unit @firstItem                              if @unit.@firstItem == item then
  668:  jump *label284 notEqual *tmp351 @phase-fabric                ...
  669:  set :processUnit.2:state 3                                   state = S_APPROACH_DST;
  670:  jump *label285 always 0 0                                    if @unit.@firstItem == item then
        label *label284                                              ...
  671:  sensor *tmp354 @unit @totalItems                             elsif @unit.@totalItems == 0 then
  672:  jump *label286 notEqual *tmp354 0                            ...
  673:  set :processUnit.2:state 2                                   state = S_APPROACH_SRC;
  674:  jump *label287 always 0 0                                    elsif @unit.@totalItems == 0 then
        label *label286                                              ...
  675:  set .MSG ", initializing\n"                                  MSG = ", initializing\n";
  676:  ucontrol approach .CORE_X .CORE_Y 6 0 0                      approach(CORE_X, CORE_Y, RADIUS_APPROACH);
  677:  ucontrol within .CORE_X .CORE_Y 8 *tmp357 0                  if within(CORE_X, CORE_Y, RADIUS_WITHIN) then
  678:  jump *label288 equal *tmp357 false                           ...
  679:  ucontrol itemDrop .CORE .UNIT_CAPACITY 0 0 0                 itemDrop(CORE, UNIT_CAPACITY);
        label *label288                                              if within(CORE_X, CORE_Y, RADIUS_WITHIN) then
        label *label287                                              elsif @unit.@totalItems == 0 then
        label *label285                                              if @unit.@firstItem == item then
        label *label280                                              if state < S_APPROACH_SRC or state > S_APPROACH_DST then
  680:  jump *label290 notEqual :processUnit.2:state 2               if state == S_APPROACH_SRC then
  681:  ucontrol within .CORE_X .CORE_Y 8 *tmp361 0                  if within(CORE_X, CORE_Y, RADIUS_WITHIN) then
  682:  jump *label292 equal *tmp361 false                           ...
  683:  ucontrol itemTake .CORE @phase-fabric .UNIT_CAPACITY 0 0     itemTake(CORE, item, UNIT_CAPACITY);
  684:  sensor *tmp363 @unit @totalItems                             if @unit.@totalItems >= UNIT_CAPACITY then
  685:  jump *label294 lessThan *tmp363 .UNIT_CAPACITY               ...
  686:  ucontrol approach .DOME_X .DOME_Y 6 0 0                      approach(DOME_X, DOME_Y, RADIUS_APPROACH);
  687:  set :processUnit.2:state 3                                   state = S_APPROACH_DST;
  688:  jump *label293 always 0 0                                    if @unit.@totalItems >= UNIT_CAPACITY then
        label *label294                                              ...
  689:  set .MSG ", loading\n"                                       MSG = ", loading\n";
  690:  jump *label293 always 0 0                                    if within(CORE_X, CORE_Y, RADIUS_WITHIN) then
        label *label292                                              ...
  691:  ucontrol approach .CORE_X .CORE_Y 6 0 0                      approach(CORE_X, CORE_Y, RADIUS_APPROACH);
  692:  set .MSG ", fetching in [gold]"                              MSG = ", fetching in [gold]";
  693:  sensor *tmp366 @unit @x                                      distance = len(CORE_X - @unit.@x, CORE_Y - @unit.@y) \ SPEED_TENTHS / 10;
  694:  op sub *tmp367 .CORE_X *tmp366                               ...
  695:  sensor *tmp368 @unit @y                                      ...
  696:  op sub *tmp369 .CORE_Y *tmp368                               ...
  697:  op len *tmp370 *tmp367 *tmp369                               ...
  698:  op idiv *tmp371 *tmp370 .SPEED_TENTHS                        ...
  699:  op div :processUnit.2:distance *tmp371 10                    ...
        label *label293                                              if within(CORE_X, CORE_Y, RADIUS_WITHIN) then
        label *label290                                              if state == S_APPROACH_SRC then
  700:  jump *label296 notEqual :processUnit.2:state 3               if state == S_APPROACH_DST then
  701:  ucontrol within .DOME_X .DOME_Y 8 *tmp375 0                  if within(DOME_X, DOME_Y, RADIUS_WITHIN) then
  702:  jump *label298 equal *tmp375 false                           ...
  703:  jump *label300 equal .SUPPLY_P_FIRST false                   if supply then
  704:  ucontrol itemDrop .DOME .UNIT_CAPACITY 0 0 0                 itemDrop(DOME, UNIT_CAPACITY);
  705:  set .MSG ", supplying\n"                                     MSG = ", supplying\n";
  706:  jump *label301 always 0 0                                    if supply then
        label *label300                                              ...
  707:  ucontrol approach .DOME_X .DOME_Y 6 0 0                      approach(DOME_X, DOME_Y, RADIUS_APPROACH);   // Keep the unit active
  708:  set .MSG ", waiting\n"                                       MSG = ", waiting\n";
        label *label301                                              if supply then
  709:  sensor *tmp378 @unit @totalItems                             if @unit.@totalItems <= 0 then
  710:  jump *label299 greaterThan *tmp378 0                         ...
  711:  ucontrol approach .CORE_X .CORE_Y 6 0 0                      approach(CORE_X, CORE_Y, RADIUS_APPROACH);
  712:  set :processUnit.2:state 2                                   state = S_APPROACH_SRC;
  713:  jump *label299 always 0 0                                    if within(DOME_X, DOME_Y, RADIUS_WITHIN) then
        label *label298                                              ...
  714:  ucontrol approach .DOME_X .DOME_Y 6 0 0                      approach(DOME_X, DOME_Y, RADIUS_APPROACH);
  715:  set .MSG ", returning in [gold]"                             MSG = ", returning in [gold]";
  716:  sensor *tmp381 @unit @x                                      distance = len(DOME_X - @unit.@x, DOME_Y - @unit.@y) \ SPEED_TENTHS / 10;
  717:  op sub *tmp382 .DOME_X *tmp381                               ...
  718:  sensor *tmp383 @unit @y                                      ...
  719:  op sub *tmp384 .DOME_Y *tmp383                               ...
  720:  op len *tmp385 *tmp382 *tmp384                               ...
  721:  op idiv *tmp386 *tmp385 .SPEED_TENTHS                        ...
  722:  op div :processUnit.2:distance *tmp386 10                    ...
        label *label299                                              if within(DOME_X, DOME_Y, RADIUS_WITHIN) then
        label *label296                                              if state == S_APPROACH_DST then
  723:  ucontrol flag :processUnit.2:state 0 0 0 0                   flag(state);
  724:  sensor *tmp388 @unit @totalItems                             print($"  $group: [$color]$[]", @unit.@totalItems);
  725:  print "  "                                                   ...
  726:  print .GROUP1                                                ...
  727:  print ": [gold]"                                             ...
  728:  print *tmp388                                                ...
  729:  print "[]"                                                   ...
  730:  jump *label304 lessThan :processUnit.2:distance 0            if distance >= 0 then
  731:  print .MSG                                                   println($"$MSG$distance[] sec");
  732:  print :processUnit.2:distance                                ...
  733:  print "[] sec\n"                                             ...
  734:  jump *label305 always 0 0                                    if distance >= 0 then
        label *label304                                              ...
  735:  print .MSG                                                   print(MSG);
        label *label305                                              if distance >= 0 then
  736:  set :processUnit.2:unit @unit                                unit = @unit;
  737:  set .UNIT_P1 :processUnit.2:unit                             processUnit(out UNIT_P1, @phase-fabric, GROUP1, SUPPLY_P_FIRST);
  738:  jump *label306 equal *tmp126 false                           if FOUR_UNITS then
  739:  jump *label310 equal .UNIT_P2 null                           if currentUnit != null then
  740:  ubind .UNIT_P2                                               ubind(currentUnit);
  741:  sensor *tmp397 @unit @dead                                   if @unit.@dead == 0 && @unit.@controller == @this then
  742:  op equal *tmp398 *tmp397 0                                   ...
  743:  sensor *tmp399 @unit @controller                             ...
  744:  op equal *tmp400 *tmp399 @this                               ...
  745:  op land *tmp401 *tmp398 *tmp400                              ...
  746:  jump *label309 notEqual *tmp401 false                        ...
        label *label310                                              if currentUnit != null then
  747:  ubind *tmp9                                                  var firstUnit = ubind(TYPE);
  748:  set :rebindUnit.7:firstUnit @unit                            ...
  749:  jump __start__ equal :rebindUnit.7:firstUnit null            if firstUnit != null then
        label *label316                                              do
  750:  sensor *tmp405 @unit @controlled                             if @unit.@controlled == 0 then
  751:  jump *label309 equal *tmp405 0                               ...
  752:  ubind *tmp9                                                  ubind(TYPE);
  753:  jump __start__ equal @unit :rebindUnit.7:firstUnit           while @unit != firstUnit and firstUnit.@dead == 0;
  754:  sensor *tmp409 :rebindUnit.7:firstUnit @dead                 ...
  755:  jump *label316 equal *tmp409 0                               ...
  756:  end                                                          end();
        label *label309                                              rebindUnit(unit);
  757:  sensor :processUnit.3:state @unit @flag                      var state = @unit.@flag;
  758:  set :processUnit.3:distance -1                               var distance = -1;
  759:  jump *label324 lessThan :processUnit.3:state 2               if state < S_APPROACH_SRC or state > S_APPROACH_DST then
  760:  jump *label322 lessThanEq :processUnit.3:state 3             ...
        label *label324                                              ...
  761:  sensor *tmp415 @unit @firstItem                              if @unit.@firstItem == item then
  762:  jump *label326 notEqual *tmp415 @phase-fabric                ...
  763:  set :processUnit.3:state 3                                   state = S_APPROACH_DST;
  764:  jump *label327 always 0 0                                    if @unit.@firstItem == item then
        label *label326                                              ...
  765:  sensor *tmp418 @unit @totalItems                             elsif @unit.@totalItems == 0 then
  766:  jump *label328 notEqual *tmp418 0                            ...
  767:  set :processUnit.3:state 2                                   state = S_APPROACH_SRC;
  768:  jump *label329 always 0 0                                    elsif @unit.@totalItems == 0 then
        label *label328                                              ...
  769:  set .MSG ", initializing\n"                                  MSG = ", initializing\n";
  770:  ucontrol approach .CORE_X .CORE_Y 6 0 0                      approach(CORE_X, CORE_Y, RADIUS_APPROACH);
  771:  ucontrol within .CORE_X .CORE_Y 8 *tmp421 0                  if within(CORE_X, CORE_Y, RADIUS_WITHIN) then
  772:  jump *label330 equal *tmp421 false                           ...
  773:  ucontrol itemDrop .CORE .UNIT_CAPACITY 0 0 0                 itemDrop(CORE, UNIT_CAPACITY);
        label *label330                                              if within(CORE_X, CORE_Y, RADIUS_WITHIN) then
        label *label329                                              elsif @unit.@totalItems == 0 then
        label *label327                                              if @unit.@firstItem == item then
        label *label322                                              if state < S_APPROACH_SRC or state > S_APPROACH_DST then
  774:  jump *label332 notEqual :processUnit.3:state 2               if state == S_APPROACH_SRC then
  775:  ucontrol within .CORE_X .CORE_Y 8 *tmp425 0                  if within(CORE_X, CORE_Y, RADIUS_WITHIN) then
  776:  jump *label334 equal *tmp425 false                           ...
  777:  ucontrol itemTake .CORE @phase-fabric .UNIT_CAPACITY 0 0     itemTake(CORE, item, UNIT_CAPACITY);
  778:  sensor *tmp427 @unit @totalItems                             if @unit.@totalItems >= UNIT_CAPACITY then
  779:  jump *label336 lessThan *tmp427 .UNIT_CAPACITY               ...
  780:  ucontrol approach .DOME_X .DOME_Y 6 0 0                      approach(DOME_X, DOME_Y, RADIUS_APPROACH);
  781:  set :processUnit.3:state 3                                   state = S_APPROACH_DST;
  782:  jump *label335 always 0 0                                    if @unit.@totalItems >= UNIT_CAPACITY then
        label *label336                                              ...
  783:  set .MSG ", loading\n"                                       MSG = ", loading\n";
  784:  jump *label335 always 0 0                                    if within(CORE_X, CORE_Y, RADIUS_WITHIN) then
        label *label334                                              ...
  785:  ucontrol approach .CORE_X .CORE_Y 6 0 0                      approach(CORE_X, CORE_Y, RADIUS_APPROACH);
  786:  set .MSG ", fetching in [gold]"                              MSG = ", fetching in [gold]";
  787:  sensor *tmp430 @unit @x                                      distance = len(CORE_X - @unit.@x, CORE_Y - @unit.@y) \ SPEED_TENTHS / 10;
  788:  op sub *tmp431 .CORE_X *tmp430                               ...
  789:  sensor *tmp432 @unit @y                                      ...
  790:  op sub *tmp433 .CORE_Y *tmp432                               ...
  791:  op len *tmp434 *tmp431 *tmp433                               ...
  792:  op idiv *tmp435 *tmp434 .SPEED_TENTHS                        ...
  793:  op div :processUnit.3:distance *tmp435 10                    ...
        label *label335                                              if within(CORE_X, CORE_Y, RADIUS_WITHIN) then
        label *label332                                              if state == S_APPROACH_SRC then
  794:  jump *label338 notEqual :processUnit.3:state 3               if state == S_APPROACH_DST then
  795:  ucontrol within .DOME_X .DOME_Y 8 *tmp439 0                  if within(DOME_X, DOME_Y, RADIUS_WITHIN) then
  796:  jump *label340 equal *tmp439 false                           ...
  797:  jump *label342 notEqual .SUPPLY_P_FIRST false                if supply then
  798:  ucontrol itemDrop .DOME .UNIT_CAPACITY 0 0 0                 itemDrop(DOME, UNIT_CAPACITY);
  799:  set .MSG ", supplying\n"                                     MSG = ", supplying\n";
  800:  jump *label343 always 0 0                                    if supply then
        label *label342                                              ...
  801:  ucontrol approach .DOME_X .DOME_Y 6 0 0                      approach(DOME_X, DOME_Y, RADIUS_APPROACH);   // Keep the unit active
  802:  set .MSG ", waiting\n"                                       MSG = ", waiting\n";
        label *label343                                              if supply then
  803:  sensor *tmp442 @unit @totalItems                             if @unit.@totalItems <= 0 then
  804:  jump *label341 greaterThan *tmp442 0                         ...
  805:  ucontrol approach .CORE_X .CORE_Y 6 0 0                      approach(CORE_X, CORE_Y, RADIUS_APPROACH);
  806:  set :processUnit.3:state 2                                   state = S_APPROACH_SRC;
  807:  jump *label341 always 0 0                                    if within(DOME_X, DOME_Y, RADIUS_WITHIN) then
        label *label340                                              ...
  808:  ucontrol approach .DOME_X .DOME_Y 6 0 0                      approach(DOME_X, DOME_Y, RADIUS_APPROACH);
  809:  set .MSG ", returning in [gold]"                             MSG = ", returning in [gold]";
  810:  sensor *tmp445 @unit @x                                      distance = len(DOME_X - @unit.@x, DOME_Y - @unit.@y) \ SPEED_TENTHS / 10;
  811:  op sub *tmp446 .DOME_X *tmp445                               ...
  812:  sensor *tmp447 @unit @y                                      ...
  813:  op sub *tmp448 .DOME_Y *tmp447                               ...
  814:  op len *tmp449 *tmp446 *tmp448                               ...
  815:  op idiv *tmp450 *tmp449 .SPEED_TENTHS                        ...
  816:  op div :processUnit.3:distance *tmp450 10                    ...
        label *label341                                              if within(DOME_X, DOME_Y, RADIUS_WITHIN) then
        label *label338                                              if state == S_APPROACH_DST then
  817:  ucontrol flag :processUnit.3:state 0 0 0 0                   flag(state);
  818:  sensor *tmp452 @unit @totalItems                             print($"  $group: [$color]$[]", @unit.@totalItems);
  819:  print "  "                                                   ...
  820:  print .GROUP2                                                ...
  821:  print ": [gold]"                                             ...
  822:  print *tmp452                                                ...
  823:  print "[]"                                                   ...
  824:  jump *label346 lessThan :processUnit.3:distance 0            if distance >= 0 then
  825:  print .MSG                                                   println($"$MSG$distance[] sec");
  826:  print :processUnit.3:distance                                ...
  827:  print "[] sec\n"                                             ...
  828:  jump *label347 always 0 0                                    if distance >= 0 then
        label *label346                                              ...
  829:  print .MSG                                                   print(MSG);
        label *label347                                              if distance >= 0 then
  830:  set :processUnit.3:unit @unit                                unit = @unit;
  831:  set .UNIT_P2 :processUnit.3:unit                             processUnit(out UNIT_P2, @phase-fabric, GROUP2, not SUPPLY_P_FIRST);
  832:  jump *label348 equal .SUPPLY_P_FIRST false                   SUPPLY_P_FIRST = SUPPLY_P_FIRST ? UNIT_P1.@totalItems > 0 : UNIT_P2.@totalItems == 0;
  833:  sensor *tmp457 :processUnit.2:unit @totalItems               ...
  834:  op greaterThan .SUPPLY_P_FIRST *tmp457 0                     ...
  835:  jump *label349 always 0 0                                    ...
        label *label348                                              ...
  836:  sensor *tmp459 :processUnit.3:unit @totalItems               ...
  837:  op equal .SUPPLY_P_FIRST *tmp459 0                           ...
        label *label349                                              ...
        label *label306                                              if FOUR_UNITS then
  838:  op sub *tmp461 @time :start                                  print($"\n[lightgray]Loop time: $ ms", floor(@time - start));
  839:  op floor *tmp462 *tmp461 0                                   ...
  840:  print "\n[lightgray]Loop time: "                             ...
  841:  print *tmp462                                                ...
  842:  print " ms"                                                  ...
  843:  printflush message1                                          printflush(message1);
  844:  jump *label350 equal *tmp9 UNIT_TYPE                         if TYPE != UNIT_TYPE and unitCheck > @time then
  845:  jump *label350 lessThanEq :unitCheck @time                   ...
  846:  set :areUnitsAvailable.2:free 0                              var free = 0, occupied = 0, needed = 0;
  847:  set :areUnitsAvailable.2:occupied 0                          ...
  848:  ubind UNIT_TYPE                                              var firstUnit = ubind(type);
  849:  set :areUnitsAvailable.2:firstUnit @unit                     ...
  850:  jump *label372 equal :areUnitsAvailable.2:firstUnit null     if firstUnit != null then
  851:  set *tmp477 2                                                needed = needsFourUnits(@unit) ? 4 : 2;
  852:  set :needsFourUnits.3:unit @unit                             ...
  853:  sensor *tmp474 :needsFourUnits.3:unit @speed                 var travel_time = 2 * len(DOME_X - CORE_X, DOME_Y - CORE_Y) / unit.@speed;
  854:  op div :needsFourUnits.3:travel_time *tmp130 *tmp474         ...
  855:  jump *label360 lessThan :needsFourUnits.3:travel_time 47     needed = needsFourUnits(@unit) ? 4 : 2;
  856:  set *tmp477 4                                                ...
        label *label360                                              ...
        label *label362                                              do
  857:  sensor *tmp478 @unit @controlled                             if @unit.@controlled == 0 or @unit.@controller == @this then
  858:  jump *label367 equal *tmp478 0                               ...
  859:  sensor *tmp480 @unit @controller                             ...
  860:  jump *label365 notEqual *tmp480 @this                        ...
        label *label367                                              ...
  861:  op add :areUnitsAvailable.2:free :areUnitsAvailable.2:free 1 if ++free >= needed then
  862:  jump *label366 lessThan :areUnitsAvailable.2:free *tmp477    ...
  863:  set *tmp466 true                                             return true;
  864:  jump *label356 always 0 0                                    ...
        label *label365                                              if @unit.@controlled == 0 or @unit.@controller == @this then
  865:  op add :areUnitsAvailable.2:occupied :areUnitsAvailable.2:oc ...
        label *label366                                              ...
  866:  ubind UNIT_TYPE                                              ubind(type);
  867:  jump *label372 equal @unit :areUnitsAvailable.2:firstUnit    while @unit != firstUnit and firstUnit.@dead == 0;
  868:  sensor *tmp487 :areUnitsAvailable.2:firstUnit @dead          ...
  869:  jump *label362 equal *tmp487 0                               ...
        label *label372                                              if output then
  870:  set *tmp466 false                                            return false;
        label *label356                                              if areUnitsAvailable(UNIT_TYPE, false) then
  871:  jump *label354 equal *tmp466 false                           ...
  872:  end                                                          end();
        label *label354                                              if areUnitsAvailable(UNIT_TYPE, false) then
  873:  op add :unitCheck @time 5000                                 unitCheck = @time + UNIT_CHECK_TIME;
        label *label350                                              if TYPE != UNIT_TYPE and unitCheck > @time then
  874:  sensor *tmp192 switch1 @enabled                              while switch1.@enabled do
  875:  jump *label414 notEqual *tmp192 false                        ...
  876:  end
        label *label0                                                noinline def locateCore(type)
  877:  ubind :locateCore:type                                       ubind(type);
  878:  sensor *tmp494 @unit @controlled                             if @unit.@controlled == 0 or @unit.@controller == @this then
  879:  jump *label379 equal *tmp494 0                               ...
  880:  sensor *tmp496 @unit @controller                             ...
  881:  jump *label377 notEqual *tmp496 @this                        ...
        label *label379                                              ...
  882:  ulocate building core false @copper 0 0 0 .CORE              CORE = ulocate(:building, :core, false);
        label *label377                                              if @unit.@controlled == 0 or @unit.@controller == @this then
  883:  set :locateCore*retval .CORE                                 noinline def locateCore(type)
  884:  return :locateCore*retaddr                                   ...


Code size and number of instantiations by function:
  Size  Times  AvgSize  Function
   296     4x     74,0  inline void processUnit(in out unit, in item, in group, in supply)
   189     6x     31,5  inline def areUnitsAvailable(in type, in output)
   144     8x     18,0  inline def rebindUnit(in currentUnit)
   107     1x    107,0  <no function>
    38     7x      5,4  inline def needsFourUnits(in unit)
    27     1x     27,0  inline def chooseUnitType()
    25     1x     25,0  inline void locateDomeAndCore()
    22     1x     22,0  inline def rebindUnits()
    20     2x     10,0  inline void printDomeStatus(in item, in text)
     9     1x      9,0  noinline def locateCore(in type)
     8     4x      2,0  inline def acquireUnit(in currentUnit)
     1     1x      1,0  inline void swap(in out a, in out b)

Performance: parsed in 374 ms, compiled in 285 ms, optimized in 1,483 ms, run in 51 ms.
Error connecting to Mlog Watcher: Connection refused: connect
  - make sure Mindustry with active Mlog Watcher mod is running
  - verify Mlog Watcher listens on port 9992

Program output (100,000 steps):
[gold]Waiting for an overdrive dome to be connected...
[--- Previous segment repeated 24998,00 times ---]

Execution step limit of 100000 exceeded.
