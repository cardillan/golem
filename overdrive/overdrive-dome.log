  1446 instructions before optimizations.
    43 instructions eliminated by Temp Variables Elimination.
   259 instructions eliminated by Dead Code Elimination (2 passes, 7 iterations).
     4 instructions eliminated by Jump Normalization (2 passes, 5 iterations).
    71 instructions eliminated by Jump Optimization (2 passes, 5 iterations).
    96 instructions eliminated by Single Step Elimination (3 passes, 8 iterations).
     2 instructions eliminated by If Expression Optimization (4 iterations).
    86 instructions eliminated by Data Flow Optimization (4 passes, 18 iterations).
     2 instructions added by Loop Optimization (4 iterations).
     3 loops improved by Loop Optimization.
   158 instructions added by Loop Unrolling (8 iterations).
     2 loops unrolled by Loop Unrolling.
    21 instructions eliminated by Jump Straightening (5 iterations).
    24 instructions updated by JumpThreading.
    19 instructions eliminated by Unreachable Code Elimination.
    56 instructions eliminated by Print Merging.
   949 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 184):
    Replicate loop condition at line 54:5                        cost     1, benefit       25.0, efficiency       25.0
    Replicate loop condition at line 119:5                       cost     1, benefit       25.0, efficiency       25.0
  * Unroll iteration loop at line 169:9                          cost     5, benefit      375.0, efficiency       75.0 (+3 instructions)
  ! Unroll iteration loop at line 201:9                          cost   213, benefit      375.0, efficiency        1.8

Pass 1: speed optimization selection (cost limit 181):
  * Replicate loop condition at line 54:5                        cost     1, benefit       25.0, efficiency       25.0 (+1 instructions)
    Replicate loop condition at line 119:5                       cost     1, benefit       25.0, efficiency       25.0
  ! Unroll iteration loop at line 201:9                          cost   213, benefit      375.0, efficiency        1.8

Pass 1: speed optimization selection (cost limit 180):
  * Replicate loop condition at line 119:5                       cost     1, benefit       25.0, efficiency       25.0 (+1 instructions)
  ! Unroll iteration loop at line 201:9                          cost   213, benefit      375.0, efficiency        1.8

Pass 1: speed optimization selection (cost limit 179):
  ! Unroll iteration loop at line 201:9                          cost   213, benefit      375.0, efficiency        1.8

Pass 2: speed optimization selection (cost limit 198):
  * Unroll iteration loop at line 201:9                          cost   197, benefit      375.0, efficiency        1.9 (+147 instructions)

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-173 instructions):
 
    37 label *label15
    38 jump *label16 equal :locateCore.0*retval false
    39 jump *label1 always
-    * set *tmp2 null
    40 jump *label17 always
    41 label *label16
-    * set *tmp2 null
    42 label *label17
    43 label *label9
    44 multijump *tmp1 0 0 marker0
 
   117 label *label36
   118 set *tmp29 null
   119 label *label37
-    * set *tmp27 *tmp29
   120 jump *label35 always
   121 label *label34
   122 set *tmp30 :areUnitsAvailable.0:occupied
   123 op add :areUnitsAvailable.0:occupied :areUnitsAvailable.0:occupied 1
-    * set *tmp27 *tmp30
   124 label *label35
   125 ubind :areUnitsAvailable.0:type
   126 label *label32
 
   130 op land *tmp34 *tmp31 *tmp33
   131 jump *label31 notEqual *tmp34 false
   132 label *label33
-    * set *tmp12 null
   133 jump *label27 always
   134 label *label26
-    * set *tmp12 null
   135 label *label27
   136 jump *label38 equal :areUnitsAvailable.0:output false
   137 print :areUnitsAvailable.0:type
 
   145 jump *label40 equal *tmp36 false
   146 print ", needed: "
   147 print :areUnitsAvailable.0:needed
-    * set *tmp37 null
   148 jump *label41 always
   149 label *label40
-    * set *tmp37 null
   150 label *label41
   151 print "\n"
-    * set *tmp35 null
   152 jump *label39 always
   153 label *label38
-    * set *tmp35 null
   154 label *label39
   155 set *tmp10 false
   156 jump *label25 always
 
   159 jump *label42 equal *tmp10 false
   160 set *tmp9 UNIT_TYPE
   161 jump *label21 always
-    * set *tmp38 null
   162 jump *label43 always
   163 label *label42
-    * set *tmp38 null
   164 label *label43
   165 setaddr *tmp39 *label47
   166 set :chooseUnitType.0:type @flare
 
   225 label *label64
   226 set *tmp61 null
   227 label *label65
-    * set *tmp59 *tmp61
   228 jump *label63 always
   229 label *label62
   230 set *tmp62 :areUnitsAvailable.1:occupied
   231 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
-    * set *tmp59 *tmp62
   232 label *label63
   233 ubind :areUnitsAvailable.1:type
   234 label *label60
 
   238 op land *tmp66 *tmp63 *tmp65
   239 jump *label59 notEqual *tmp66 false
   240 label *label61
-    * set *tmp44 null
   241 jump *label55 always
   242 label *label54
-    * set *tmp44 null
   243 label *label55
   244 jump *label66 equal :areUnitsAvailable.1:output false
   245 print :areUnitsAvailable.1:type
 
   253 jump *label68 equal *tmp68 false
   254 print ", needed: "
   255 print :areUnitsAvailable.1:needed
-    * set *tmp69 null
   256 jump *label69 always
   257 label *label68
-    * set *tmp69 null
   258 label *label69
   259 print "\n"
-    * set *tmp67 null
   260 jump *label67 always
   261 label *label66
-    * set *tmp67 null
   262 label *label67
   263 set *tmp42 false
   264 jump *label53 always
 
   273 label *label70
   274 set *tmp70 null
   275 label *label71
-    * set *tmp41 *tmp70
   276 jump *label52 always
   277 label *label51
-    * set *tmp41 null
   278 label *label52
   279 label *label45
   280 multijump *tmp39 0 0 marker1
 
   299 op equal *tmp72 :rebindUnits.0:firstUnit null
   300 jump *label73 equal *tmp72 false
   301 end
-    * set *tmp73 null
   302 jump *label74 always
   303 label *label73
-    * set *tmp73 null
   304 label *label74
   305 label *label75
   306 sensor *tmp74 @unit @controller
   307 op equal *tmp75 *tmp74 @this
   308 jump *label78 equal *tmp75 false
-    * set *tmp77 :rebindUnits.0:count
   309 op add :rebindUnits.0:count :rebindUnits.0:count 1
   310 ucontrol flag 1
   311 set .UNIT_S2 .UNIT_P2
 
   321 label *label80
   322 set *tmp80 null
   323 label *label81
-    * set *tmp76 *tmp80
   324 jump *label79 always
   325 label *label78
-    * set *tmp76 null
   326 label *label79
   327 ubind .TYPE
   328 label *label76
 
   332 op land *tmp84 *tmp81 *tmp83
   333 jump *label75 notEqual *tmp84 false
   334 label *label77
-    * set *tmp71 :rebindUnits.0:count
   335 jump *label72 always
-    * set *tmp71 null
   336 label *label72
   337 set :acquireUnit.0:currentUnit .UNIT_S1
   338 set :rebindUnit.0:currentUnit :acquireUnit.0:currentUnit
 
   345 op equal *tmp92 *tmp91 @this
   346 op land *tmp93 *tmp90 *tmp92
   347 jump *label86 equal *tmp93 false
-    * set *tmp86 :rebindUnit.0:currentUnit
   348 jump *label83 always
   349 set *tmp94 null
   350 jump *label87 always
   351 label *label86
   352 set *tmp94 null
   353 label *label87
-    * set *tmp88 *tmp94
   354 jump *label85 always
   355 label *label84
-    * set *tmp88 null
   356 label *label85
   357 ubind .TYPE
   358 set :rebindUnit.0:firstUnit @unit
 
   362 sensor *tmp97 @unit @controlled
   363 op equal *tmp98 *tmp97 0
   364 jump *label93 equal *tmp98 false
-    * set *tmp86 @unit
   365 jump *label83 always
-    * set *tmp99 null
   366 jump *label94 always
   367 label *label93
-    * set *tmp99 null
   368 label *label94
   369 ubind .TYPE
   370 label *label91
 
   374 op land *tmp103 *tmp100 *tmp102
   375 jump *label90 notEqual *tmp103 false
   376 label *label92
-    * set *tmp96 null
   377 jump *label89 always
   378 label *label88
-    * set *tmp96 null
   379 label *label89
   380 end
-    * set *tmp86 null
   381 label *label83
   382 ucontrol flag 1
   383 set *tmp85 @unit
 
   396 op equal *tmp111 *tmp110 @this
   397 op land *tmp112 *tmp109 *tmp111
   398 jump *label99 equal *tmp112 false
-    * set *tmp105 :rebindUnit.1:currentUnit
   399 jump *label96 always
   400 set *tmp113 null
   401 jump *label100 always
   402 label *label99
   403 set *tmp113 null
   404 label *label100
-    * set *tmp107 *tmp113
   405 jump *label98 always
   406 label *label97
-    * set *tmp107 null
   407 label *label98
   408 ubind .TYPE
   409 set :rebindUnit.1:firstUnit @unit
 
   413 sensor *tmp116 @unit @controlled
   414 op equal *tmp117 *tmp116 0
   415 jump *label106 equal *tmp117 false
-    * set *tmp105 @unit
   416 jump *label96 always
-    * set *tmp118 null
   417 jump *label107 always
   418 label *label106
-    * set *tmp118 null
   419 label *label107
   420 ubind .TYPE
   421 label *label104
 
   425 op land *tmp122 *tmp119 *tmp121
   426 jump *label103 notEqual *tmp122 false
   427 label *label105
-    * set *tmp115 null
   428 jump *label102 always
   429 label *label101
-    * set *tmp115 null
   430 label *label102
   431 end
-    * set *tmp105 null
   432 label *label96
   433 ucontrol flag 1
   434 set *tmp104 @unit
 
   450 label *label110
   451 set .UNIT_S1 :swap.0:a
   452 set .UNIT_P1 :swap.0:b
-    * set *tmp128 null
   453 jump *label109 always
   454 label *label108
-    * set *tmp128 null
   455 label *label109
   456 sensor *tmp129 .UNIT_S1 @itemCapacity
   457 set .UNIT_CAPACITY *tmp129
 
   462 op strictEqual *tmp132 .SPEED null
   463 jump *label111 equal *tmp132 false
   464 stop
-    * set *tmp133 null
   465 jump *label112 always
   466 label *label111
-    * set *tmp133 null
   467 label *label112
   468 set :needsFourUnits.2:unit .UNIT_S1
   469 op sub *tmp135 .DOME_X .CORE_X
 
   491 op equal *tmp150 *tmp149 @this
   492 op land *tmp151 *tmp148 *tmp150
   493 jump *label120 equal *tmp151 false
-    * set *tmp144 :rebindUnit.2:currentUnit
   494 jump *label117 always
   495 set *tmp152 null
   496 jump *label121 always
   497 label *label120
   498 set *tmp152 null
   499 label *label121
-    * set *tmp146 *tmp152
   500 jump *label119 always
   501 label *label118
-    * set *tmp146 null
   502 label *label119
   503 ubind .TYPE
   504 set :rebindUnit.2:firstUnit @unit
 
   508 sensor *tmp155 @unit @controlled
   509 op equal *tmp156 *tmp155 0
   510 jump *label127 equal *tmp156 false
-    * set *tmp144 @unit
   511 jump *label117 always
-    * set *tmp157 null
   512 jump *label128 always
   513 label *label127
-    * set *tmp157 null
   514 label *label128
   515 ubind .TYPE
   516 label *label125
 
   520 op land *tmp161 *tmp158 *tmp160
   521 jump *label124 notEqual *tmp161 false
   522 label *label126
-    * set *tmp154 null
   523 jump *label123 always
   524 label *label122
-    * set *tmp154 null
   525 label *label123
   526 end
-    * set *tmp144 null
   527 label *label117
   528 ucontrol flag 1
   529 set *tmp143 @unit
 
   542 op equal *tmp169 *tmp168 @this
   543 op land *tmp170 *tmp167 *tmp169
   544 jump *label133 equal *tmp170 false
-    * set *tmp163 :rebindUnit.3:currentUnit
   545 jump *label130 always
   546 set *tmp171 null
   547 jump *label134 always
   548 label *label133
   549 set *tmp171 null
   550 label *label134
-    * set *tmp165 *tmp171
   551 jump *label132 always
   552 label *label131
-    * set *tmp165 null
   553 label *label132
   554 ubind .TYPE
   555 set :rebindUnit.3:firstUnit @unit
 
   559 sensor *tmp174 @unit @controlled
   560 op equal *tmp175 *tmp174 0
   561 jump *label140 equal *tmp175 false
-    * set *tmp163 @unit
   562 jump *label130 always
-    * set *tmp176 null
   563 jump *label141 always
   564 label *label140
-    * set *tmp176 null
   565 label *label141
   566 ubind .TYPE
   567 label *label138
 
   571 op land *tmp180 *tmp177 *tmp179
   572 jump *label137 notEqual *tmp180 false
   573 label *label139
-    * set *tmp173 null
   574 jump *label136 always
   575 label *label135
-    * set *tmp173 null
   576 label *label136
   577 end
-    * set *tmp163 null
   578 label *label130
   579 ucontrol flag 1
   580 set *tmp162 @unit
 
   596 label *label144
   597 set .UNIT_S1 :swap.1:a
   598 set .UNIT_P2 :swap.1:b
-    * set *tmp186 null
   599 jump *label143 always
   600 label *label142
-    * set *tmp186 null
   601 label *label143
   602 sensor *tmp187 .UNIT_S2 @firstItem
   603 op equal *tmp188 *tmp187 @phase-fabric
 
   613 label *label147
   614 set .UNIT_S2 :swap.2:a
   615 set .UNIT_P2 :swap.2:b
-    * set *tmp192 null
   616 jump *label146 always
   617 label *label145
-    * set *tmp192 null
   618 label *label146
   619 set .GROUP1 "unit  1"
   620 set .GROUP2 "unit 2"
-    * set *tmp142 .GROUP2
   621 jump *label115 always
   622 label *label114
   623 ubind .UNIT_S2
 
   627 ucontrol unbind
   628 set .UNIT_P2 null
   629 set .GROUP1 "unit"
-    * set *tmp142 .GROUP1
   630 label *label115
   631 op equal *tmp193 .FOUR_UNITS false
   632 sensor *tmp194 .UNIT_S1 @totalItems
 
   666 print "["
   667 print "]"
   668 print "\n"
-    * set *tmp207 null
   669 jump *label153 always
   670 label *label152
   671 print "  dome:  [coral]"
 
   673 print "["
   674 print "]"
   675 print "\n"
-    * set *tmp207 null
   676 label *label153
   677 label *label151
   678 set :processUnit.0:unit .UNIT_S1
 
   689 op equal *tmp214 *tmp213 @this
   690 op land *tmp215 *tmp212 *tmp214
   691 jump *label158 equal *tmp215 false
-    * set *tmp208 :rebindUnit.4:currentUnit
   692 jump *label155 always
   693 set *tmp216 null
   694 jump *label159 always
   695 label *label158
   696 set *tmp216 null
   697 label *label159
-    * set *tmp210 *tmp216
   698 jump *label157 always
   699 label *label156
-    * set *tmp210 null
   700 label *label157
   701 ubind .TYPE
   702 set :rebindUnit.4:firstUnit @unit
 
   706 sensor *tmp219 @unit @controlled
   707 op equal *tmp220 *tmp219 0
   708 jump *label165 equal *tmp220 false
-    * set *tmp208 @unit
   709 jump *label155 always
-    * set *tmp221 null
   710 jump *label166 always
   711 label *label165
-    * set *tmp221 null
   712 label *label166
   713 ubind .TYPE
   714 label *label163
 
   718 op land *tmp225 *tmp222 *tmp224
   719 jump *label162 notEqual *tmp225 false
   720 label *label164
-    * set *tmp218 null
   721 jump *label161 always
   722 label *label160
-    * set *tmp218 null
   723 label *label161
   724 end
-    * set *tmp208 null
   725 label *label155
   726 sensor *tmp226 @unit @flag
   727 set :processUnit.0:state *tmp226
 
   759 label *label172
   760 set *tmp233 *tmp236
   761 label *label170
-    * set *tmp230 *tmp233
   762 jump *label168 always
   763 label *label167
-    * set *tmp230 null
   764 label *label168
   765 op equal *tmp239 :processUnit.0:state 2
   766 jump *label175 equal *tmp239 false
 
   793 set :processUnit.0:distance *tmp252
   794 set *tmp242 :processUnit.0:distance
   795 label *label178
-    * set *tmp240 *tmp242
   796 jump *label176 always
   797 label *label175
-    * set *tmp240 null
   798 label *label176
   799 op equal *tmp253 :processUnit.0:state 3
   800 jump *label181 equal *tmp253 false
 
   803 jump *label185 equal :processUnit.0:supply false
   804 ucontrol itemDrop .DOME .UNIT_CAPACITY
   805 set .MSG ", supplying\n"
-    * set *tmp257 .MSG
   806 jump *label186 always
   807 label *label185
   808 ucontrol approach .DOME_X .DOME_Y 6
   809 set .MSG ", waiting\n"
-    * set *tmp257 .MSG
   810 label *label186
   811 sensor *tmp258 @unit @totalItems
   812 op lessThanEq *tmp259 *tmp258 0
 
   833 set :processUnit.0:distance *tmp267
   834 set *tmp256 :processUnit.0:distance
   835 label *label184
-    * set *tmp254 *tmp256
   836 jump *label182 always
   837 label *label181
-    * set *tmp254 null
   838 label *label182
   839 ucontrol flag :processUnit.0:state
   840 sensor *tmp268 @unit @totalItems
 
   854 print "["
   855 print "] sec"
   856 print "\n"
-    * set *tmp270 null
   857 jump *label190 always
   858 label *label189
   859 print .MSG
-    * set *tmp270 .MSG
   860 label *label190
   861 set *tmp271 @unit
   862 set :processUnit.0:unit *tmp271
 
   878 op equal *tmp280 *tmp279 @this
   879 op land *tmp281 *tmp278 *tmp280
   880 jump *label197 equal *tmp281 false
-    * set *tmp274 :rebindUnit.5:currentUnit
   881 jump *label194 always
   882 set *tmp282 null
   883 jump *label198 always
   884 label *label197
   885 set *tmp282 null
   886 label *label198
-    * set *tmp276 *tmp282
   887 jump *label196 always
   888 label *label195
-    * set *tmp276 null
   889 label *label196
   890 ubind .TYPE
   891 set :rebindUnit.5:firstUnit @unit
 
   895 sensor *tmp285 @unit @controlled
   896 op equal *tmp286 *tmp285 0
   897 jump *label204 equal *tmp286 false
-    * set *tmp274 @unit
   898 jump *label194 always
-    * set *tmp287 null
   899 jump *label205 always
   900 label *label204
-    * set *tmp287 null
   901 label *label205
   902 ubind .TYPE
   903 label *label202
 
   907 op land *tmp291 *tmp288 *tmp290
   908 jump *label201 notEqual *tmp291 false
   909 label *label203
-    * set *tmp284 null
   910 jump *label200 always
   911 label *label199
-    * set *tmp284 null
   912 label *label200
   913 end
-    * set *tmp274 null
   914 label *label194
   915 sensor *tmp292 @unit @flag
   916 set :processUnit.1:state *tmp292
 
   948 label *label211
   949 set *tmp299 *tmp302
   950 label *label209
-    * set *tmp296 *tmp299
   951 jump *label207 always
   952 label *label206
-    * set *tmp296 null
   953 label *label207
   954 op equal *tmp305 :processUnit.1:state 2
   955 jump *label214 equal *tmp305 false
 
   982 set :processUnit.1:distance *tmp318
   983 set *tmp308 :processUnit.1:distance
   984 label *label217
-    * set *tmp306 *tmp308
   985 jump *label215 always
   986 label *label214
-    * set *tmp306 null
   987 label *label215
   988 op equal *tmp319 :processUnit.1:state 3
   989 jump *label220 equal *tmp319 false
 
   992 jump *label224 equal :processUnit.1:supply false
   993 ucontrol itemDrop .DOME .UNIT_CAPACITY
   994 set .MSG ", supplying\n"
-    * set *tmp323 .MSG
   995 jump *label225 always
   996 label *label224
   997 ucontrol approach .DOME_X .DOME_Y 6
   998 set .MSG ", waiting\n"
-    * set *tmp323 .MSG
   999 label *label225
  1000 sensor *tmp324 @unit @totalItems
  1001 op lessThanEq *tmp325 *tmp324 0
 
  1022 set :processUnit.1:distance *tmp333
  1023 set *tmp322 :processUnit.1:distance
  1024 label *label223
-    * set *tmp320 *tmp322
  1025 jump *label221 always
  1026 label *label220
-    * set *tmp320 null
  1027 label *label221
  1028 ucontrol flag :processUnit.1:state
  1029 sensor *tmp334 @unit @totalItems
 
  1043 print "["
  1044 print "] sec"
  1045 print "\n"
-    * set *tmp336 null
  1046 jump *label229 always
  1047 label *label228
  1048 print .MSG
-    * set *tmp336 .MSG
  1049 label *label229
  1050 set *tmp337 @unit
  1051 set :processUnit.1:unit *tmp337
 
  1062 set *tmp338 *tmp342
  1063 label *label231
  1064 set .SUPPLY_S_FIRST *tmp338
-    * set *tmp272 .SUPPLY_S_FIRST
  1065 jump *label192 always
  1066 label *label191
-    * set *tmp272 null
  1067 label *label192
  1068 set :printDomeStatus.1:item @phase-fabric
  1069 set :printDomeStatus.1:text "\n[green]Phase fabric[] status:\n"
 
  1077 print "["
  1078 print "]"
  1079 print "\n"
-    * set *tmp345 null
  1080 jump *label234 always
  1081 label *label233
  1082 print "  dome:  [coral]"
 
  1084 print "["
  1085 print "]"
  1086 print "\n"
-    * set *tmp345 null
  1087 label *label234
  1088 label *label232
  1089 set :processUnit.2:unit .UNIT_P1
 
  1100 op equal *tmp352 *tmp351 @this
  1101 op land *tmp353 *tmp350 *tmp352
  1102 jump *label239 equal *tmp353 false
-    * set *tmp346 :rebindUnit.6:currentUnit
  1103 jump *label236 always
  1104 set *tmp354 null
  1105 jump *label240 always
  1106 label *label239
  1107 set *tmp354 null
  1108 label *label240
-    * set *tmp348 *tmp354
  1109 jump *label238 always
  1110 label *label237
-    * set *tmp348 null
  1111 label *label238
  1112 ubind .TYPE
  1113 set :rebindUnit.6:firstUnit @unit
 
  1117 sensor *tmp357 @unit @controlled
  1118 op equal *tmp358 *tmp357 0
  1119 jump *label246 equal *tmp358 false
-    * set *tmp346 @unit
  1120 jump *label236 always
-    * set *tmp359 null
  1121 jump *label247 always
  1122 label *label246
-    * set *tmp359 null
  1123 label *label247
  1124 ubind .TYPE
  1125 label *label244
 
  1129 op land *tmp363 *tmp360 *tmp362
  1130 jump *label243 notEqual *tmp363 false
  1131 label *label245
-    * set *tmp356 null
  1132 jump *label242 always
  1133 label *label241
-    * set *tmp356 null
  1134 label *label242
  1135 end
-    * set *tmp346 null
  1136 label *label236
  1137 sensor *tmp364 @unit @flag
  1138 set :processUnit.2:state *tmp364
 
  1170 label *label253
  1171 set *tmp371 *tmp374
  1172 label *label251
-    * set *tmp368 *tmp371
  1173 jump *label249 always
  1174 label *label248
-    * set *tmp368 null
  1175 label *label249
  1176 op equal *tmp377 :processUnit.2:state 2
  1177 jump *label256 equal *tmp377 false
 
  1204 set :processUnit.2:distance *tmp390
  1205 set *tmp380 :processUnit.2:distance
  1206 label *label259
-    * set *tmp378 *tmp380
  1207 jump *label257 always
  1208 label *label256
-    * set *tmp378 null
  1209 label *label257
  1210 op equal *tmp391 :processUnit.2:state 3
  1211 jump *label262 equal *tmp391 false
 
  1214 jump *label266 equal :processUnit.2:supply false
  1215 ucontrol itemDrop .DOME .UNIT_CAPACITY
  1216 set .MSG ", supplying\n"
-    * set *tmp395 .MSG
  1217 jump *label267 always
  1218 label *label266
  1219 ucontrol approach .DOME_X .DOME_Y 6
  1220 set .MSG ", waiting\n"
-    * set *tmp395 .MSG
  1221 label *label267
  1222 sensor *tmp396 @unit @totalItems
  1223 op lessThanEq *tmp397 *tmp396 0
 
  1244 set :processUnit.2:distance *tmp405
  1245 set *tmp394 :processUnit.2:distance
  1246 label *label265
-    * set *tmp392 *tmp394
  1247 jump *label263 always
  1248 label *label262
-    * set *tmp392 null
  1249 label *label263
  1250 ucontrol flag :processUnit.2:state
  1251 sensor *tmp406 @unit @totalItems
 
  1265 print "["
  1266 print "] sec"
  1267 print "\n"
-    * set *tmp408 null
  1268 jump *label271 always
  1269 label *label270
  1270 print .MSG
-    * set *tmp408 .MSG
  1271 label *label271
  1272 set *tmp409 @unit
  1273 set :processUnit.2:unit *tmp409
 
  1289 op equal *tmp418 *tmp417 @this
  1290 op land *tmp419 *tmp416 *tmp418
  1291 jump *label278 equal *tmp419 false
-    * set *tmp412 :rebindUnit.7:currentUnit
  1292 jump *label275 always
  1293 set *tmp420 null
  1294 jump *label279 always
  1295 label *label278
  1296 set *tmp420 null
  1297 label *label279
-    * set *tmp414 *tmp420
  1298 jump *label277 always
  1299 label *label276
-    * set *tmp414 null
  1300 label *label277
  1301 ubind .TYPE
  1302 set :rebindUnit.7:firstUnit @unit
 
  1306 sensor *tmp423 @unit @controlled
  1307 op equal *tmp424 *tmp423 0
  1308 jump *label285 equal *tmp424 false
-    * set *tmp412 @unit
  1309 jump *label275 always
-    * set *tmp425 null
  1310 jump *label286 always
  1311 label *label285
-    * set *tmp425 null
  1312 label *label286
  1313 ubind .TYPE
  1314 label *label283
 
  1318 op land *tmp429 *tmp426 *tmp428
  1319 jump *label282 notEqual *tmp429 false
  1320 label *label284
-    * set *tmp422 null
  1321 jump *label281 always
  1322 label *label280
-    * set *tmp422 null
  1323 label *label281
  1324 end
-    * set *tmp412 null
  1325 label *label275
  1326 sensor *tmp430 @unit @flag
  1327 set :processUnit.3:state *tmp430
 
  1359 label *label292
  1360 set *tmp437 *tmp440
  1361 label *label290
-    * set *tmp434 *tmp437
  1362 jump *label288 always
  1363 label *label287
-    * set *tmp434 null
  1364 label *label288
  1365 op equal *tmp443 :processUnit.3:state 2
  1366 jump *label295 equal *tmp443 false
 
  1393 set :processUnit.3:distance *tmp456
  1394 set *tmp446 :processUnit.3:distance
  1395 label *label298
-    * set *tmp444 *tmp446
  1396 jump *label296 always
  1397 label *label295
-    * set *tmp444 null
  1398 label *label296
  1399 op equal *tmp457 :processUnit.3:state 3
  1400 jump *label301 equal *tmp457 false
 
  1403 jump *label305 equal :processUnit.3:supply false
  1404 ucontrol itemDrop .DOME .UNIT_CAPACITY
  1405 set .MSG ", supplying\n"
-    * set *tmp461 .MSG
  1406 jump *label306 always
  1407 label *label305
  1408 ucontrol approach .DOME_X .DOME_Y 6
  1409 set .MSG ", waiting\n"
-    * set *tmp461 .MSG
  1410 label *label306
  1411 sensor *tmp462 @unit @totalItems
  1412 op lessThanEq *tmp463 *tmp462 0
 
  1433 set :processUnit.3:distance *tmp471
  1434 set *tmp460 :processUnit.3:distance
  1435 label *label304
-    * set *tmp458 *tmp460
  1436 jump *label302 always
  1437 label *label301
-    * set *tmp458 null
  1438 label *label302
  1439 ucontrol flag :processUnit.3:state
  1440 sensor *tmp472 @unit @totalItems
 
  1454 print "["
  1455 print "] sec"
  1456 print "\n"
-    * set *tmp474 null
  1457 jump *label310 always
  1458 label *label309
  1459 print .MSG
-    * set *tmp474 .MSG
  1460 label *label310
  1461 set *tmp475 @unit
  1462 set :processUnit.3:unit *tmp475
 
  1473 set *tmp476 *tmp480
  1474 label *label312
  1475 set .SUPPLY_P_FIRST *tmp476
-    * set *tmp410 .SUPPLY_P_FIRST
  1476 jump *label273 always
  1477 label *label272
-    * set *tmp410 null
  1478 label *label273
  1479 op sub *tmp481 @time :start
  1480 op floor *tmp482 *tmp481
 
  1534 label *label326
  1535 set *tmp506 null
  1536 label *label327
-    * set *tmp504 *tmp506
  1537 jump *label325 always
  1538 label *label324
  1539 set *tmp507 :areUnitsAvailable.2:occupied
  1540 op add :areUnitsAvailable.2:occupied :areUnitsAvailable.2:occupied 1
-    * set *tmp504 *tmp507
  1541 label *label325
  1542 ubind :areUnitsAvailable.2:type
  1543 label *label322
 
  1547 op land *tmp511 *tmp508 *tmp510
  1548 jump *label321 notEqual *tmp511 false
  1549 label *label323
-    * set *tmp489 null
  1550 jump *label317 always
  1551 label *label316
-    * set *tmp489 null
  1552 label *label317
  1553 jump *label328 equal :areUnitsAvailable.2:output false
  1554 print :areUnitsAvailable.2:type
 
  1562 jump *label330 equal *tmp513 false
  1563 print ", needed: "
  1564 print :areUnitsAvailable.2:needed
-    * set *tmp514 null
  1565 jump *label331 always
  1566 label *label330
-    * set *tmp514 null
  1567 label *label331
  1568 print "\n"
-    * set *tmp512 null
  1569 jump *label329 always
  1570 label *label328
-    * set *tmp512 null
  1571 label *label329
  1572 set *tmp487 false
  1573 jump *label315 always
 
  1575 label *label315
  1576 jump *label332 equal *tmp487 false
  1577 end
-    * set *tmp515 null
  1578 jump *label333 always
  1579 label *label332
-    * set *tmp515 null
  1580 label *label333
  1581 op add *tmp516 @time 5000
  1582 set :unitCheck *tmp516
-    * set *tmp486 :unitCheck
  1583 jump *label314 always
  1584 label *label313
-    * set *tmp486 null
  1585 label *label314
  1586 label *label149
  1587 jump *label148 always
 
  1597 jump *label335 equal *tmp521 false
  1598 ulocate building core false @copper *tmp524 *tmp525 *tmp526 *tmp523
  1599 set .CORE *tmp523
-    * set *tmp522 .CORE
  1600 jump *label336 always
  1601 label *label335
-    * set *tmp522 null
  1602 label *label336
  1603 set :locateCore.0*retval .CORE
  1604 label *label334

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-53 instructions):
 
   112 jump *label36 equal *tmp28 false
   113 set *tmp10 true
   114 jump *label25 always
-    * set *tmp29 null
   115 jump *label37 always
   116 label *label36
-    * set *tmp29 null
   117 label *label37
   118 jump *label35 always
   119 label *label34
-    * set *tmp30 :areUnitsAvailable.0:occupied
   120 op add :areUnitsAvailable.0:occupied :areUnitsAvailable.0:occupied 1
   121 label *label35
   122 ubind :areUnitsAvailable.0:type
 
   217 jump *label64 equal *tmp60 false
   218 set *tmp42 true
   219 jump *label53 always
-    * set *tmp61 null
   220 jump *label65 always
   221 label *label64
-    * set *tmp61 null
   222 label *label65
   223 jump *label63 always
   224 label *label62
-    * set *tmp62 :areUnitsAvailable.1:occupied
   225 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   226 label *label63
   227 ubind :areUnitsAvailable.1:type
 
   262 printflush null
   263 set *tmp9 :chooseUnitType.0:type
   264 jump *label21 always
-    * set *tmp70 null
   265 jump *label71 always
   266 label *label70
-    * set *tmp70 null
   267 label *label71
   268 jump *label52 always
   269 label *label51
 
   308 op notEqual *tmp79 .UNIT_S2 null
   309 jump *label80 equal *tmp79 false
   310 jump *label77 always
-    * set *tmp80 null
   311 jump *label81 always
   312 label *label80
-    * set *tmp80 null
   313 label *label81
   314 jump *label79 always
   315 label *label78
 
   336 op land *tmp93 *tmp90 *tmp92
   337 jump *label86 equal *tmp93 false
   338 jump *label83 always
-    * set *tmp94 null
   339 jump *label87 always
   340 label *label86
-    * set *tmp94 null
   341 label *label87
   342 jump *label85 always
   343 label *label84
 
   385 op land *tmp112 *tmp109 *tmp111
   386 jump *label99 equal *tmp112 false
   387 jump *label96 always
-    * set *tmp113 null
   388 jump *label100 always
   389 label *label99
-    * set *tmp113 null
   390 label *label100
   391 jump *label98 always
   392 label *label97
 
   478 op land *tmp151 *tmp148 *tmp150
   479 jump *label120 equal *tmp151 false
   480 jump *label117 always
-    * set *tmp152 null
   481 jump *label121 always
   482 label *label120
-    * set *tmp152 null
   483 label *label121
   484 jump *label119 always
   485 label *label118
 
   527 op land *tmp170 *tmp167 *tmp169
   528 jump *label133 equal *tmp170 false
   529 jump *label130 always
-    * set *tmp171 null
   530 jump *label134 always
   531 label *label133
-    * set *tmp171 null
   532 label *label134
   533 jump *label132 always
   534 label *label131
 
   672 op land *tmp215 *tmp212 *tmp214
   673 jump *label158 equal *tmp215 false
   674 jump *label155 always
-    * set *tmp216 null
   675 jump *label159 always
   676 label *label158
-    * set *tmp216 null
   677 label *label159
   678 jump *label157 always
   679 label *label156
 
   715 op equal *tmp232 *tmp231 :processUnit.0:item
   716 jump *label169 equal *tmp232 false
   717 set :processUnit.0:state 3
-    * set *tmp233 :processUnit.0:state
   718 jump *label170 always
   719 label *label169
   720 sensor *tmp234 @unit @totalItems
 
   736 label *label174
   737 set *tmp236 *tmp238
   738 label *label172
-    * set *tmp233 *tmp236
   739 label *label170
   740 jump *label168 always
   741 label *label167
 
   756 set .MSG ", loading\n"
   757 set *tmp245 .MSG
   758 label *label180
-    * set *tmp242 *tmp245
   759 jump *label178 always
   760 label *label177
   761 ucontrol approach .CORE_X .CORE_Y 6
 
   768 op idiv *tmp251 *tmp250 .SPEED_TENTHS
   769 op div *tmp252 *tmp251 10
   770 set :processUnit.0:distance *tmp252
-    * set *tmp242 :processUnit.0:distance
   771 label *label178
   772 jump *label176 always
   773 label *label175
 
   794 label *label187
   795 set *tmp260 null
   796 label *label188
-    * set *tmp256 *tmp260
   797 jump *label184 always
   798 label *label183
   799 ucontrol approach .DOME_X .DOME_Y 6
 
   806 op idiv *tmp266 *tmp265 .SPEED_TENTHS
   807 op div *tmp267 *tmp266 10
   808 set :processUnit.0:distance *tmp267
-    * set *tmp256 :processUnit.0:distance
   809 label *label184
   810 jump *label182 always
   811 label *label181
 
   853 op land *tmp281 *tmp278 *tmp280
   854 jump *label197 equal *tmp281 false
   855 jump *label194 always
-    * set *tmp282 null
   856 jump *label198 always
   857 label *label197
-    * set *tmp282 null
   858 label *label198
   859 jump *label196 always
   860 label *label195
 
   896 op equal *tmp298 *tmp297 :processUnit.1:item
   897 jump *label208 equal *tmp298 false
   898 set :processUnit.1:state 3
-    * set *tmp299 :processUnit.1:state
   899 jump *label209 always
   900 label *label208
   901 sensor *tmp300 @unit @totalItems
 
   917 label *label213
   918 set *tmp302 *tmp304
   919 label *label211
-    * set *tmp299 *tmp302
   920 label *label209
   921 jump *label207 always
   922 label *label206
 
   937 set .MSG ", loading\n"
   938 set *tmp311 .MSG
   939 label *label219
-    * set *tmp308 *tmp311
   940 jump *label217 always
   941 label *label216
   942 ucontrol approach .CORE_X .CORE_Y 6
 
   949 op idiv *tmp317 *tmp316 .SPEED_TENTHS
   950 op div *tmp318 *tmp317 10
   951 set :processUnit.1:distance *tmp318
-    * set *tmp308 :processUnit.1:distance
   952 label *label217
   953 jump *label215 always
   954 label *label214
 
   975 label *label226
   976 set *tmp326 null
   977 label *label227
-    * set *tmp322 *tmp326
   978 jump *label223 always
   979 label *label222
   980 ucontrol approach .DOME_X .DOME_Y 6
 
   987 op idiv *tmp332 *tmp331 .SPEED_TENTHS
   988 op div *tmp333 *tmp332 10
   989 set :processUnit.1:distance *tmp333
-    * set *tmp322 :processUnit.1:distance
   990 label *label223
   991 jump *label221 always
   992 label *label220
 
  1067 op land *tmp353 *tmp350 *tmp352
  1068 jump *label239 equal *tmp353 false
  1069 jump *label236 always
-    * set *tmp354 null
  1070 jump *label240 always
  1071 label *label239
-    * set *tmp354 null
  1072 label *label240
  1073 jump *label238 always
  1074 label *label237
 
  1110 op equal *tmp370 *tmp369 :processUnit.2:item
  1111 jump *label250 equal *tmp370 false
  1112 set :processUnit.2:state 3
-    * set *tmp371 :processUnit.2:state
  1113 jump *label251 always
  1114 label *label250
  1115 sensor *tmp372 @unit @totalItems
 
  1131 label *label255
  1132 set *tmp374 *tmp376
  1133 label *label253
-    * set *tmp371 *tmp374
  1134 label *label251
  1135 jump *label249 always
  1136 label *label248
 
  1151 set .MSG ", loading\n"
  1152 set *tmp383 .MSG
  1153 label *label261
-    * set *tmp380 *tmp383
  1154 jump *label259 always
  1155 label *label258
  1156 ucontrol approach .CORE_X .CORE_Y 6
 
  1163 op idiv *tmp389 *tmp388 .SPEED_TENTHS
  1164 op div *tmp390 *tmp389 10
  1165 set :processUnit.2:distance *tmp390
-    * set *tmp380 :processUnit.2:distance
  1166 label *label259
  1167 jump *label257 always
  1168 label *label256
 
  1189 label *label268
  1190 set *tmp398 null
  1191 label *label269
-    * set *tmp394 *tmp398
  1192 jump *label265 always
  1193 label *label264
  1194 ucontrol approach .DOME_X .DOME_Y 6
 
  1201 op idiv *tmp404 *tmp403 .SPEED_TENTHS
  1202 op div *tmp405 *tmp404 10
  1203 set :processUnit.2:distance *tmp405
-    * set *tmp394 :processUnit.2:distance
  1204 label *label265
  1205 jump *label263 always
  1206 label *label262
 
  1248 op land *tmp419 *tmp416 *tmp418
  1249 jump *label278 equal *tmp419 false
  1250 jump *label275 always
-    * set *tmp420 null
  1251 jump *label279 always
  1252 label *label278
-    * set *tmp420 null
  1253 label *label279
  1254 jump *label277 always
  1255 label *label276
 
  1291 op equal *tmp436 *tmp435 :processUnit.3:item
  1292 jump *label289 equal *tmp436 false
  1293 set :processUnit.3:state 3
-    * set *tmp437 :processUnit.3:state
  1294 jump *label290 always
  1295 label *label289
  1296 sensor *tmp438 @unit @totalItems
 
  1312 label *label294
  1313 set *tmp440 *tmp442
  1314 label *label292
-    * set *tmp437 *tmp440
  1315 label *label290
  1316 jump *label288 always
  1317 label *label287
 
  1332 set .MSG ", loading\n"
  1333 set *tmp449 .MSG
  1334 label *label300
-    * set *tmp446 *tmp449
  1335 jump *label298 always
  1336 label *label297
  1337 ucontrol approach .CORE_X .CORE_Y 6
 
  1344 op idiv *tmp455 *tmp454 .SPEED_TENTHS
  1345 op div *tmp456 *tmp455 10
  1346 set :processUnit.3:distance *tmp456
-    * set *tmp446 :processUnit.3:distance
  1347 label *label298
  1348 jump *label296 always
  1349 label *label295
 
  1370 label *label307
  1371 set *tmp464 null
  1372 label *label308
-    * set *tmp460 *tmp464
  1373 jump *label304 always
  1374 label *label303
  1375 ucontrol approach .DOME_X .DOME_Y 6
 
  1382 op idiv *tmp470 *tmp469 .SPEED_TENTHS
  1383 op div *tmp471 *tmp470 10
  1384 set :processUnit.3:distance *tmp471
-    * set *tmp460 :processUnit.3:distance
  1385 label *label304
  1386 jump *label302 always
  1387 label *label301
 
  1479 jump *label326 equal *tmp505 false
  1480 set *tmp487 true
  1481 jump *label315 always
-    * set *tmp506 null
  1482 jump *label327 always
  1483 label *label326
-    * set *tmp506 null
  1484 label *label327
  1485 jump *label325 always
  1486 label *label324
-    * set *tmp507 :areUnitsAvailable.2:occupied
  1487 op add :areUnitsAvailable.2:occupied :areUnitsAvailable.2:occupied 1
  1488 label *label325
  1489 ubind :areUnitsAvailable.2:type

Modifications by Initial phase, Dead Code Elimination, iteration 3 (-24 instructions):
 
   721 op equal *tmp235 *tmp234 0
   722 jump *label171 equal *tmp235 false
   723 set :processUnit.0:state 2
-    * set *tmp236 :processUnit.0:state
   724 jump *label172 always
   725 label *label171
   726 set .MSG ", initializing\n"
 
   733 label *label173
   734 set *tmp238 null
   735 label *label174
-    * set *tmp236 *tmp238
   736 label *label172
   737 label *label170
   738 jump *label168 always
 
   748 jump *label179 equal *tmp244 false
   749 ucontrol approach .DOME_X .DOME_Y 6
   750 set :processUnit.0:state 3
-    * set *tmp245 :processUnit.0:state
   751 jump *label180 always
   752 label *label179
   753 set .MSG ", loading\n"
-    * set *tmp245 .MSG
   754 label *label180
   755 jump *label178 always
   756 label *label177
 
   785 jump *label187 equal *tmp259 false
   786 ucontrol approach .CORE_X .CORE_Y 6
   787 set :processUnit.0:state 2
-    * set *tmp260 :processUnit.0:state
   788 jump *label188 always
   789 label *label187
-    * set *tmp260 null
   790 label *label188
   791 jump *label184 always
   792 label *label183
 
   896 op equal *tmp301 *tmp300 0
   897 jump *label210 equal *tmp301 false
   898 set :processUnit.1:state 2
-    * set *tmp302 :processUnit.1:state
   899 jump *label211 always
   900 label *label210
   901 set .MSG ", initializing\n"
 
   908 label *label212
   909 set *tmp304 null
   910 label *label213
-    * set *tmp302 *tmp304
   911 label *label211
   912 label *label209
   913 jump *label207 always
 
   923 jump *label218 equal *tmp310 false
   924 ucontrol approach .DOME_X .DOME_Y 6
   925 set :processUnit.1:state 3
-    * set *tmp311 :processUnit.1:state
   926 jump *label219 always
   927 label *label218
   928 set .MSG ", loading\n"
-    * set *tmp311 .MSG
   929 label *label219
   930 jump *label217 always
   931 label *label216
 
   960 jump *label226 equal *tmp325 false
   961 ucontrol approach .CORE_X .CORE_Y 6
   962 set :processUnit.1:state 2
-    * set *tmp326 :processUnit.1:state
   963 jump *label227 always
   964 label *label226
-    * set *tmp326 null
   965 label *label227
   966 jump *label223 always
   967 label *label222
 
  1104 op equal *tmp373 *tmp372 0
  1105 jump *label252 equal *tmp373 false
  1106 set :processUnit.2:state 2
-    * set *tmp374 :processUnit.2:state
  1107 jump *label253 always
  1108 label *label252
  1109 set .MSG ", initializing\n"
 
  1116 label *label254
  1117 set *tmp376 null
  1118 label *label255
-    * set *tmp374 *tmp376
  1119 label *label253
  1120 label *label251
  1121 jump *label249 always
 
  1131 jump *label260 equal *tmp382 false
  1132 ucontrol approach .DOME_X .DOME_Y 6
  1133 set :processUnit.2:state 3
-    * set *tmp383 :processUnit.2:state
  1134 jump *label261 always
  1135 label *label260
  1136 set .MSG ", loading\n"
-    * set *tmp383 .MSG
  1137 label *label261
  1138 jump *label259 always
  1139 label *label258
 
  1168 jump *label268 equal *tmp397 false
  1169 ucontrol approach .CORE_X .CORE_Y 6
  1170 set :processUnit.2:state 2
-    * set *tmp398 :processUnit.2:state
  1171 jump *label269 always
  1172 label *label268
-    * set *tmp398 null
  1173 label *label269
  1174 jump *label265 always
  1175 label *label264
 
  1279 op equal *tmp439 *tmp438 0
  1280 jump *label291 equal *tmp439 false
  1281 set :processUnit.3:state 2
-    * set *tmp440 :processUnit.3:state
  1282 jump *label292 always
  1283 label *label291
  1284 set .MSG ", initializing\n"
 
  1291 label *label293
  1292 set *tmp442 null
  1293 label *label294
-    * set *tmp440 *tmp442
  1294 label *label292
  1295 label *label290
  1296 jump *label288 always
 
  1306 jump *label299 equal *tmp448 false
  1307 ucontrol approach .DOME_X .DOME_Y 6
  1308 set :processUnit.3:state 3
-    * set *tmp449 :processUnit.3:state
  1309 jump *label300 always
  1310 label *label299
  1311 set .MSG ", loading\n"
-    * set *tmp449 .MSG
  1312 label *label300
  1313 jump *label298 always
  1314 label *label297
 
  1343 jump *label307 equal *tmp463 false
  1344 ucontrol approach .CORE_X .CORE_Y 6
  1345 set :processUnit.3:state 2
-    * set *tmp464 :processUnit.3:state
  1346 jump *label308 always
  1347 label *label307
-    * set *tmp464 null
  1348 label *label308
  1349 jump *label304 always
  1350 label *label303

Modifications by Initial phase, Dead Code Elimination, iteration 4 (-8 instructions):
 
   728 ucontrol within .CORE_X .CORE_Y 8 *tmp237
   729 jump *label173 equal *tmp237 false
   730 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * set *tmp238 null
   731 jump *label174 always
   732 label *label173
-    * set *tmp238 null
   733 label *label174
   734 label *label172
   735 label *label170
 
   901 ucontrol within .CORE_X .CORE_Y 8 *tmp303
   902 jump *label212 equal *tmp303 false
   903 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * set *tmp304 null
   904 jump *label213 always
   905 label *label212
-    * set *tmp304 null
   906 label *label213
   907 label *label211
   908 label *label209
 
  1107 ucontrol within .CORE_X .CORE_Y 8 *tmp375
  1108 jump *label254 equal *tmp375 false
  1109 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * set *tmp376 null
  1110 jump *label255 always
  1111 label *label254
-    * set *tmp376 null
  1112 label *label255
  1113 label *label253
  1114 label *label251
 
  1280 ucontrol within .CORE_X .CORE_Y 8 *tmp441
  1281 jump *label293 equal *tmp441 false
  1282 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * set *tmp442 null
  1283 jump *label294 always
  1284 label *label293
-    * set *tmp442 null
  1285 label *label294
  1286 label *label292
  1287 label *label290

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-43 instructions):
 
    48 jump *label5 always
    49 label *label7
    50 label *label1
-    * sensor *tmp3 .CORE @x
-    * set .CORE_X *tmp3
-    * sensor *tmp4 .CORE @y
-    * set .CORE_Y *tmp4
-    * sensor *tmp5 .DOME @x
-    * set .DOME_X *tmp5
-    * sensor *tmp6 .DOME @y
-    * set .DOME_Y *tmp6
+   51 sensor .CORE_X .CORE @x
+   52 sensor .CORE_Y .CORE @y
+   53 sensor .DOME_X .DOME @x
+   54 sensor .DOME_Y .DOME @y
    55 label *label18
    56 sensor *tmp7 switch1 @enabled
    57 op equal *tmp8 *tmp7 false
 
    82 op len *tmp16 *tmp14 *tmp15
    83 op mul *tmp17 2 *tmp16
    84 sensor *tmp18 :needsFourUnits.0:unit @speed
-    * op div *tmp19 *tmp17 *tmp18
-    * set :needsFourUnits.0:travel_time *tmp19
-    * op greaterThanEq *tmp20 :needsFourUnits.0:travel_time 47
-    * set *tmp13 *tmp20
+   85 op div :needsFourUnits.0:travel_time *tmp17 *tmp18
+   86 op greaterThanEq *tmp13 :needsFourUnits.0:travel_time 47
    87 jump *label28 always
    88 set *tmp13 null
    89 label *label28
 
   185 op len *tmp48 *tmp46 *tmp47
   186 op mul *tmp49 2 *tmp48
   187 sensor *tmp50 :needsFourUnits.1:unit @speed
-    * op div *tmp51 *tmp49 *tmp50
-    * set :needsFourUnits.1:travel_time *tmp51
-    * op greaterThanEq *tmp52 :needsFourUnits.1:travel_time 47
-    * set *tmp45 *tmp52
+  188 op div :needsFourUnits.1:travel_time *tmp49 *tmp50
+  189 op greaterThanEq *tmp45 :needsFourUnits.1:travel_time 47
   190 jump *label56 always
   191 set *tmp45 null
   192 label *label56
 
   295 set .UNIT_S2 .UNIT_P2
   296 set .UNIT_P2 .UNIT_S1
   297 set .UNIT_S1 .UNIT_P1
-    * set *tmp78 @unit
-    * set .UNIT_P1 *tmp78
+  298 set .UNIT_P1 @unit
   299 op notEqual *tmp79 .UNIT_S2 null
   300 jump *label80 equal *tmp79 false
   301 jump *label77 always
 
   430 jump *label109 always
   431 label *label108
   432 label *label109
-    * sensor *tmp129 .UNIT_S1 @itemCapacity
-    * set .UNIT_CAPACITY *tmp129
-    * sensor *tmp130 .UNIT_S1 @speed
-    * set .SPEED *tmp130
-    * op div *tmp131 .SPEED 10
-    * set .SPEED_TENTHS *tmp131
+  433 sensor .UNIT_CAPACITY .UNIT_S1 @itemCapacity
+  434 sensor .SPEED .UNIT_S1 @speed
+  435 op div .SPEED_TENTHS .SPEED 10
   436 op strictEqual *tmp132 .SPEED null
   437 jump *label111 equal *tmp132 false
   438 stop
 
   445 op len *tmp137 *tmp135 *tmp136
   446 op mul *tmp138 2 *tmp137
   447 sensor *tmp139 :needsFourUnits.2:unit @speed
-    * op div *tmp140 *tmp138 *tmp139
-    * set :needsFourUnits.2:travel_time *tmp140
-    * op greaterThanEq *tmp141 :needsFourUnits.2:travel_time 47
-    * set *tmp134 *tmp141
+  448 op div :needsFourUnits.2:travel_time *tmp138 *tmp139
+  449 op greaterThanEq *tmp134 :needsFourUnits.2:travel_time 47
   450 jump *label113 always
   451 set *tmp134 null
   452 label *label113
 
   600 sensor *tmp194 .UNIT_S1 @totalItems
   601 sensor *tmp195 .UNIT_S2 @totalItems
   602 op lessThan *tmp196 *tmp194 *tmp195
-    * op or *tmp197 *tmp193 *tmp196
-    * set .SUPPLY_S_FIRST *tmp197
+  603 op or .SUPPLY_S_FIRST *tmp193 *tmp196
   604 op equal *tmp198 .FOUR_UNITS false
   605 sensor *tmp199 .UNIT_P1 @totalItems
   606 sensor *tmp200 .UNIT_P2 @totalItems
   607 op lessThan *tmp201 *tmp199 *tmp200
-    * op or *tmp202 *tmp198 *tmp201
-    * set .SUPPLY_P_FIRST *tmp202
-    * op add *tmp203 @time 5000
-    * set :unitCheck *tmp203
+  608 op or .SUPPLY_P_FIRST *tmp198 *tmp201
+  609 op add :unitCheck @time 5000
   610 label *label148
   611 sensor *tmp204 switch1 @enabled
   612 jump *label150 equal *tmp204 false
 
   622 set :printDomeStatus.0:item @silicon
   623 set :printDomeStatus.0:text "\n[green]Silicon[] status:\n"
   624 print :printDomeStatus.0:text
-    * sensor *tmp205 .DOME :printDomeStatus.0:item
-    * set :printDomeStatus.0:level *tmp205
+  625 sensor :printDomeStatus.0:level .DOME :printDomeStatus.0:item
   626 op greaterThan *tmp206 :printDomeStatus.0:level 3
   627 jump *label152 equal *tmp206 false
   628 print "  dome:  [green]"
 
   685 label *label161
   686 end
   687 label *label155
-    * sensor *tmp226 @unit @flag
-    * set :processUnit.0:state *tmp226
+  688 sensor :processUnit.0:state @unit @flag
   689 set :processUnit.0:distance -1
   690 set :processUnit.0:color "gold"
   691 op lessThan *tmp227 :processUnit.0:state 2
 
   741 op sub *tmp249 .CORE_Y *tmp248
   742 op len *tmp250 *tmp247 *tmp249
   743 op idiv *tmp251 *tmp250 .SPEED_TENTHS
-    * op div *tmp252 *tmp251 10
-    * set :processUnit.0:distance *tmp252
+  744 op div :processUnit.0:distance *tmp251 10
   745 label *label178
   746 jump *label176 always
   747 label *label175
 
   776 op sub *tmp264 .DOME_Y *tmp263
   777 op len *tmp265 *tmp262 *tmp264
   778 op idiv *tmp266 *tmp265 .SPEED_TENTHS
-    * op div *tmp267 *tmp266 10
-    * set :processUnit.0:distance *tmp267
+  779 op div :processUnit.0:distance *tmp266 10
   780 label *label184
   781 jump *label182 always
   782 label *label181
 
   803 label *label189
   804 print .MSG
   805 label *label190
-    * set *tmp271 @unit
-    * set :processUnit.0:unit *tmp271
+  806 set :processUnit.0:unit @unit
   807 label *label154
   808 set .UNIT_S1 :processUnit.0:unit
   809 jump *label191 equal .FOUR_UNITS false
 
   854 label *label200
   855 end
   856 label *label194
-    * sensor *tmp292 @unit @flag
-    * set :processUnit.1:state *tmp292
+  857 sensor :processUnit.1:state @unit @flag
   858 set :processUnit.1:distance -1
   859 set :processUnit.1:color "gold"
   860 op lessThan *tmp293 :processUnit.1:state 2
 
   910 op sub *tmp315 .CORE_Y *tmp314
   911 op len *tmp316 *tmp313 *tmp315
   912 op idiv *tmp317 *tmp316 .SPEED_TENTHS
-    * op div *tmp318 *tmp317 10
-    * set :processUnit.1:distance *tmp318
+  913 op div :processUnit.1:distance *tmp317 10
   914 label *label217
   915 jump *label215 always
   916 label *label214
 
   945 op sub *tmp330 .DOME_Y *tmp329
   946 op len *tmp331 *tmp328 *tmp330
   947 op idiv *tmp332 *tmp331 .SPEED_TENTHS
-    * op div *tmp333 *tmp332 10
-    * set :processUnit.1:distance *tmp333
+  948 op div :processUnit.1:distance *tmp332 10
   949 label *label223
   950 jump *label221 always
   951 label *label220
 
   972 label *label228
   973 print .MSG
   974 label *label229
-    * set *tmp337 @unit
-    * set :processUnit.1:unit *tmp337
+  975 set :processUnit.1:unit @unit
   976 label *label193
   977 set .UNIT_S2 :processUnit.1:unit
   978 jump *label230 equal .SUPPLY_S_FIRST false
   979 sensor *tmp339 .UNIT_S1 @totalItems
-    * op greaterThan *tmp340 *tmp339 0
-    * set *tmp338 *tmp340
+  980 op greaterThan *tmp338 *tmp339 0
   981 jump *label231 always
   982 label *label230
   983 sensor *tmp341 .UNIT_S2 @totalItems
-    * op equal *tmp342 *tmp341 0
-    * set *tmp338 *tmp342
+  984 op equal *tmp338 *tmp341 0
   985 label *label231
   986 set .SUPPLY_S_FIRST *tmp338
   987 jump *label192 always
 
   990 set :printDomeStatus.1:item @phase-fabric
   991 set :printDomeStatus.1:text "\n[green]Phase fabric[] status:\n"
   992 print :printDomeStatus.1:text
-    * sensor *tmp343 .DOME :printDomeStatus.1:item
-    * set :printDomeStatus.1:level *tmp343
+  993 sensor :printDomeStatus.1:level .DOME :printDomeStatus.1:item
   994 op greaterThan *tmp344 :printDomeStatus.1:level 3
   995 jump *label233 equal *tmp344 false
   996 print "  dome:  [green]"
 
  1053 label *label242
  1054 end
  1055 label *label236
-    * sensor *tmp364 @unit @flag
-    * set :processUnit.2:state *tmp364
+ 1056 sensor :processUnit.2:state @unit @flag
  1057 set :processUnit.2:distance -1
  1058 set :processUnit.2:color "gold"
  1059 op lessThan *tmp365 :processUnit.2:state 2
 
  1109 op sub *tmp387 .CORE_Y *tmp386
  1110 op len *tmp388 *tmp385 *tmp387
  1111 op idiv *tmp389 *tmp388 .SPEED_TENTHS
-    * op div *tmp390 *tmp389 10
-    * set :processUnit.2:distance *tmp390
+ 1112 op div :processUnit.2:distance *tmp389 10
  1113 label *label259
  1114 jump *label257 always
  1115 label *label256
 
  1144 op sub *tmp402 .DOME_Y *tmp401
  1145 op len *tmp403 *tmp400 *tmp402
  1146 op idiv *tmp404 *tmp403 .SPEED_TENTHS
-    * op div *tmp405 *tmp404 10
-    * set :processUnit.2:distance *tmp405
+ 1147 op div :processUnit.2:distance *tmp404 10
  1148 label *label265
  1149 jump *label263 always
  1150 label *label262
 
  1171 label *label270
  1172 print .MSG
  1173 label *label271
-    * set *tmp409 @unit
-    * set :processUnit.2:unit *tmp409
+ 1174 set :processUnit.2:unit @unit
  1175 label *label235
  1176 set .UNIT_P1 :processUnit.2:unit
  1177 jump *label272 equal .FOUR_UNITS false
 
  1222 label *label281
  1223 end
  1224 label *label275
-    * sensor *tmp430 @unit @flag
-    * set :processUnit.3:state *tmp430
+ 1225 sensor :processUnit.3:state @unit @flag
  1226 set :processUnit.3:distance -1
  1227 set :processUnit.3:color "gold"
  1228 op lessThan *tmp431 :processUnit.3:state 2
 
  1278 op sub *tmp453 .CORE_Y *tmp452
  1279 op len *tmp454 *tmp451 *tmp453
  1280 op idiv *tmp455 *tmp454 .SPEED_TENTHS
-    * op div *tmp456 *tmp455 10
-    * set :processUnit.3:distance *tmp456
+ 1281 op div :processUnit.3:distance *tmp455 10
  1282 label *label298
  1283 jump *label296 always
  1284 label *label295
 
  1313 op sub *tmp468 .DOME_Y *tmp467
  1314 op len *tmp469 *tmp466 *tmp468
  1315 op idiv *tmp470 *tmp469 .SPEED_TENTHS
-    * op div *tmp471 *tmp470 10
-    * set :processUnit.3:distance *tmp471
+ 1316 op div :processUnit.3:distance *tmp470 10
  1317 label *label304
  1318 jump *label302 always
  1319 label *label301
 
  1340 label *label309
  1341 print .MSG
  1342 label *label310
-    * set *tmp475 @unit
-    * set :processUnit.3:unit *tmp475
+ 1343 set :processUnit.3:unit @unit
  1344 label *label274
  1345 set .UNIT_P2 :processUnit.3:unit
  1346 jump *label311 equal .SUPPLY_P_FIRST false
  1347 sensor *tmp477 .UNIT_P1 @totalItems
-    * op greaterThan *tmp478 *tmp477 0
-    * set *tmp476 *tmp478
+ 1348 op greaterThan *tmp476 *tmp477 0
  1349 jump *label312 always
  1350 label *label311
  1351 sensor *tmp479 .UNIT_P2 @totalItems
-    * op equal *tmp480 *tmp479 0
-    * set *tmp476 *tmp480
+ 1352 op equal *tmp476 *tmp479 0
  1353 label *label312
  1354 set .SUPPLY_P_FIRST *tmp476
  1355 jump *label273 always
 
  1382 op len *tmp493 *tmp491 *tmp492
  1383 op mul *tmp494 2 *tmp493
  1384 sensor *tmp495 :needsFourUnits.3:unit @speed
-    * op div *tmp496 *tmp494 *tmp495
-    * set :needsFourUnits.3:travel_time *tmp496
-    * op greaterThanEq *tmp497 :needsFourUnits.3:travel_time 47
-    * set *tmp490 *tmp497
+ 1385 op div :needsFourUnits.3:travel_time *tmp494 *tmp495
+ 1386 op greaterThanEq *tmp490 :needsFourUnits.3:travel_time 47
  1387 jump *label318 always
  1388 set *tmp490 null
  1389 label *label318
 
  1452 jump *label333 always
  1453 label *label332
  1454 label *label333
-    * op add *tmp516 @time 5000
-    * set :unitCheck *tmp516
+ 1455 op add :unitCheck @time 5000
  1456 jump *label314 always
  1457 label *label313
  1458 label *label314
 
  1468 op equal *tmp520 *tmp519 @this
  1469 op or *tmp521 *tmp518 *tmp520
  1470 jump *label335 equal *tmp521 false
-    * ulocate building core false @copper *tmp524 *tmp525 *tmp526 *tmp523
-    * set .CORE *tmp523
+ 1471 ulocate building core false @copper 0 0 0 .CORE
  1472 jump *label336 always
  1473 label *label335
  1474 label *label336

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-2 instructions):
 
    15 printflush message1
    16 set .CORE null
    17 label *label5
-    * jump *label7 equal true false
    18 setaddr *tmp1 *label11
    19 set :locateDomeAndCore.0:type @flare
    20 jump *label8 always
 
    62 jump *label18 always
    63 label *label20
    64 label *label22
-    * jump *label24 equal true false
    65 printflush null
    66 print "[gold]Looking for suitable unit type:[]"
    67 print "\n"

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-69 instructions):
 
     3 remark "Do not modify anything below this line."
     4 set .DOME dome1
     5 label *label2
-    * op equal *tmp0 .DOME null
-    * jump *label4 equal *tmp0 false
+    6 jump *label4 notEqual .DOME null
     7 print "[gold]Waiting for an overdrive dome to be connected..."
     8 printflush message1
     9 set .DOME dome1
 
    52 sensor .DOME_Y .DOME @y
    53 label *label18
    54 sensor *tmp7 switch1 @enabled
-    * op equal *tmp8 *tmp7 false
-    * jump *label20 equal *tmp8 false
+   55 jump *label20 notEqual *tmp7 false
    56 print "[coral]Activate switch to begin supplying overdrive dome..."
    57 print "\n"
    58 printflush message1
 
    70 set :areUnitsAvailable.0:needed 0
    71 ubind :areUnitsAvailable.0:type
    72 set :areUnitsAvailable.0:firstUnit @unit
-    * op notEqual *tmp11 :areUnitsAvailable.0:firstUnit null
-    * jump *label26 equal *tmp11 false
+   73 jump *label26 equal :areUnitsAvailable.0:firstUnit null
    74 set :needsFourUnits.0:unit @unit
    75 op sub *tmp14 .DOME_X .CORE_X
    76 op sub *tmp15 .DOME_Y .CORE_Y
 
    97 op or *tmp26 *tmp23 *tmp25
    98 jump *label34 equal *tmp26 false
    99 op add :areUnitsAvailable.0:free :areUnitsAvailable.0:free 1
-    * op greaterThanEq *tmp28 :areUnitsAvailable.0:free :areUnitsAvailable.0:needed
-    * jump *label36 equal *tmp28 false
+  100 jump *label36 lessThan :areUnitsAvailable.0:free :areUnitsAvailable.0:needed
   101 set *tmp10 true
   102 jump *label25 always
   103 jump *label37 always
 
   126 print ","
   127 print " free: "
   128 print :areUnitsAvailable.0:free
-    * op greaterThan *tmp36 :areUnitsAvailable.0:needed 0
-    * jump *label40 equal *tmp36 false
+  129 jump *label40 lessThanEq :areUnitsAvailable.0:needed 0
   130 print ", needed: "
   131 print :areUnitsAvailable.0:needed
   132 jump *label41 always
 
   161 setaddr *tmp39 *label50
   162 set :chooseUnitType.0:type @mono
   163 label *label44
-    * op notEqual *tmp40 :chooseUnitType.0:type UNIT_TYPE
-    * jump *label51 equal *tmp40 false
+  164 jump *label51 equal :chooseUnitType.0:type UNIT_TYPE
   165 set :areUnitsAvailable.1:type :chooseUnitType.0:type
   166 set :areUnitsAvailable.1:output true
   167 set :areUnitsAvailable.1:free 0
 
   169 set :areUnitsAvailable.1:needed 0
   170 ubind :areUnitsAvailable.1:type
   171 set :areUnitsAvailable.1:firstUnit @unit
-    * op notEqual *tmp43 :areUnitsAvailable.1:firstUnit null
-    * jump *label54 equal *tmp43 false
+  172 jump *label54 equal :areUnitsAvailable.1:firstUnit null
   173 set :needsFourUnits.1:unit @unit
   174 op sub *tmp46 .DOME_X .CORE_X
   175 op sub *tmp47 .DOME_Y .CORE_Y
 
   196 op or *tmp58 *tmp55 *tmp57
   197 jump *label62 equal *tmp58 false
   198 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
-    * op greaterThanEq *tmp60 :areUnitsAvailable.1:free :areUnitsAvailable.1:needed
-    * jump *label64 equal *tmp60 false
+  199 jump *label64 lessThan :areUnitsAvailable.1:free :areUnitsAvailable.1:needed
   200 set *tmp42 true
   201 jump *label53 always
   202 jump *label65 always
 
   225 print ","
   226 print " free: "
   227 print :areUnitsAvailable.1:free
-    * op greaterThan *tmp68 :areUnitsAvailable.1:needed 0
-    * jump *label68 equal *tmp68 false
+  228 jump *label68 lessThanEq :areUnitsAvailable.1:needed 0
   229 print ", needed: "
   230 print :areUnitsAvailable.1:needed
   231 jump *label69 always
 
   269 set :rebindUnits.0:count 0
   270 ubind .TYPE
   271 set :rebindUnits.0:firstUnit @unit
-    * op equal *tmp72 :rebindUnits.0:firstUnit null
-    * jump *label73 equal *tmp72 false
+  272 jump *label73 notEqual :rebindUnits.0:firstUnit null
   273 end
   274 jump *label74 always
   275 label *label73
   276 label *label74
   277 label *label75
   278 sensor *tmp74 @unit @controller
-    * op equal *tmp75 *tmp74 @this
-    * jump *label78 equal *tmp75 false
+  279 jump *label78 notEqual *tmp74 @this
   280 op add :rebindUnits.0:count :rebindUnits.0:count 1
   281 ucontrol flag 1
   282 set .UNIT_S2 .UNIT_P2
   283 set .UNIT_P2 .UNIT_S1
   284 set .UNIT_S1 .UNIT_P1
   285 set .UNIT_P1 @unit
-    * op notEqual *tmp79 .UNIT_S2 null
-    * jump *label80 equal *tmp79 false
+  286 jump *label80 equal .UNIT_S2 null
   287 jump *label77 always
   288 jump *label81 always
   289 label *label80
 
   303 label *label72
   304 set :acquireUnit.0:currentUnit .UNIT_S1
   305 set :rebindUnit.0:currentUnit :acquireUnit.0:currentUnit
-    * op notEqual *tmp87 :rebindUnit.0:currentUnit null
-    * jump *label84 equal *tmp87 false
+  306 jump *label84 equal :rebindUnit.0:currentUnit null
   307 ubind :rebindUnit.0:currentUnit
   308 sensor *tmp89 @unit @dead
   309 op strictEqual *tmp90 *tmp89 0
 
   320 label *label85
   321 ubind .TYPE
   322 set :rebindUnit.0:firstUnit @unit
-    * op notEqual *tmp95 :rebindUnit.0:firstUnit null
-    * jump *label88 equal *tmp95 false
+  323 jump *label88 equal :rebindUnit.0:firstUnit null
   324 label *label90
   325 sensor *tmp97 @unit @controlled
-    * op equal *tmp98 *tmp97 0
-    * jump *label93 equal *tmp98 false
+  326 jump *label93 notEqual *tmp97 0
   327 jump *label83 always
   328 jump *label94 always
   329 label *label93
 
   349 set .UNIT_S1 *tmp85
   350 set :acquireUnit.1:currentUnit .UNIT_P1
   351 set :rebindUnit.1:currentUnit :acquireUnit.1:currentUnit
-    * op notEqual *tmp106 :rebindUnit.1:currentUnit null
-    * jump *label97 equal *tmp106 false
+  352 jump *label97 equal :rebindUnit.1:currentUnit null
   353 ubind :rebindUnit.1:currentUnit
   354 sensor *tmp108 @unit @dead
   355 op strictEqual *tmp109 *tmp108 0
 
   366 label *label98
   367 ubind .TYPE
   368 set :rebindUnit.1:firstUnit @unit
-    * op notEqual *tmp114 :rebindUnit.1:firstUnit null
-    * jump *label101 equal *tmp114 false
+  369 jump *label101 equal :rebindUnit.1:firstUnit null
   370 label *label103
   371 sensor *tmp116 @unit @controlled
-    * op equal *tmp117 *tmp116 0
-    * jump *label106 equal *tmp117 false
+  372 jump *label106 notEqual *tmp116 0
   373 jump *label96 always
   374 jump *label107 always
   375 label *label106
 
   434 jump *label114 equal .FOUR_UNITS false
   435 set :acquireUnit.2:currentUnit .UNIT_S2
   436 set :rebindUnit.2:currentUnit :acquireUnit.2:currentUnit
-    * op notEqual *tmp145 :rebindUnit.2:currentUnit null
-    * jump *label118 equal *tmp145 false
+  437 jump *label118 equal :rebindUnit.2:currentUnit null
   438 ubind :rebindUnit.2:currentUnit
   439 sensor *tmp147 @unit @dead
   440 op strictEqual *tmp148 *tmp147 0
 
   451 label *label119
   452 ubind .TYPE
   453 set :rebindUnit.2:firstUnit @unit
-    * op notEqual *tmp153 :rebindUnit.2:firstUnit null
-    * jump *label122 equal *tmp153 false
+  454 jump *label122 equal :rebindUnit.2:firstUnit null
   455 label *label124
   456 sensor *tmp155 @unit @controlled
-    * op equal *tmp156 *tmp155 0
-    * jump *label127 equal *tmp156 false
+  457 jump *label127 notEqual *tmp155 0
   458 jump *label117 always
   459 jump *label128 always
   460 label *label127
 
   480 set .UNIT_S2 *tmp143
   481 set :acquireUnit.3:currentUnit .UNIT_P2
   482 set :rebindUnit.3:currentUnit :acquireUnit.3:currentUnit
-    * op notEqual *tmp164 :rebindUnit.3:currentUnit null
-    * jump *label131 equal *tmp164 false
+  483 jump *label131 equal :rebindUnit.3:currentUnit null
   484 ubind :rebindUnit.3:currentUnit
   485 sensor *tmp166 @unit @dead
   486 op strictEqual *tmp167 *tmp166 0
 
   497 label *label132
   498 ubind .TYPE
   499 set :rebindUnit.3:firstUnit @unit
-    * op notEqual *tmp172 :rebindUnit.3:firstUnit null
-    * jump *label135 equal *tmp172 false
+  500 jump *label135 equal :rebindUnit.3:firstUnit null
   501 label *label137
   502 sensor *tmp174 @unit @controlled
-    * op equal *tmp175 *tmp174 0
-    * jump *label140 equal *tmp175 false
+  503 jump *label140 notEqual *tmp174 0
   504 jump *label130 always
   505 jump *label141 always
   506 label *label140
 
   597 set :printDomeStatus.0:text "\n[green]Silicon[] status:\n"
   598 print :printDomeStatus.0:text
   599 sensor :printDomeStatus.0:level .DOME :printDomeStatus.0:item
-    * op greaterThan *tmp206 :printDomeStatus.0:level 3
-    * jump *label152 equal *tmp206 false
+  600 jump *label152 lessThanEq :printDomeStatus.0:level 3
   601 print "  dome:  [green]"
   602 print :printDomeStatus.0:level
   603 print "["
 
   617 set :processUnit.0:group .GROUP1
   618 set :processUnit.0:supply .SUPPLY_S_FIRST
   619 set :rebindUnit.4:currentUnit :processUnit.0:unit
-    * op notEqual *tmp209 :rebindUnit.4:currentUnit null
-    * jump *label156 equal *tmp209 false
+  620 jump *label156 equal :rebindUnit.4:currentUnit null
   621 ubind :rebindUnit.4:currentUnit
   622 sensor *tmp211 @unit @dead
   623 op strictEqual *tmp212 *tmp211 0
 
   634 label *label157
   635 ubind .TYPE
   636 set :rebindUnit.4:firstUnit @unit
-    * op notEqual *tmp217 :rebindUnit.4:firstUnit null
-    * jump *label160 equal *tmp217 false
+  637 jump *label160 equal :rebindUnit.4:firstUnit null
   638 label *label162
   639 sensor *tmp219 @unit @controlled
-    * op equal *tmp220 *tmp219 0
-    * jump *label165 equal *tmp220 false
+  640 jump *label165 notEqual *tmp219 0
   641 jump *label155 always
   642 jump *label166 always
   643 label *label165
 
   663 op or *tmp229 *tmp227 *tmp228
   664 jump *label167 equal *tmp229 false
   665 sensor *tmp231 @unit @firstItem
-    * op equal *tmp232 *tmp231 :processUnit.0:item
-    * jump *label169 equal *tmp232 false
+  666 jump *label169 notEqual *tmp231 :processUnit.0:item
   667 set :processUnit.0:state 3
   668 jump *label170 always
   669 label *label169
   670 sensor *tmp234 @unit @totalItems
-    * op equal *tmp235 *tmp234 0
-    * jump *label171 equal *tmp235 false
+  671 jump *label171 notEqual *tmp234 0
   672 set :processUnit.0:state 2
   673 jump *label172 always
   674 label *label171
 
   685 jump *label168 always
   686 label *label167
   687 label *label168
-    * op equal *tmp239 :processUnit.0:state 2
-    * jump *label175 equal *tmp239 false
+  688 jump *label175 notEqual :processUnit.0:state 2
   689 ucontrol within .CORE_X .CORE_Y 8 *tmp241
   690 jump *label177 equal *tmp241 false
   691 ucontrol itemTake .CORE :processUnit.0:item .UNIT_CAPACITY
   692 sensor *tmp243 @unit @totalItems
-    * op greaterThanEq *tmp244 *tmp243 .UNIT_CAPACITY
-    * jump *label179 equal *tmp244 false
+  693 jump *label179 lessThan *tmp243 .UNIT_CAPACITY
   694 ucontrol approach .DOME_X .DOME_Y 6
   695 set :processUnit.0:state 3
   696 jump *label180 always
 
   712 jump *label176 always
   713 label *label175
   714 label *label176
-    * op equal *tmp253 :processUnit.0:state 3
-    * jump *label181 equal *tmp253 false
+  715 jump *label181 notEqual :processUnit.0:state 3
   716 ucontrol within .DOME_X .DOME_Y 8 *tmp255
   717 jump *label183 equal *tmp255 false
   718 jump *label185 equal :processUnit.0:supply false
 
   724 set .MSG ", waiting\n"
   725 label *label186
   726 sensor *tmp258 @unit @totalItems
-    * op lessThanEq *tmp259 *tmp258 0
-    * jump *label187 equal *tmp259 false
+  727 jump *label187 greaterThan *tmp258 0
   728 ucontrol approach .CORE_X .CORE_Y 6
   729 set :processUnit.0:state 2
   730 jump *label188 always
 
   756 print *tmp268
   757 print "["
   758 print "]"
-    * op greaterThanEq *tmp269 :processUnit.0:distance 0
-    * jump *label189 equal *tmp269 false
+  759 jump *label189 lessThan :processUnit.0:distance 0
   760 print .MSG
   761 print :processUnit.0:distance
   762 print "["
 
   776 set :processUnit.1:group .GROUP2
   777 set :processUnit.1:supply *tmp273
   778 set :rebindUnit.5:currentUnit :processUnit.1:unit
-    * op notEqual *tmp275 :rebindUnit.5:currentUnit null
-    * jump *label195 equal *tmp275 false
+  779 jump *label195 equal :rebindUnit.5:currentUnit null
   780 ubind :rebindUnit.5:currentUnit
   781 sensor *tmp277 @unit @dead
   782 op strictEqual *tmp278 *tmp277 0
 
   793 label *label196
   794 ubind .TYPE
   795 set :rebindUnit.5:firstUnit @unit
-    * op notEqual *tmp283 :rebindUnit.5:firstUnit null
-    * jump *label199 equal *tmp283 false
+  796 jump *label199 equal :rebindUnit.5:firstUnit null
   797 label *label201
   798 sensor *tmp285 @unit @controlled
-    * op equal *tmp286 *tmp285 0
-    * jump *label204 equal *tmp286 false
+  799 jump *label204 notEqual *tmp285 0
   800 jump *label194 always
   801 jump *label205 always
   802 label *label204
 
   822 op or *tmp295 *tmp293 *tmp294
   823 jump *label206 equal *tmp295 false
   824 sensor *tmp297 @unit @firstItem
-    * op equal *tmp298 *tmp297 :processUnit.1:item
-    * jump *label208 equal *tmp298 false
+  825 jump *label208 notEqual *tmp297 :processUnit.1:item
   826 set :processUnit.1:state 3
   827 jump *label209 always
   828 label *label208
   829 sensor *tmp300 @unit @totalItems
-    * op equal *tmp301 *tmp300 0
-    * jump *label210 equal *tmp301 false
+  830 jump *label210 notEqual *tmp300 0
   831 set :processUnit.1:state 2
   832 jump *label211 always
   833 label *label210
 
   844 jump *label207 always
   845 label *label206
   846 label *label207
-    * op equal *tmp305 :processUnit.1:state 2
-    * jump *label214 equal *tmp305 false
+  847 jump *label214 notEqual :processUnit.1:state 2
   848 ucontrol within .CORE_X .CORE_Y 8 *tmp307
   849 jump *label216 equal *tmp307 false
   850 ucontrol itemTake .CORE :processUnit.1:item .UNIT_CAPACITY
   851 sensor *tmp309 @unit @totalItems
-    * op greaterThanEq *tmp310 *tmp309 .UNIT_CAPACITY
-    * jump *label218 equal *tmp310 false
+  852 jump *label218 lessThan *tmp309 .UNIT_CAPACITY
   853 ucontrol approach .DOME_X .DOME_Y 6
   854 set :processUnit.1:state 3
   855 jump *label219 always
 
   871 jump *label215 always
   872 label *label214
   873 label *label215
-    * op equal *tmp319 :processUnit.1:state 3
-    * jump *label220 equal *tmp319 false
+  874 jump *label220 notEqual :processUnit.1:state 3
   875 ucontrol within .DOME_X .DOME_Y 8 *tmp321
   876 jump *label222 equal *tmp321 false
   877 jump *label224 equal :processUnit.1:supply false
 
   883 set .MSG ", waiting\n"
   884 label *label225
   885 sensor *tmp324 @unit @totalItems
-    * op lessThanEq *tmp325 *tmp324 0
-    * jump *label226 equal *tmp325 false
+  886 jump *label226 greaterThan *tmp324 0
   887 ucontrol approach .CORE_X .CORE_Y 6
   888 set :processUnit.1:state 2
   889 jump *label227 always
 
   915 print *tmp334
   916 print "["
   917 print "]"
-    * op greaterThanEq *tmp335 :processUnit.1:distance 0
-    * jump *label228 equal *tmp335 false
+  918 jump *label228 lessThan :processUnit.1:distance 0
   919 print .MSG
   920 print :processUnit.1:distance
   921 print "["
 
   944 set :printDomeStatus.1:text "\n[green]Phase fabric[] status:\n"
   945 print :printDomeStatus.1:text
   946 sensor :printDomeStatus.1:level .DOME :printDomeStatus.1:item
-    * op greaterThan *tmp344 :printDomeStatus.1:level 3
-    * jump *label233 equal *tmp344 false
+  947 jump *label233 lessThanEq :printDomeStatus.1:level 3
   948 print "  dome:  [green]"
   949 print :printDomeStatus.1:level
   950 print "["
 
   964 set :processUnit.2:group .GROUP1
   965 set :processUnit.2:supply .SUPPLY_P_FIRST
   966 set :rebindUnit.6:currentUnit :processUnit.2:unit
-    * op notEqual *tmp347 :rebindUnit.6:currentUnit null
-    * jump *label237 equal *tmp347 false
+  967 jump *label237 equal :rebindUnit.6:currentUnit null
   968 ubind :rebindUnit.6:currentUnit
   969 sensor *tmp349 @unit @dead
   970 op strictEqual *tmp350 *tmp349 0
 
   981 label *label238
   982 ubind .TYPE
   983 set :rebindUnit.6:firstUnit @unit
-    * op notEqual *tmp355 :rebindUnit.6:firstUnit null
-    * jump *label241 equal *tmp355 false
+  984 jump *label241 equal :rebindUnit.6:firstUnit null
   985 label *label243
   986 sensor *tmp357 @unit @controlled
-    * op equal *tmp358 *tmp357 0
-    * jump *label246 equal *tmp358 false
+  987 jump *label246 notEqual *tmp357 0
   988 jump *label236 always
   989 jump *label247 always
   990 label *label246
 
  1010 op or *tmp367 *tmp365 *tmp366
  1011 jump *label248 equal *tmp367 false
  1012 sensor *tmp369 @unit @firstItem
-    * op equal *tmp370 *tmp369 :processUnit.2:item
-    * jump *label250 equal *tmp370 false
+ 1013 jump *label250 notEqual *tmp369 :processUnit.2:item
  1014 set :processUnit.2:state 3
  1015 jump *label251 always
  1016 label *label250
  1017 sensor *tmp372 @unit @totalItems
-    * op equal *tmp373 *tmp372 0
-    * jump *label252 equal *tmp373 false
+ 1018 jump *label252 notEqual *tmp372 0
  1019 set :processUnit.2:state 2
  1020 jump *label253 always
  1021 label *label252
 
  1032 jump *label249 always
  1033 label *label248
  1034 label *label249
-    * op equal *tmp377 :processUnit.2:state 2
-    * jump *label256 equal *tmp377 false
+ 1035 jump *label256 notEqual :processUnit.2:state 2
  1036 ucontrol within .CORE_X .CORE_Y 8 *tmp379
  1037 jump *label258 equal *tmp379 false
  1038 ucontrol itemTake .CORE :processUnit.2:item .UNIT_CAPACITY
  1039 sensor *tmp381 @unit @totalItems
-    * op greaterThanEq *tmp382 *tmp381 .UNIT_CAPACITY
-    * jump *label260 equal *tmp382 false
+ 1040 jump *label260 lessThan *tmp381 .UNIT_CAPACITY
  1041 ucontrol approach .DOME_X .DOME_Y 6
  1042 set :processUnit.2:state 3
  1043 jump *label261 always
 
  1059 jump *label257 always
  1060 label *label256
  1061 label *label257
-    * op equal *tmp391 :processUnit.2:state 3
-    * jump *label262 equal *tmp391 false
+ 1062 jump *label262 notEqual :processUnit.2:state 3
  1063 ucontrol within .DOME_X .DOME_Y 8 *tmp393
  1064 jump *label264 equal *tmp393 false
  1065 jump *label266 equal :processUnit.2:supply false
 
  1071 set .MSG ", waiting\n"
  1072 label *label267
  1073 sensor *tmp396 @unit @totalItems
-    * op lessThanEq *tmp397 *tmp396 0
-    * jump *label268 equal *tmp397 false
+ 1074 jump *label268 greaterThan *tmp396 0
  1075 ucontrol approach .CORE_X .CORE_Y 6
  1076 set :processUnit.2:state 2
  1077 jump *label269 always
 
  1103 print *tmp406
  1104 print "["
  1105 print "]"
-    * op greaterThanEq *tmp407 :processUnit.2:distance 0
-    * jump *label270 equal *tmp407 false
+ 1106 jump *label270 lessThan :processUnit.2:distance 0
  1107 print .MSG
  1108 print :processUnit.2:distance
  1109 print "["
 
  1123 set :processUnit.3:group .GROUP2
  1124 set :processUnit.3:supply *tmp411
  1125 set :rebindUnit.7:currentUnit :processUnit.3:unit
-    * op notEqual *tmp413 :rebindUnit.7:currentUnit null
-    * jump *label276 equal *tmp413 false
+ 1126 jump *label276 equal :rebindUnit.7:currentUnit null
  1127 ubind :rebindUnit.7:currentUnit
  1128 sensor *tmp415 @unit @dead
  1129 op strictEqual *tmp416 *tmp415 0
 
  1140 label *label277
  1141 ubind .TYPE
  1142 set :rebindUnit.7:firstUnit @unit
-    * op notEqual *tmp421 :rebindUnit.7:firstUnit null
-    * jump *label280 equal *tmp421 false
+ 1143 jump *label280 equal :rebindUnit.7:firstUnit null
  1144 label *label282
  1145 sensor *tmp423 @unit @controlled
-    * op equal *tmp424 *tmp423 0
-    * jump *label285 equal *tmp424 false
+ 1146 jump *label285 notEqual *tmp423 0
  1147 jump *label275 always
  1148 jump *label286 always
  1149 label *label285
 
  1169 op or *tmp433 *tmp431 *tmp432
  1170 jump *label287 equal *tmp433 false
  1171 sensor *tmp435 @unit @firstItem
-    * op equal *tmp436 *tmp435 :processUnit.3:item
-    * jump *label289 equal *tmp436 false
+ 1172 jump *label289 notEqual *tmp435 :processUnit.3:item
  1173 set :processUnit.3:state 3
  1174 jump *label290 always
  1175 label *label289
  1176 sensor *tmp438 @unit @totalItems
-    * op equal *tmp439 *tmp438 0
-    * jump *label291 equal *tmp439 false
+ 1177 jump *label291 notEqual *tmp438 0
  1178 set :processUnit.3:state 2
  1179 jump *label292 always
  1180 label *label291
 
  1191 jump *label288 always
  1192 label *label287
  1193 label *label288
-    * op equal *tmp443 :processUnit.3:state 2
-    * jump *label295 equal *tmp443 false
+ 1194 jump *label295 notEqual :processUnit.3:state 2
  1195 ucontrol within .CORE_X .CORE_Y 8 *tmp445
  1196 jump *label297 equal *tmp445 false
  1197 ucontrol itemTake .CORE :processUnit.3:item .UNIT_CAPACITY
  1198 sensor *tmp447 @unit @totalItems
-    * op greaterThanEq *tmp448 *tmp447 .UNIT_CAPACITY
-    * jump *label299 equal *tmp448 false
+ 1199 jump *label299 lessThan *tmp447 .UNIT_CAPACITY
  1200 ucontrol approach .DOME_X .DOME_Y 6
  1201 set :processUnit.3:state 3
  1202 jump *label300 always
 
  1218 jump *label296 always
  1219 label *label295
  1220 label *label296
-    * op equal *tmp457 :processUnit.3:state 3
-    * jump *label301 equal *tmp457 false
+ 1221 jump *label301 notEqual :processUnit.3:state 3
  1222 ucontrol within .DOME_X .DOME_Y 8 *tmp459
  1223 jump *label303 equal *tmp459 false
  1224 jump *label305 equal :processUnit.3:supply false
 
  1230 set .MSG ", waiting\n"
  1231 label *label306
  1232 sensor *tmp462 @unit @totalItems
-    * op lessThanEq *tmp463 *tmp462 0
-    * jump *label307 equal *tmp463 false
+ 1233 jump *label307 greaterThan *tmp462 0
  1234 ucontrol approach .CORE_X .CORE_Y 6
  1235 set :processUnit.3:state 2
  1236 jump *label308 always
 
  1262 print *tmp472
  1263 print "["
  1264 print "]"
-    * op greaterThanEq *tmp473 :processUnit.3:distance 0
-    * jump *label309 equal *tmp473 false
+ 1265 jump *label309 lessThan :processUnit.3:distance 0
  1266 print .MSG
  1267 print :processUnit.3:distance
  1268 print "["
 
  1306 set :areUnitsAvailable.2:needed 0
  1307 ubind :areUnitsAvailable.2:type
  1308 set :areUnitsAvailable.2:firstUnit @unit
-    * op notEqual *tmp488 :areUnitsAvailable.2:firstUnit null
-    * jump *label316 equal *tmp488 false
+ 1309 jump *label316 equal :areUnitsAvailable.2:firstUnit null
  1310 set :needsFourUnits.3:unit @unit
  1311 op sub *tmp491 .DOME_X .CORE_X
  1312 op sub *tmp492 .DOME_Y .CORE_Y
 
  1333 op or *tmp503 *tmp500 *tmp502
  1334 jump *label324 equal *tmp503 false
  1335 op add :areUnitsAvailable.2:free :areUnitsAvailable.2:free 1
-    * op greaterThanEq *tmp505 :areUnitsAvailable.2:free :areUnitsAvailable.2:needed
-    * jump *label326 equal *tmp505 false
+ 1336 jump *label326 lessThan :areUnitsAvailable.2:free :areUnitsAvailable.2:needed
  1337 set *tmp487 true
  1338 jump *label315 always
  1339 jump *label327 always
 
  1362 print ","
  1363 print " free: "
  1364 print :areUnitsAvailable.2:free
-    * op greaterThan *tmp513 :areUnitsAvailable.2:needed 0
-    * jump *label330 equal *tmp513 false
+ 1365 jump *label330 lessThanEq :areUnitsAvailable.2:needed 0
  1366 print ", needed: "
  1367 print :areUnitsAvailable.2:needed
  1368 jump *label331 always

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-81 instructions):
 
    35 label *label15
    36 jump *label16 equal :locateCore.0*retval false
    37 jump *label1 always
-    * jump *label17 always
    38 label *label16
    39 label *label17
    40 label *label9
 
    99 jump *label36 lessThan :areUnitsAvailable.0:free :areUnitsAvailable.0:needed
   100 set *tmp10 true
   101 jump *label25 always
-    * jump *label37 always
   102 label *label36
   103 label *label37
   104 jump *label35 always
 
   113 op land *tmp34 *tmp31 *tmp33
   114 jump *label31 notEqual *tmp34 false
   115 label *label33
-    * jump *label27 always
   116 label *label26
   117 label *label27
   118 jump *label38 equal :areUnitsAvailable.0:output false
 
   126 jump *label40 lessThanEq :areUnitsAvailable.0:needed 0
   127 print ", needed: "
   128 print :areUnitsAvailable.0:needed
-    * jump *label41 always
   129 label *label40
   130 label *label41
   131 print "\n"
-    * jump *label39 always
   132 label *label38
   133 label *label39
   134 set *tmp10 false
 
   138 jump *label42 equal *tmp10 false
   139 set *tmp9 UNIT_TYPE
   140 jump *label21 always
-    * jump *label43 always
   141 label *label42
   142 label *label43
   143 setaddr *tmp39 *label47
 
   193 jump *label64 lessThan :areUnitsAvailable.1:free :areUnitsAvailable.1:needed
   194 set *tmp42 true
   195 jump *label53 always
-    * jump *label65 always
   196 label *label64
   197 label *label65
   198 jump *label63 always
 
   207 op land *tmp66 *tmp63 *tmp65
   208 jump *label59 notEqual *tmp66 false
   209 label *label61
-    * jump *label55 always
   210 label *label54
   211 label *label55
   212 jump *label66 equal :areUnitsAvailable.1:output false
 
   220 jump *label68 lessThanEq :areUnitsAvailable.1:needed 0
   221 print ", needed: "
   222 print :areUnitsAvailable.1:needed
-    * jump *label69 always
   223 label *label68
   224 label *label69
   225 print "\n"
-    * jump *label67 always
   226 label *label66
   227 label *label67
   228 set *tmp42 false
 
   233 printflush null
   234 set *tmp9 :chooseUnitType.0:type
   235 jump *label21 always
-    * jump *label71 always
   236 label *label70
   237 label *label71
-    * jump *label52 always
   238 label *label51
   239 label *label52
   240 label *label45
 
   259 set :rebindUnits.0:firstUnit @unit
   260 jump *label73 notEqual :rebindUnits.0:firstUnit null
   261 end
-    * jump *label74 always
   262 label *label73
   263 label *label74
   264 label *label75
 
   272 set .UNIT_P1 @unit
   273 jump *label80 equal .UNIT_S2 null
   274 jump *label77 always
-    * jump *label81 always
   275 label *label80
   276 label *label81
-    * jump *label79 always
   277 label *label78
   278 label *label79
   279 ubind .TYPE
 
   284 op land *tmp84 *tmp81 *tmp83
   285 jump *label75 notEqual *tmp84 false
   286 label *label77
-    * jump *label72 always
   287 label *label72
   288 set :acquireUnit.0:currentUnit .UNIT_S1
   289 set :rebindUnit.0:currentUnit :acquireUnit.0:currentUnit
 
   296 op land *tmp93 *tmp90 *tmp92
   297 jump *label86 equal *tmp93 false
   298 jump *label83 always
-    * jump *label87 always
   299 label *label86
   300 label *label87
-    * jump *label85 always
   301 label *label84
   302 label *label85
   303 ubind .TYPE
 
   307 sensor *tmp97 @unit @controlled
   308 jump *label93 notEqual *tmp97 0
   309 jump *label83 always
-    * jump *label94 always
   310 label *label93
   311 label *label94
   312 ubind .TYPE
 
   317 op land *tmp103 *tmp100 *tmp102
   318 jump *label90 notEqual *tmp103 false
   319 label *label92
-    * jump *label89 always
   320 label *label88
   321 label *label89
   322 end
 
   338 op land *tmp112 *tmp109 *tmp111
   339 jump *label99 equal *tmp112 false
   340 jump *label96 always
-    * jump *label100 always
   341 label *label99
   342 label *label100
-    * jump *label98 always
   343 label *label97
   344 label *label98
   345 ubind .TYPE
 
   349 sensor *tmp116 @unit @controlled
   350 jump *label106 notEqual *tmp116 0
   351 jump *label96 always
-    * jump *label107 always
   352 label *label106
   353 label *label107
   354 ubind .TYPE
 
   359 op land *tmp122 *tmp119 *tmp121
   360 jump *label103 notEqual *tmp122 false
   361 label *label105
-    * jump *label102 always
   362 label *label101
   363 label *label102
   364 end
 
   383 label *label110
   384 set .UNIT_S1 :swap.0:a
   385 set .UNIT_P1 :swap.0:b
-    * jump *label109 always
   386 label *label108
   387 label *label109
   388 sensor .UNIT_CAPACITY .UNIT_S1 @itemCapacity
 
   391 op strictEqual *tmp132 .SPEED null
   392 jump *label111 equal *tmp132 false
   393 stop
-    * jump *label112 always
   394 label *label111
   395 label *label112
   396 set :needsFourUnits.2:unit .UNIT_S1
 
   417 op land *tmp151 *tmp148 *tmp150
   418 jump *label120 equal *tmp151 false
   419 jump *label117 always
-    * jump *label121 always
   420 label *label120
   421 label *label121
-    * jump *label119 always
   422 label *label118
   423 label *label119
   424 ubind .TYPE
 
   428 sensor *tmp155 @unit @controlled
   429 jump *label127 notEqual *tmp155 0
   430 jump *label117 always
-    * jump *label128 always
   431 label *label127
   432 label *label128
   433 ubind .TYPE
 
   438 op land *tmp161 *tmp158 *tmp160
   439 jump *label124 notEqual *tmp161 false
   440 label *label126
-    * jump *label123 always
   441 label *label122
   442 label *label123
   443 end
 
   459 op land *tmp170 *tmp167 *tmp169
   460 jump *label133 equal *tmp170 false
   461 jump *label130 always
-    * jump *label134 always
   462 label *label133
   463 label *label134
-    * jump *label132 always
   464 label *label131
   465 label *label132
   466 ubind .TYPE
 
   470 sensor *tmp174 @unit @controlled
   471 jump *label140 notEqual *tmp174 0
   472 jump *label130 always
-    * jump *label141 always
   473 label *label140
   474 label *label141
   475 ubind .TYPE
 
   480 op land *tmp180 *tmp177 *tmp179
   481 jump *label137 notEqual *tmp180 false
   482 label *label139
-    * jump *label136 always
   483 label *label135
   484 label *label136
   485 end
 
   504 label *label144
   505 set .UNIT_S1 :swap.1:a
   506 set .UNIT_P2 :swap.1:b
-    * jump *label143 always
   507 label *label142
   508 label *label143
   509 sensor *tmp187 .UNIT_S2 @firstItem
 
   520 label *label147
   521 set .UNIT_S2 :swap.2:a
   522 set .UNIT_P2 :swap.2:b
-    * jump *label146 always
   523 label *label145
   524 label *label146
   525 set .GROUP1 "unit  1"
 
   590 op land *tmp215 *tmp212 *tmp214
   591 jump *label158 equal *tmp215 false
   592 jump *label155 always
-    * jump *label159 always
   593 label *label158
   594 label *label159
-    * jump *label157 always
   595 label *label156
   596 label *label157
   597 ubind .TYPE
 
   601 sensor *tmp219 @unit @controlled
   602 jump *label165 notEqual *tmp219 0
   603 jump *label155 always
-    * jump *label166 always
   604 label *label165
   605 label *label166
   606 ubind .TYPE
 
   611 op land *tmp225 *tmp222 *tmp224
   612 jump *label162 notEqual *tmp225 false
   613 label *label164
-    * jump *label161 always
   614 label *label160
   615 label *label161
   616 end
 
   637 ucontrol within .CORE_X .CORE_Y 8 *tmp237
   638 jump *label173 equal *tmp237 false
   639 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * jump *label174 always
   640 label *label173
   641 label *label174
   642 label *label172
   643 label *label170
-    * jump *label168 always
   644 label *label167
   645 label *label168
   646 jump *label175 notEqual :processUnit.0:state 2
 
   667 op idiv *tmp251 *tmp250 .SPEED_TENTHS
   668 op div :processUnit.0:distance *tmp251 10
   669 label *label178
-    * jump *label176 always
   670 label *label175
   671 label *label176
   672 jump *label181 notEqual :processUnit.0:state 3
 
   684 jump *label187 greaterThan *tmp258 0
   685 ucontrol approach .CORE_X .CORE_Y 6
   686 set :processUnit.0:state 2
-    * jump *label188 always
   687 label *label187
   688 label *label188
   689 jump *label184 always
 
   698 op idiv *tmp266 *tmp265 .SPEED_TENTHS
   699 op div :processUnit.0:distance *tmp266 10
   700 label *label184
-    * jump *label182 always
   701 label *label181
   702 label *label182
   703 ucontrol flag :processUnit.0:state
 
   740 op land *tmp281 *tmp278 *tmp280
   741 jump *label197 equal *tmp281 false
   742 jump *label194 always
-    * jump *label198 always
   743 label *label197
   744 label *label198
-    * jump *label196 always
   745 label *label195
   746 label *label196
   747 ubind .TYPE
 
   751 sensor *tmp285 @unit @controlled
   752 jump *label204 notEqual *tmp285 0
   753 jump *label194 always
-    * jump *label205 always
   754 label *label204
   755 label *label205
   756 ubind .TYPE
 
   761 op land *tmp291 *tmp288 *tmp290
   762 jump *label201 notEqual *tmp291 false
   763 label *label203
-    * jump *label200 always
   764 label *label199
   765 label *label200
   766 end
 
   787 ucontrol within .CORE_X .CORE_Y 8 *tmp303
   788 jump *label212 equal *tmp303 false
   789 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * jump *label213 always
   790 label *label212
   791 label *label213
   792 label *label211
   793 label *label209
-    * jump *label207 always
   794 label *label206
   795 label *label207
   796 jump *label214 notEqual :processUnit.1:state 2
 
   817 op idiv *tmp317 *tmp316 .SPEED_TENTHS
   818 op div :processUnit.1:distance *tmp317 10
   819 label *label217
-    * jump *label215 always
   820 label *label214
   821 label *label215
   822 jump *label220 notEqual :processUnit.1:state 3
 
   834 jump *label226 greaterThan *tmp324 0
   835 ucontrol approach .CORE_X .CORE_Y 6
   836 set :processUnit.1:state 2
-    * jump *label227 always
   837 label *label226
   838 label *label227
   839 jump *label223 always
 
   848 op idiv *tmp332 *tmp331 .SPEED_TENTHS
   849 op div :processUnit.1:distance *tmp332 10
   850 label *label223
-    * jump *label221 always
   851 label *label220
   852 label *label221
   853 ucontrol flag :processUnit.1:state
 
   883 op equal *tmp338 *tmp341 0
   884 label *label231
   885 set .SUPPLY_S_FIRST *tmp338
-    * jump *label192 always
   886 label *label191
   887 label *label192
   888 set :printDomeStatus.1:item @phase-fabric
 
   918 op land *tmp353 *tmp350 *tmp352
   919 jump *label239 equal *tmp353 false
   920 jump *label236 always
-    * jump *label240 always
   921 label *label239
   922 label *label240
-    * jump *label238 always
   923 label *label237
   924 label *label238
   925 ubind .TYPE
 
   929 sensor *tmp357 @unit @controlled
   930 jump *label246 notEqual *tmp357 0
   931 jump *label236 always
-    * jump *label247 always
   932 label *label246
   933 label *label247
   934 ubind .TYPE
 
   939 op land *tmp363 *tmp360 *tmp362
   940 jump *label243 notEqual *tmp363 false
   941 label *label245
-    * jump *label242 always
   942 label *label241
   943 label *label242
   944 end
 
   965 ucontrol within .CORE_X .CORE_Y 8 *tmp375
   966 jump *label254 equal *tmp375 false
   967 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * jump *label255 always
   968 label *label254
   969 label *label255
   970 label *label253
   971 label *label251
-    * jump *label249 always
   972 label *label248
   973 label *label249
   974 jump *label256 notEqual :processUnit.2:state 2
 
   995 op idiv *tmp389 *tmp388 .SPEED_TENTHS
   996 op div :processUnit.2:distance *tmp389 10
   997 label *label259
-    * jump *label257 always
   998 label *label256
   999 label *label257
  1000 jump *label262 notEqual :processUnit.2:state 3
 
  1012 jump *label268 greaterThan *tmp396 0
  1013 ucontrol approach .CORE_X .CORE_Y 6
  1014 set :processUnit.2:state 2
-    * jump *label269 always
  1015 label *label268
  1016 label *label269
  1017 jump *label265 always
 
  1026 op idiv *tmp404 *tmp403 .SPEED_TENTHS
  1027 op div :processUnit.2:distance *tmp404 10
  1028 label *label265
-    * jump *label263 always
  1029 label *label262
  1030 label *label263
  1031 ucontrol flag :processUnit.2:state
 
  1068 op land *tmp419 *tmp416 *tmp418
  1069 jump *label278 equal *tmp419 false
  1070 jump *label275 always
-    * jump *label279 always
  1071 label *label278
  1072 label *label279
-    * jump *label277 always
  1073 label *label276
  1074 label *label277
  1075 ubind .TYPE
 
  1079 sensor *tmp423 @unit @controlled
  1080 jump *label285 notEqual *tmp423 0
  1081 jump *label275 always
-    * jump *label286 always
  1082 label *label285
  1083 label *label286
  1084 ubind .TYPE
 
  1089 op land *tmp429 *tmp426 *tmp428
  1090 jump *label282 notEqual *tmp429 false
  1091 label *label284
-    * jump *label281 always
  1092 label *label280
  1093 label *label281
  1094 end
 
  1115 ucontrol within .CORE_X .CORE_Y 8 *tmp441
  1116 jump *label293 equal *tmp441 false
  1117 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * jump *label294 always
  1118 label *label293
  1119 label *label294
  1120 label *label292
  1121 label *label290
-    * jump *label288 always
  1122 label *label287
  1123 label *label288
  1124 jump *label295 notEqual :processUnit.3:state 2
 
  1145 op idiv *tmp455 *tmp454 .SPEED_TENTHS
  1146 op div :processUnit.3:distance *tmp455 10
  1147 label *label298
-    * jump *label296 always
  1148 label *label295
  1149 label *label296
  1150 jump *label301 notEqual :processUnit.3:state 3
 
  1162 jump *label307 greaterThan *tmp462 0
  1163 ucontrol approach .CORE_X .CORE_Y 6
  1164 set :processUnit.3:state 2
-    * jump *label308 always
  1165 label *label307
  1166 label *label308
  1167 jump *label304 always
 
  1176 op idiv *tmp470 *tmp469 .SPEED_TENTHS
  1177 op div :processUnit.3:distance *tmp470 10
  1178 label *label304
-    * jump *label302 always
  1179 label *label301
  1180 label *label302
  1181 ucontrol flag :processUnit.3:state
 
  1211 op equal *tmp476 *tmp479 0
  1212 label *label312
  1213 set .SUPPLY_P_FIRST *tmp476
-    * jump *label273 always
  1214 label *label272
  1215 label *label273
  1216 op sub *tmp481 @time :start
 
  1262 jump *label326 lessThan :areUnitsAvailable.2:free :areUnitsAvailable.2:needed
  1263 set *tmp487 true
  1264 jump *label315 always
-    * jump *label327 always
  1265 label *label326
  1266 label *label327
  1267 jump *label325 always
 
  1276 op land *tmp511 *tmp508 *tmp510
  1277 jump *label321 notEqual *tmp511 false
  1278 label *label323
-    * jump *label317 always
  1279 label *label316
  1280 label *label317
  1281 jump *label328 equal :areUnitsAvailable.2:output false
 
  1289 jump *label330 lessThanEq :areUnitsAvailable.2:needed 0
  1290 print ", needed: "
  1291 print :areUnitsAvailable.2:needed
-    * jump *label331 always
  1292 label *label330
  1293 label *label331
  1294 print "\n"
-    * jump *label329 always
  1295 label *label328
  1296 label *label329
  1297 set *tmp487 false
 
  1300 label *label315
  1301 jump *label332 equal *tmp487 false
  1302 end
-    * jump *label333 always
  1303 label *label332
  1304 label *label333
  1305 op add :unitCheck @time 5000
-    * jump *label314 always
  1306 label *label313
  1307 label *label314
  1308 label *label149
 
  1318 op or *tmp521 *tmp518 *tmp520
  1319 jump *label335 equal *tmp521 false
  1320 ulocate building core false @copper 0 0 0 .CORE
-    * jump *label336 always
  1321 label *label335
  1322 label *label336
  1323 set :locateCore.0*retval .CORE

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-11 instructions):
 
    67 set :areUnitsAvailable.0:free 0
    68 set :areUnitsAvailable.0:occupied 0
    69 set :areUnitsAvailable.0:needed 0
-    * ubind :areUnitsAvailable.0:type
+   70 ubind UNIT_TYPE
    71 set :areUnitsAvailable.0:firstUnit @unit
    72 jump *label26 equal :areUnitsAvailable.0:firstUnit null
    73 set :needsFourUnits.0:unit @unit
 
    79 op div :needsFourUnits.0:travel_time *tmp17 *tmp18
    80 op greaterThanEq *tmp13 :needsFourUnits.0:travel_time 47
    81 jump *label28 always
-    * set *tmp13 null
    82 label *label28
    83 jump *label29 equal *tmp13 false
    84 set *tmp21 4
 
    95 op or *tmp26 *tmp23 *tmp25
    96 jump *label34 equal *tmp26 false
    97 op add :areUnitsAvailable.0:free :areUnitsAvailable.0:free 1
-    * jump *label36 lessThan :areUnitsAvailable.0:free :areUnitsAvailable.0:needed
+   98 jump *label36 lessThan :areUnitsAvailable.0:free *tmp21
    99 set *tmp10 true
   100 jump *label25 always
   101 label *label36
 
   104 label *label34
   105 op add :areUnitsAvailable.0:occupied :areUnitsAvailable.0:occupied 1
   106 label *label35
-    * ubind :areUnitsAvailable.0:type
+  107 ubind UNIT_TYPE
   108 label *label32
   109 op notEqual *tmp31 @unit :areUnitsAvailable.0:firstUnit
   110 sensor *tmp32 :areUnitsAvailable.0:firstUnit @dead
 
   114 label *label33
   115 label *label26
   116 label *label27
-    * jump *label38 equal :areUnitsAvailable.0:output false
-    * print :areUnitsAvailable.0:type
+  117 jump *label38 equal true false
+  118 print UNIT_TYPE
   119 print ":"
   120 print " occupied: "
   121 print :areUnitsAvailable.0:occupied
 
   132 label *label39
   133 set *tmp10 false
   134 jump *label25 always
-    * set *tmp10 null
   135 label *label25
   136 jump *label42 equal *tmp10 false
   137 set *tmp9 UNIT_TYPE
 
   159 set :areUnitsAvailable.1:free 0
   160 set :areUnitsAvailable.1:occupied 0
   161 set :areUnitsAvailable.1:needed 0
-    * ubind :areUnitsAvailable.1:type
+  162 ubind :chooseUnitType.0:type
   163 set :areUnitsAvailable.1:firstUnit @unit
   164 jump *label54 equal :areUnitsAvailable.1:firstUnit null
   165 set :needsFourUnits.1:unit @unit
 
   171 op div :needsFourUnits.1:travel_time *tmp49 *tmp50
   172 op greaterThanEq *tmp45 :needsFourUnits.1:travel_time 47
   173 jump *label56 always
-    * set *tmp45 null
   174 label *label56
   175 jump *label57 equal *tmp45 false
   176 set *tmp53 4
 
   187 op or *tmp58 *tmp55 *tmp57
   188 jump *label62 equal *tmp58 false
   189 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
-    * jump *label64 lessThan :areUnitsAvailable.1:free :areUnitsAvailable.1:needed
+  190 jump *label64 lessThan :areUnitsAvailable.1:free *tmp53
   191 set *tmp42 true
   192 jump *label53 always
   193 label *label64
 
   196 label *label62
   197 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   198 label *label63
-    * ubind :areUnitsAvailable.1:type
+  199 ubind :chooseUnitType.0:type
   200 label *label60
   201 op notEqual *tmp63 @unit :areUnitsAvailable.1:firstUnit
   202 sensor *tmp64 :areUnitsAvailable.1:firstUnit @dead
 
   206 label *label61
   207 label *label54
   208 label *label55
-    * jump *label66 equal :areUnitsAvailable.1:output false
-    * print :areUnitsAvailable.1:type
+  209 jump *label66 equal true false
+  210 print :chooseUnitType.0:type
   211 print ":"
   212 print " occupied: "
   213 print :areUnitsAvailable.1:occupied
 
   224 label *label67
   225 set *tmp42 false
   226 jump *label53 always
-    * set *tmp42 null
   227 label *label53
   228 jump *label70 equal *tmp42 false
   229 printflush null
 
   247 print "[gold]Binding units..."
   248 printflush message1
   249 set .UNIT_P2 null
-    * set .UNIT_S2 .UNIT_P2
-    * set .UNIT_P1 .UNIT_S2
-    * set .UNIT_S1 .UNIT_P1
+  250 set .UNIT_S2 null
+  251 set .UNIT_P1 .UNIT_P2
+  252 set .UNIT_S1 .UNIT_S2
   253 set :rebindUnits.0:count 0
-    * ubind .TYPE
+  254 ubind *tmp9
   255 set :rebindUnits.0:firstUnit @unit
   256 jump *label73 notEqual :rebindUnits.0:firstUnit null
   257 end
 
   272 label *label81
   273 label *label78
   274 label *label79
-    * ubind .TYPE
+  275 ubind *tmp9
   276 label *label76
   277 op notEqual *tmp81 @unit :rebindUnits.0:firstUnit
   278 sensor *tmp82 :rebindUnits.0:firstUnit @dead
 
   282 label *label77
   283 label *label72
   284 set :acquireUnit.0:currentUnit .UNIT_S1
-    * set :rebindUnit.0:currentUnit :acquireUnit.0:currentUnit
-    * jump *label84 equal :rebindUnit.0:currentUnit null
-    * ubind :rebindUnit.0:currentUnit
+  285 set :rebindUnit.0:currentUnit .UNIT_S1
+  286 jump *label84 equal :acquireUnit.0:currentUnit null
+  287 ubind :acquireUnit.0:currentUnit
   288 sensor *tmp89 @unit @dead
   289 op strictEqual *tmp90 *tmp89 0
   290 sensor *tmp91 @unit @controller
 
   296 label *label87
   297 label *label84
   298 label *label85
-    * ubind .TYPE
+  299 ubind *tmp9
   300 set :rebindUnit.0:firstUnit @unit
   301 jump *label88 equal :rebindUnit.0:firstUnit null
   302 label *label90
 
   305 jump *label83 always
   306 label *label93
   307 label *label94
-    * ubind .TYPE
+  308 ubind *tmp9
   309 label *label91
   310 op notEqual *tmp100 @unit :rebindUnit.0:firstUnit
   311 sensor *tmp101 :rebindUnit.0:firstUnit @dead
 
   320 ucontrol flag 1
   321 set *tmp85 @unit
   322 jump *label82 always
-    * set *tmp85 null
   323 label *label82
   324 set .UNIT_S1 *tmp85
   325 set :acquireUnit.1:currentUnit .UNIT_P1
-    * set :rebindUnit.1:currentUnit :acquireUnit.1:currentUnit
-    * jump *label97 equal :rebindUnit.1:currentUnit null
-    * ubind :rebindUnit.1:currentUnit
+  326 set :rebindUnit.1:currentUnit .UNIT_P1
+  327 jump *label97 equal :acquireUnit.1:currentUnit null
+  328 ubind :acquireUnit.1:currentUnit
   329 sensor *tmp108 @unit @dead
   330 op strictEqual *tmp109 *tmp108 0
   331 sensor *tmp110 @unit @controller
 
   337 label *label100
   338 label *label97
   339 label *label98
-    * ubind .TYPE
+  340 ubind *tmp9
   341 set :rebindUnit.1:firstUnit @unit
   342 jump *label101 equal :rebindUnit.1:firstUnit null
   343 label *label103
 
   346 jump *label96 always
   347 label *label106
   348 label *label107
-    * ubind .TYPE
+  349 ubind *tmp9
   350 label *label104
   351 op notEqual *tmp119 @unit :rebindUnit.1:firstUnit
   352 sensor *tmp120 :rebindUnit.1:firstUnit @dead
 
   361 ucontrol flag 1
   362 set *tmp104 @unit
   363 jump *label95 always
-    * set *tmp104 null
   364 label *label95
   365 set .UNIT_P1 *tmp104
-    * sensor *tmp123 .UNIT_S1 @firstItem
+  366 sensor *tmp123 *tmp85 @firstItem
   367 op equal *tmp124 *tmp123 @phase-fabric
-    * sensor *tmp125 .UNIT_P1 @firstItem
+  368 sensor *tmp125 *tmp104 @firstItem
   369 op equal *tmp126 *tmp125 @silicon
   370 op or *tmp127 *tmp124 *tmp126
   371 jump *label108 equal *tmp127 false
-    * set :swap.0:a .UNIT_S1
-    * set :swap.0:b .UNIT_P1
-    * set :swap.0:t :swap.0:a
-    * set :swap.0:a :swap.0:b
+  372 set :swap.0:a *tmp85
+  373 set :swap.0:b *tmp104
+  374 set :swap.0:t .UNIT_S1
+  375 set :swap.0:a .UNIT_P1
   376 set :swap.0:b :swap.0:t
   377 label *label110
   378 set .UNIT_S1 :swap.0:a
-    * set .UNIT_P1 :swap.0:b
+  379 set .UNIT_P1 :swap.0:t
   380 label *label108
   381 label *label109
   382 sensor .UNIT_CAPACITY .UNIT_S1 @itemCapacity
 
   392 op sub *tmp136 .DOME_Y .CORE_Y
   393 op len *tmp137 *tmp135 *tmp136
   394 op mul *tmp138 2 *tmp137
-    * sensor *tmp139 :needsFourUnits.2:unit @speed
-    * op div :needsFourUnits.2:travel_time *tmp138 *tmp139
+  395 sensor *tmp139 .UNIT_S1 @speed
+  396 op div :needsFourUnits.2:travel_time *tmp138 .SPEED
   397 op greaterThanEq *tmp134 :needsFourUnits.2:travel_time 47
   398 jump *label113 always
-    * set *tmp134 null
   399 label *label113
   400 set .FOUR_UNITS *tmp134
-    * jump *label114 equal .FOUR_UNITS false
+  401 jump *label114 equal *tmp134 false
   402 set :acquireUnit.2:currentUnit .UNIT_S2
-    * set :rebindUnit.2:currentUnit :acquireUnit.2:currentUnit
-    * jump *label118 equal :rebindUnit.2:currentUnit null
-    * ubind :rebindUnit.2:currentUnit
+  403 set :rebindUnit.2:currentUnit .UNIT_S2
+  404 jump *label118 equal :acquireUnit.2:currentUnit null
+  405 ubind :acquireUnit.2:currentUnit
   406 sensor *tmp147 @unit @dead
   407 op strictEqual *tmp148 *tmp147 0
   408 sensor *tmp149 @unit @controller
 
   414 label *label121
   415 label *label118
   416 label *label119
-    * ubind .TYPE
+  417 ubind *tmp9
   418 set :rebindUnit.2:firstUnit @unit
   419 jump *label122 equal :rebindUnit.2:firstUnit null
   420 label *label124
 
   423 jump *label117 always
   424 label *label127
   425 label *label128
-    * ubind .TYPE
+  426 ubind *tmp9
   427 label *label125
   428 op notEqual *tmp158 @unit :rebindUnit.2:firstUnit
   429 sensor *tmp159 :rebindUnit.2:firstUnit @dead
 
   438 ucontrol flag 1
   439 set *tmp143 @unit
   440 jump *label116 always
-    * set *tmp143 null
   441 label *label116
   442 set .UNIT_S2 *tmp143
   443 set :acquireUnit.3:currentUnit .UNIT_P2
-    * set :rebindUnit.3:currentUnit :acquireUnit.3:currentUnit
-    * jump *label131 equal :rebindUnit.3:currentUnit null
-    * ubind :rebindUnit.3:currentUnit
+  444 set :rebindUnit.3:currentUnit .UNIT_P2
+  445 jump *label131 equal :acquireUnit.3:currentUnit null
+  446 ubind :acquireUnit.3:currentUnit
   447 sensor *tmp166 @unit @dead
   448 op strictEqual *tmp167 *tmp166 0
   449 sensor *tmp168 @unit @controller
 
   455 label *label134
   456 label *label131
   457 label *label132
-    * ubind .TYPE
+  458 ubind *tmp9
   459 set :rebindUnit.3:firstUnit @unit
   460 jump *label135 equal :rebindUnit.3:firstUnit null
   461 label *label137
 
   464 jump *label130 always
   465 label *label140
   466 label *label141
-    * ubind .TYPE
+  467 ubind *tmp9
   468 label *label138
   469 op notEqual *tmp177 @unit :rebindUnit.3:firstUnit
   470 sensor *tmp178 :rebindUnit.3:firstUnit @dead
 
   479 ucontrol flag 1
   480 set *tmp162 @unit
   481 jump *label129 always
-    * set *tmp162 null
   482 label *label129
   483 set .UNIT_P2 *tmp162
   484 sensor *tmp181 .UNIT_S1 @firstItem
   485 op equal *tmp182 *tmp181 @phase-fabric
-    * sensor *tmp183 .UNIT_P2 @firstItem
+  486 sensor *tmp183 *tmp162 @firstItem
   487 op notEqual *tmp184 *tmp183 @phase-fabric
   488 op land *tmp185 *tmp182 *tmp184
   489 jump *label142 equal *tmp185 false
   490 set :swap.1:a .UNIT_S1
-    * set :swap.1:b .UNIT_P2
-    * set :swap.1:t :swap.1:a
-    * set :swap.1:a :swap.1:b
+  491 set :swap.1:b *tmp162
+  492 set :swap.1:t .UNIT_S1
+  493 set :swap.1:a .UNIT_P2
   494 set :swap.1:b :swap.1:t
   495 label *label144
   496 set .UNIT_S1 :swap.1:a
-    * set .UNIT_P2 :swap.1:b
+  497 set .UNIT_P2 :swap.1:t
   498 label *label142
   499 label *label143
-    * sensor *tmp187 .UNIT_S2 @firstItem
+  500 sensor *tmp187 *tmp143 @firstItem
   501 op equal *tmp188 *tmp187 @phase-fabric
   502 sensor *tmp189 .UNIT_P2 @firstItem
   503 op equal *tmp190 *tmp189 @silicon
   504 op or *tmp191 *tmp188 *tmp190
   505 jump *label145 equal *tmp191 false
-    * set :swap.2:a .UNIT_S2
+  506 set :swap.2:a *tmp143
   507 set :swap.2:b .UNIT_P2
-    * set :swap.2:t :swap.2:a
-    * set :swap.2:a :swap.2:b
+  508 set :swap.2:t .UNIT_S2
+  509 set :swap.2:a .UNIT_P2
   510 set :swap.2:b :swap.2:t
   511 label *label147
   512 set .UNIT_S2 :swap.2:a
-    * set .UNIT_P2 :swap.2:b
+  513 set .UNIT_P2 :swap.2:t
   514 label *label145
   515 label *label146
   516 set .GROUP1 "unit  1"
 
   525 set .UNIT_P2 null
   526 set .GROUP1 "unit"
   527 label *label115
-    * op equal *tmp193 .FOUR_UNITS false
+  528 op equal *tmp193 *tmp134 false
   529 sensor *tmp194 .UNIT_S1 @totalItems
   530 sensor *tmp195 .UNIT_S2 @totalItems
   531 op lessThan *tmp196 *tmp194 *tmp195
   532 op or .SUPPLY_S_FIRST *tmp193 *tmp196
-    * op equal *tmp198 .FOUR_UNITS false
+  533 op equal *tmp198 *tmp134 false
   534 sensor *tmp199 .UNIT_P1 @totalItems
   535 sensor *tmp200 .UNIT_P2 @totalItems
   536 op lessThan *tmp201 *tmp199 *tmp200
-    * op or .SUPPLY_P_FIRST *tmp198 *tmp201
+  537 op or .SUPPLY_P_FIRST *tmp193 *tmp201
   538 op add :unitCheck @time 5000
   539 label *label148
   540 sensor *tmp204 switch1 @enabled
 
   544 print "\n"
   545 print "\n"
   546 print "Unit type: [green]"
-    * print .TYPE
+  547 print *tmp9
   548 print "["
   549 print "]"
   550 print "\n"
   551 set :printDomeStatus.0:item @silicon
   552 set :printDomeStatus.0:text "\n[green]Silicon[] status:\n"
-    * print :printDomeStatus.0:text
-    * sensor :printDomeStatus.0:level .DOME :printDomeStatus.0:item
+  553 print "\n[green]Silicon[] status:\n"
+  554 sensor :printDomeStatus.0:level .DOME @silicon
   555 jump *label152 lessThanEq :printDomeStatus.0:level 3
   556 print "  dome:  [green]"
   557 print :printDomeStatus.0:level
 
   571 set :processUnit.0:item @silicon
   572 set :processUnit.0:group .GROUP1
   573 set :processUnit.0:supply .SUPPLY_S_FIRST
-    * set :rebindUnit.4:currentUnit :processUnit.0:unit
-    * jump *label156 equal :rebindUnit.4:currentUnit null
-    * ubind :rebindUnit.4:currentUnit
+  574 set :rebindUnit.4:currentUnit .UNIT_S1
+  575 jump *label156 equal :processUnit.0:unit null
+  576 ubind :processUnit.0:unit
   577 sensor *tmp211 @unit @dead
   578 op strictEqual *tmp212 *tmp211 0
   579 sensor *tmp213 @unit @controller
 
   585 label *label159
   586 label *label156
   587 label *label157
-    * ubind .TYPE
+  588 ubind *tmp9
   589 set :rebindUnit.4:firstUnit @unit
   590 jump *label160 equal :rebindUnit.4:firstUnit null
   591 label *label162
 
   594 jump *label155 always
   595 label *label165
   596 label *label166
-    * ubind .TYPE
+  597 ubind *tmp9
   598 label *label163
   599 op notEqual *tmp222 @unit :rebindUnit.4:firstUnit
   600 sensor *tmp223 :rebindUnit.4:firstUnit @dead
 
   614 op or *tmp229 *tmp227 *tmp228
   615 jump *label167 equal *tmp229 false
   616 sensor *tmp231 @unit @firstItem
-    * jump *label169 notEqual *tmp231 :processUnit.0:item
+  617 jump *label169 notEqual *tmp231 @silicon
   618 set :processUnit.0:state 3
   619 jump *label170 always
   620 label *label169
 
   637 jump *label175 notEqual :processUnit.0:state 2
   638 ucontrol within .CORE_X .CORE_Y 8 *tmp241
   639 jump *label177 equal *tmp241 false
-    * ucontrol itemTake .CORE :processUnit.0:item .UNIT_CAPACITY
+  640 ucontrol itemTake .CORE @silicon .UNIT_CAPACITY
   641 sensor *tmp243 @unit @totalItems
   642 jump *label179 lessThan *tmp243 .UNIT_CAPACITY
   643 ucontrol approach .DOME_X .DOME_Y 6
 
   663 jump *label181 notEqual :processUnit.0:state 3
   664 ucontrol within .DOME_X .DOME_Y 8 *tmp255
   665 jump *label183 equal *tmp255 false
-    * jump *label185 equal :processUnit.0:supply false
+  666 jump *label185 equal .SUPPLY_S_FIRST false
   667 ucontrol itemDrop .DOME .UNIT_CAPACITY
   668 set .MSG ", supplying\n"
   669 jump *label186 always
 
   694 ucontrol flag :processUnit.0:state
   695 sensor *tmp268 @unit @totalItems
   696 print "  "
-    * print :processUnit.0:group
+  697 print .GROUP1
   698 print ":"
   699 print " ["
-    * print :processUnit.0:color
+  700 print "gold"
   701 print "]"
   702 print *tmp268
   703 print "["
 
   715 set :processUnit.0:unit @unit
   716 label *label154
   717 set .UNIT_S1 :processUnit.0:unit
-    * jump *label191 equal .FOUR_UNITS false
+  718 jump *label191 equal *tmp134 false
   719 op equal *tmp273 .SUPPLY_S_FIRST false
   720 set :processUnit.1:unit .UNIT_S2
   721 set :processUnit.1:item @silicon
   722 set :processUnit.1:group .GROUP2
   723 set :processUnit.1:supply *tmp273
-    * set :rebindUnit.5:currentUnit :processUnit.1:unit
-    * jump *label195 equal :rebindUnit.5:currentUnit null
-    * ubind :rebindUnit.5:currentUnit
+  724 set :rebindUnit.5:currentUnit .UNIT_S2
+  725 jump *label195 equal :processUnit.1:unit null
+  726 ubind :processUnit.1:unit
   727 sensor *tmp277 @unit @dead
   728 op strictEqual *tmp278 *tmp277 0
   729 sensor *tmp279 @unit @controller
 
   735 label *label198
   736 label *label195
   737 label *label196
-    * ubind .TYPE
+  738 ubind *tmp9
   739 set :rebindUnit.5:firstUnit @unit
   740 jump *label199 equal :rebindUnit.5:firstUnit null
   741 label *label201
 
   744 jump *label194 always
   745 label *label204
   746 label *label205
-    * ubind .TYPE
+  747 ubind *tmp9
   748 label *label202
   749 op notEqual *tmp288 @unit :rebindUnit.5:firstUnit
   750 sensor *tmp289 :rebindUnit.5:firstUnit @dead
 
   764 op or *tmp295 *tmp293 *tmp294
   765 jump *label206 equal *tmp295 false
   766 sensor *tmp297 @unit @firstItem
-    * jump *label208 notEqual *tmp297 :processUnit.1:item
+  767 jump *label208 notEqual *tmp297 @silicon
   768 set :processUnit.1:state 3
   769 jump *label209 always
   770 label *label208
 
   787 jump *label214 notEqual :processUnit.1:state 2
   788 ucontrol within .CORE_X .CORE_Y 8 *tmp307
   789 jump *label216 equal *tmp307 false
-    * ucontrol itemTake .CORE :processUnit.1:item .UNIT_CAPACITY
+  790 ucontrol itemTake .CORE @silicon .UNIT_CAPACITY
   791 sensor *tmp309 @unit @totalItems
   792 jump *label218 lessThan *tmp309 .UNIT_CAPACITY
   793 ucontrol approach .DOME_X .DOME_Y 6
 
   813 jump *label220 notEqual :processUnit.1:state 3
   814 ucontrol within .DOME_X .DOME_Y 8 *tmp321
   815 jump *label222 equal *tmp321 false
-    * jump *label224 equal :processUnit.1:supply false
+  816 jump *label224 equal *tmp273 false
   817 ucontrol itemDrop .DOME .UNIT_CAPACITY
   818 set .MSG ", supplying\n"
   819 jump *label225 always
 
   844 ucontrol flag :processUnit.1:state
   845 sensor *tmp334 @unit @totalItems
   846 print "  "
-    * print :processUnit.1:group
+  847 print .GROUP2
   848 print ":"
   849 print " ["
-    * print :processUnit.1:color
+  850 print "gold"
   851 print "]"
   852 print *tmp334
   853 print "["
 
   866 label *label193
   867 set .UNIT_S2 :processUnit.1:unit
   868 jump *label230 equal .SUPPLY_S_FIRST false
-    * sensor *tmp339 .UNIT_S1 @totalItems
+  869 sensor *tmp339 :processUnit.0:unit @totalItems
   870 op greaterThan *tmp338 *tmp339 0
   871 jump *label231 always
   872 label *label230
-    * sensor *tmp341 .UNIT_S2 @totalItems
+  873 sensor *tmp341 :processUnit.1:unit @totalItems
   874 op equal *tmp338 *tmp341 0
   875 label *label231
   876 set .SUPPLY_S_FIRST *tmp338
 
   878 label *label192
   879 set :printDomeStatus.1:item @phase-fabric
   880 set :printDomeStatus.1:text "\n[green]Phase fabric[] status:\n"
-    * print :printDomeStatus.1:text
-    * sensor :printDomeStatus.1:level .DOME :printDomeStatus.1:item
+  881 print "\n[green]Phase fabric[] status:\n"
+  882 sensor :printDomeStatus.1:level .DOME @phase-fabric
   883 jump *label233 lessThanEq :printDomeStatus.1:level 3
   884 print "  dome:  [green]"
   885 print :printDomeStatus.1:level
 
   899 set :processUnit.2:item @phase-fabric
   900 set :processUnit.2:group .GROUP1
   901 set :processUnit.2:supply .SUPPLY_P_FIRST
-    * set :rebindUnit.6:currentUnit :processUnit.2:unit
-    * jump *label237 equal :rebindUnit.6:currentUnit null
-    * ubind :rebindUnit.6:currentUnit
+  902 set :rebindUnit.6:currentUnit .UNIT_P1
+  903 jump *label237 equal :processUnit.2:unit null
+  904 ubind :processUnit.2:unit
   905 sensor *tmp349 @unit @dead
   906 op strictEqual *tmp350 *tmp349 0
   907 sensor *tmp351 @unit @controller
 
   913 label *label240
   914 label *label237
   915 label *label238
-    * ubind .TYPE
+  916 ubind *tmp9
   917 set :rebindUnit.6:firstUnit @unit
   918 jump *label241 equal :rebindUnit.6:firstUnit null
   919 label *label243
 
   922 jump *label236 always
   923 label *label246
   924 label *label247
-    * ubind .TYPE
+  925 ubind *tmp9
   926 label *label244
   927 op notEqual *tmp360 @unit :rebindUnit.6:firstUnit
   928 sensor *tmp361 :rebindUnit.6:firstUnit @dead
 
   942 op or *tmp367 *tmp365 *tmp366
   943 jump *label248 equal *tmp367 false
   944 sensor *tmp369 @unit @firstItem
-    * jump *label250 notEqual *tmp369 :processUnit.2:item
+  945 jump *label250 notEqual *tmp369 @phase-fabric
   946 set :processUnit.2:state 3
   947 jump *label251 always
   948 label *label250
 
   965 jump *label256 notEqual :processUnit.2:state 2
   966 ucontrol within .CORE_X .CORE_Y 8 *tmp379
   967 jump *label258 equal *tmp379 false
-    * ucontrol itemTake .CORE :processUnit.2:item .UNIT_CAPACITY
+  968 ucontrol itemTake .CORE @phase-fabric .UNIT_CAPACITY
   969 sensor *tmp381 @unit @totalItems
   970 jump *label260 lessThan *tmp381 .UNIT_CAPACITY
   971 ucontrol approach .DOME_X .DOME_Y 6
 
   991 jump *label262 notEqual :processUnit.2:state 3
   992 ucontrol within .DOME_X .DOME_Y 8 *tmp393
   993 jump *label264 equal *tmp393 false
-    * jump *label266 equal :processUnit.2:supply false
+  994 jump *label266 equal .SUPPLY_P_FIRST false
   995 ucontrol itemDrop .DOME .UNIT_CAPACITY
   996 set .MSG ", supplying\n"
   997 jump *label267 always
 
  1022 ucontrol flag :processUnit.2:state
  1023 sensor *tmp406 @unit @totalItems
  1024 print "  "
-    * print :processUnit.2:group
+ 1025 print .GROUP1
  1026 print ":"
  1027 print " ["
-    * print :processUnit.2:color
+ 1028 print "gold"
  1029 print "]"
  1030 print *tmp406
  1031 print "["
 
  1043 set :processUnit.2:unit @unit
  1044 label *label235
  1045 set .UNIT_P1 :processUnit.2:unit
-    * jump *label272 equal .FOUR_UNITS false
+ 1046 jump *label272 equal *tmp134 false
  1047 op equal *tmp411 .SUPPLY_P_FIRST false
  1048 set :processUnit.3:unit .UNIT_P2
  1049 set :processUnit.3:item @phase-fabric
  1050 set :processUnit.3:group .GROUP2
  1051 set :processUnit.3:supply *tmp411
-    * set :rebindUnit.7:currentUnit :processUnit.3:unit
-    * jump *label276 equal :rebindUnit.7:currentUnit null
-    * ubind :rebindUnit.7:currentUnit
+ 1052 set :rebindUnit.7:currentUnit .UNIT_P2
+ 1053 jump *label276 equal :processUnit.3:unit null
+ 1054 ubind :processUnit.3:unit
  1055 sensor *tmp415 @unit @dead
  1056 op strictEqual *tmp416 *tmp415 0
  1057 sensor *tmp417 @unit @controller
 
  1063 label *label279
  1064 label *label276
  1065 label *label277
-    * ubind .TYPE
+ 1066 ubind *tmp9
  1067 set :rebindUnit.7:firstUnit @unit
  1068 jump *label280 equal :rebindUnit.7:firstUnit null
  1069 label *label282
 
  1072 jump *label275 always
  1073 label *label285
  1074 label *label286
-    * ubind .TYPE
+ 1075 ubind *tmp9
  1076 label *label283
  1077 op notEqual *tmp426 @unit :rebindUnit.7:firstUnit
  1078 sensor *tmp427 :rebindUnit.7:firstUnit @dead
 
  1092 op or *tmp433 *tmp431 *tmp432
  1093 jump *label287 equal *tmp433 false
  1094 sensor *tmp435 @unit @firstItem
-    * jump *label289 notEqual *tmp435 :processUnit.3:item
+ 1095 jump *label289 notEqual *tmp435 @phase-fabric
  1096 set :processUnit.3:state 3
  1097 jump *label290 always
  1098 label *label289
 
  1115 jump *label295 notEqual :processUnit.3:state 2
  1116 ucontrol within .CORE_X .CORE_Y 8 *tmp445
  1117 jump *label297 equal *tmp445 false
-    * ucontrol itemTake .CORE :processUnit.3:item .UNIT_CAPACITY
+ 1118 ucontrol itemTake .CORE @phase-fabric .UNIT_CAPACITY
  1119 sensor *tmp447 @unit @totalItems
  1120 jump *label299 lessThan *tmp447 .UNIT_CAPACITY
  1121 ucontrol approach .DOME_X .DOME_Y 6
 
  1141 jump *label301 notEqual :processUnit.3:state 3
  1142 ucontrol within .DOME_X .DOME_Y 8 *tmp459
  1143 jump *label303 equal *tmp459 false
-    * jump *label305 equal :processUnit.3:supply false
+ 1144 jump *label305 equal *tmp411 false
  1145 ucontrol itemDrop .DOME .UNIT_CAPACITY
  1146 set .MSG ", supplying\n"
  1147 jump *label306 always
 
  1172 ucontrol flag :processUnit.3:state
  1173 sensor *tmp472 @unit @totalItems
  1174 print "  "
-    * print :processUnit.3:group
+ 1175 print .GROUP2
  1176 print ":"
  1177 print " ["
-    * print :processUnit.3:color
+ 1178 print "gold"
  1179 print "]"
  1180 print *tmp472
  1181 print "["
 
  1194 label *label274
  1195 set .UNIT_P2 :processUnit.3:unit
  1196 jump *label311 equal .SUPPLY_P_FIRST false
-    * sensor *tmp477 .UNIT_P1 @totalItems
+ 1197 sensor *tmp477 :processUnit.2:unit @totalItems
  1198 op greaterThan *tmp476 *tmp477 0
  1199 jump *label312 always
  1200 label *label311
-    * sensor *tmp479 .UNIT_P2 @totalItems
+ 1201 sensor *tmp479 :processUnit.3:unit @totalItems
  1202 op equal *tmp476 *tmp479 0
  1203 label *label312
  1204 set .SUPPLY_P_FIRST *tmp476
 
  1212 print " "
  1213 print "ms"
  1214 printflush message1
-    * op notEqual *tmp483 .TYPE UNIT_TYPE
+ 1215 op notEqual *tmp483 *tmp9 UNIT_TYPE
  1216 op greaterThan *tmp484 :unitCheck @time
  1217 op land *tmp485 *tmp483 *tmp484
  1218 jump *label313 equal *tmp485 false
 
  1221 set :areUnitsAvailable.2:free 0
  1222 set :areUnitsAvailable.2:occupied 0
  1223 set :areUnitsAvailable.2:needed 0
-    * ubind :areUnitsAvailable.2:type
+ 1224 ubind UNIT_TYPE
  1225 set :areUnitsAvailable.2:firstUnit @unit
  1226 jump *label316 equal :areUnitsAvailable.2:firstUnit null
  1227 set :needsFourUnits.3:unit @unit
  1228 op sub *tmp491 .DOME_X .CORE_X
  1229 op sub *tmp492 .DOME_Y .CORE_Y
-    * op len *tmp493 *tmp491 *tmp492
-    * op mul *tmp494 2 *tmp493
+ 1230 op len *tmp493 *tmp135 *tmp136
+ 1231 op mul *tmp494 2 *tmp137
  1232 sensor *tmp495 :needsFourUnits.3:unit @speed
-    * op div :needsFourUnits.3:travel_time *tmp494 *tmp495
+ 1233 op div :needsFourUnits.3:travel_time *tmp138 *tmp495
  1234 op greaterThanEq *tmp490 :needsFourUnits.3:travel_time 47
  1235 jump *label318 always
-    * set *tmp490 null
  1236 label *label318
  1237 jump *label319 equal *tmp490 false
  1238 set *tmp498 4
 
  1249 op or *tmp503 *tmp500 *tmp502
  1250 jump *label324 equal *tmp503 false
  1251 op add :areUnitsAvailable.2:free :areUnitsAvailable.2:free 1
-    * jump *label326 lessThan :areUnitsAvailable.2:free :areUnitsAvailable.2:needed
+ 1252 jump *label326 lessThan :areUnitsAvailable.2:free *tmp498
  1253 set *tmp487 true
  1254 jump *label315 always
  1255 label *label326
 
  1258 label *label324
  1259 op add :areUnitsAvailable.2:occupied :areUnitsAvailable.2:occupied 1
  1260 label *label325
-    * ubind :areUnitsAvailable.2:type
+ 1261 ubind UNIT_TYPE
  1262 label *label322
  1263 op notEqual *tmp508 @unit :areUnitsAvailable.2:firstUnit
  1264 sensor *tmp509 :areUnitsAvailable.2:firstUnit @dead
 
  1268 label *label323
  1269 label *label316
  1270 label *label317
-    * jump *label328 equal :areUnitsAvailable.2:output false
-    * print :areUnitsAvailable.2:type
+ 1271 jump *label328 equal false false
+ 1272 print UNIT_TYPE
  1273 print ":"
  1274 print " occupied: "
  1275 print :areUnitsAvailable.2:occupied
 
  1286 label *label329
  1287 set *tmp487 false
  1288 jump *label315 always
-    * set *tmp487 null
  1289 label *label315
  1290 jump *label332 equal *tmp487 false
  1291 end

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-48 instructions):
 
    62 printflush null
    63 print "[gold]Looking for suitable unit type:[]"
    64 print "\n"
-    * set :areUnitsAvailable.0:type UNIT_TYPE
-    * set :areUnitsAvailable.0:output true
    65 set :areUnitsAvailable.0:free 0
    66 set :areUnitsAvailable.0:occupied 0
    67 set :areUnitsAvailable.0:needed 0
 
   152 set :chooseUnitType.0:type @mono
   153 label *label44
   154 jump *label51 equal :chooseUnitType.0:type UNIT_TYPE
-    * set :areUnitsAvailable.1:type :chooseUnitType.0:type
-    * set :areUnitsAvailable.1:output true
   155 set :areUnitsAvailable.1:free 0
   156 set :areUnitsAvailable.1:occupied 0
   157 set :areUnitsAvailable.1:needed 0
 
   239 label *label24
   240 set *tmp9 null
   241 label *label21
-    * set .TYPE *tmp9
   242 print "[gold]Binding units..."
   243 printflush message1
   244 set .UNIT_P2 null
   245 set .UNIT_S2 null
-    * set .UNIT_P1 .UNIT_P2
-    * set .UNIT_S1 .UNIT_S2
+  246 set .UNIT_P1 null
+  247 set .UNIT_S1 null
   248 set :rebindUnits.0:count 0
   249 ubind *tmp9
   250 set :rebindUnits.0:firstUnit @unit
 
   277 label *label77
   278 label *label72
   279 set :acquireUnit.0:currentUnit .UNIT_S1
-    * set :rebindUnit.0:currentUnit .UNIT_S1
-    * jump *label84 equal :acquireUnit.0:currentUnit null
-    * ubind :acquireUnit.0:currentUnit
+  280 jump *label84 equal .UNIT_S1 null
+  281 ubind .UNIT_S1
   282 sensor *tmp89 @unit @dead
   283 op strictEqual *tmp90 *tmp89 0
   284 sensor *tmp91 @unit @controller
 
   317 label *label82
   318 set .UNIT_S1 *tmp85
   319 set :acquireUnit.1:currentUnit .UNIT_P1
-    * set :rebindUnit.1:currentUnit .UNIT_P1
-    * jump *label97 equal :acquireUnit.1:currentUnit null
-    * ubind :acquireUnit.1:currentUnit
+  320 jump *label97 equal .UNIT_P1 null
+  321 ubind .UNIT_P1
   322 sensor *tmp108 @unit @dead
   323 op strictEqual *tmp109 *tmp108 0
   324 sensor *tmp110 @unit @controller
 
   362 op equal *tmp126 *tmp125 @silicon
   363 op or *tmp127 *tmp124 *tmp126
   364 jump *label108 equal *tmp127 false
-    * set :swap.0:a *tmp85
-    * set :swap.0:b *tmp104
-    * set :swap.0:t .UNIT_S1
-    * set :swap.0:a .UNIT_P1
-    * set :swap.0:b :swap.0:t
+  365 set :swap.0:t *tmp85
+  366 set :swap.0:a *tmp104
+  367 set :swap.0:b .UNIT_S1
   368 label *label110
-    * set .UNIT_S1 :swap.0:a
+  369 set .UNIT_S1 .UNIT_P1
   370 set .UNIT_P1 :swap.0:t
   371 label *label108
   372 label *label109
 
   378 stop
   379 label *label111
   380 label *label112
-    * set :needsFourUnits.2:unit .UNIT_S1
   381 op sub *tmp135 .DOME_X .CORE_X
   382 op sub *tmp136 .DOME_Y .CORE_Y
   383 op len *tmp137 *tmp135 *tmp136
 
   387 op greaterThanEq *tmp134 :needsFourUnits.2:travel_time 47
   388 jump *label113 always
   389 label *label113
-    * set .FOUR_UNITS *tmp134
   390 jump *label114 equal *tmp134 false
   391 set :acquireUnit.2:currentUnit .UNIT_S2
-    * set :rebindUnit.2:currentUnit .UNIT_S2
-    * jump *label118 equal :acquireUnit.2:currentUnit null
-    * ubind :acquireUnit.2:currentUnit
+  392 jump *label118 equal .UNIT_S2 null
+  393 ubind .UNIT_S2
   394 sensor *tmp147 @unit @dead
   395 op strictEqual *tmp148 *tmp147 0
   396 sensor *tmp149 @unit @controller
 
   429 label *label116
   430 set .UNIT_S2 *tmp143
   431 set :acquireUnit.3:currentUnit .UNIT_P2
-    * set :rebindUnit.3:currentUnit .UNIT_P2
-    * jump *label131 equal :acquireUnit.3:currentUnit null
-    * ubind :acquireUnit.3:currentUnit
+  432 jump *label131 equal .UNIT_P2 null
+  433 ubind .UNIT_P2
   434 sensor *tmp166 @unit @dead
   435 op strictEqual *tmp167 *tmp166 0
   436 sensor *tmp168 @unit @controller
 
   474 op notEqual *tmp184 *tmp183 @phase-fabric
   475 op land *tmp185 *tmp182 *tmp184
   476 jump *label142 equal *tmp185 false
-    * set :swap.1:a .UNIT_S1
-    * set :swap.1:b *tmp162
   477 set :swap.1:t .UNIT_S1
-    * set :swap.1:a .UNIT_P2
-    * set :swap.1:b :swap.1:t
+  478 set :swap.1:a *tmp162
+  479 set :swap.1:b .UNIT_S1
   480 label *label144
-    * set .UNIT_S1 :swap.1:a
+  481 set .UNIT_S1 .UNIT_P2
   482 set .UNIT_P2 :swap.1:t
   483 label *label142
   484 label *label143
 
   488 op equal *tmp190 *tmp189 @silicon
   489 op or *tmp191 *tmp188 *tmp190
   490 jump *label145 equal *tmp191 false
-    * set :swap.2:a *tmp143
-    * set :swap.2:b .UNIT_P2
-    * set :swap.2:t .UNIT_S2
+  491 set :swap.2:t *tmp143
   492 set :swap.2:a .UNIT_P2
-    * set :swap.2:b :swap.2:t
+  493 set :swap.2:b .UNIT_S2
   494 label *label147
-    * set .UNIT_S2 :swap.2:a
+  495 set .UNIT_S2 .UNIT_P2
   496 set .UNIT_P2 :swap.2:t
   497 label *label145
   498 label *label146
 
   513 sensor *tmp195 .UNIT_S2 @totalItems
   514 op lessThan *tmp196 *tmp194 *tmp195
   515 op or .SUPPLY_S_FIRST *tmp193 *tmp196
-    * op equal *tmp198 *tmp134 false
   516 sensor *tmp199 .UNIT_P1 @totalItems
   517 sensor *tmp200 .UNIT_P2 @totalItems
   518 op lessThan *tmp201 *tmp199 *tmp200
 
   530 print "["
   531 print "]"
   532 print "\n"
-    * set :printDomeStatus.0:item @silicon
-    * set :printDomeStatus.0:text "\n[green]Silicon[] status:\n"
   533 print "\n[green]Silicon[] status:\n"
   534 sensor :printDomeStatus.0:level .DOME @silicon
   535 jump *label152 lessThanEq :printDomeStatus.0:level 3
 
   548 label *label153
   549 label *label151
   550 set :processUnit.0:unit .UNIT_S1
-    * set :processUnit.0:item @silicon
-    * set :processUnit.0:group .GROUP1
-    * set :processUnit.0:supply .SUPPLY_S_FIRST
-    * set :rebindUnit.4:currentUnit .UNIT_S1
-    * jump *label156 equal :processUnit.0:unit null
-    * ubind :processUnit.0:unit
+  551 jump *label156 equal .UNIT_S1 null
+  552 ubind .UNIT_S1
   553 sensor *tmp211 @unit @dead
   554 op strictEqual *tmp212 *tmp211 0
   555 sensor *tmp213 @unit @controller
 
   584 label *label155
   585 sensor :processUnit.0:state @unit @flag
   586 set :processUnit.0:distance -1
-    * set :processUnit.0:color "gold"
   587 op lessThan *tmp227 :processUnit.0:state 2
   588 op greaterThan *tmp228 :processUnit.0:state 3
   589 op or *tmp229 *tmp227 *tmp228
 
   693 jump *label191 equal *tmp134 false
   694 op equal *tmp273 .SUPPLY_S_FIRST false
   695 set :processUnit.1:unit .UNIT_S2
-    * set :processUnit.1:item @silicon
-    * set :processUnit.1:group .GROUP2
-    * set :processUnit.1:supply *tmp273
-    * set :rebindUnit.5:currentUnit .UNIT_S2
-    * jump *label195 equal :processUnit.1:unit null
-    * ubind :processUnit.1:unit
+  696 jump *label195 equal .UNIT_S2 null
+  697 ubind .UNIT_S2
   698 sensor *tmp277 @unit @dead
   699 op strictEqual *tmp278 *tmp277 0
   700 sensor *tmp279 @unit @controller
 
   729 label *label194
   730 sensor :processUnit.1:state @unit @flag
   731 set :processUnit.1:distance -1
-    * set :processUnit.1:color "gold"
   732 op lessThan *tmp293 :processUnit.1:state 2
   733 op greaterThan *tmp294 :processUnit.1:state 3
   734 op or *tmp295 *tmp293 *tmp294
 
   846 set .SUPPLY_S_FIRST *tmp338
   847 label *label191
   848 label *label192
-    * set :printDomeStatus.1:item @phase-fabric
-    * set :printDomeStatus.1:text "\n[green]Phase fabric[] status:\n"
   849 print "\n[green]Phase fabric[] status:\n"
   850 sensor :printDomeStatus.1:level .DOME @phase-fabric
   851 jump *label233 lessThanEq :printDomeStatus.1:level 3
 
   864 label *label234
   865 label *label232
   866 set :processUnit.2:unit .UNIT_P1
-    * set :processUnit.2:item @phase-fabric
-    * set :processUnit.2:group .GROUP1
-    * set :processUnit.2:supply .SUPPLY_P_FIRST
-    * set :rebindUnit.6:currentUnit .UNIT_P1
-    * jump *label237 equal :processUnit.2:unit null
-    * ubind :processUnit.2:unit
+  867 jump *label237 equal .UNIT_P1 null
+  868 ubind .UNIT_P1
   869 sensor *tmp349 @unit @dead
   870 op strictEqual *tmp350 *tmp349 0
   871 sensor *tmp351 @unit @controller
 
   900 label *label236
   901 sensor :processUnit.2:state @unit @flag
   902 set :processUnit.2:distance -1
-    * set :processUnit.2:color "gold"
   903 op lessThan *tmp365 :processUnit.2:state 2
   904 op greaterThan *tmp366 :processUnit.2:state 3
   905 op or *tmp367 *tmp365 *tmp366
 
  1009 jump *label272 equal *tmp134 false
  1010 op equal *tmp411 .SUPPLY_P_FIRST false
  1011 set :processUnit.3:unit .UNIT_P2
-    * set :processUnit.3:item @phase-fabric
-    * set :processUnit.3:group .GROUP2
-    * set :processUnit.3:supply *tmp411
-    * set :rebindUnit.7:currentUnit .UNIT_P2
-    * jump *label276 equal :processUnit.3:unit null
-    * ubind :processUnit.3:unit
+ 1012 jump *label276 equal .UNIT_P2 null
+ 1013 ubind .UNIT_P2
  1014 sensor *tmp415 @unit @dead
  1015 op strictEqual *tmp416 *tmp415 0
  1016 sensor *tmp417 @unit @controller
 
  1045 label *label275
  1046 sensor :processUnit.3:state @unit @flag
  1047 set :processUnit.3:distance -1
-    * set :processUnit.3:color "gold"
  1048 op lessThan *tmp431 :processUnit.3:state 2
  1049 op greaterThan *tmp432 :processUnit.3:state 3
  1050 op or *tmp433 *tmp431 *tmp432
 
  1174 op greaterThan *tmp484 :unitCheck @time
  1175 op land *tmp485 *tmp483 *tmp484
  1176 jump *label313 equal *tmp485 false
-    * set :areUnitsAvailable.2:type UNIT_TYPE
-    * set :areUnitsAvailable.2:output false
  1177 set :areUnitsAvailable.2:free 0
  1178 set :areUnitsAvailable.2:occupied 0
  1179 set :areUnitsAvailable.2:needed 0
 
  1181 set :areUnitsAvailable.2:firstUnit @unit
  1182 jump *label316 equal :areUnitsAvailable.2:firstUnit null
  1183 set :needsFourUnits.3:unit @unit
-    * op sub *tmp491 .DOME_X .CORE_X
-    * op sub *tmp492 .DOME_Y .CORE_Y
-    * op len *tmp493 *tmp135 *tmp136
-    * op mul *tmp494 2 *tmp137
  1184 sensor *tmp495 :needsFourUnits.3:unit @speed
  1185 op div :needsFourUnits.3:travel_time *tmp138 *tmp495
  1186 op greaterThanEq *tmp490 :needsFourUnits.3:travel_time 47

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 3 (-12 instructions):
 
   276 jump *label75 notEqual *tmp84 false
   277 label *label77
   278 label *label72
-    * set :acquireUnit.0:currentUnit .UNIT_S1
   279 jump *label84 equal .UNIT_S1 null
   280 ubind .UNIT_S1
   281 sensor *tmp89 @unit @dead
 
   315 jump *label82 always
   316 label *label82
   317 set .UNIT_S1 *tmp85
-    * set :acquireUnit.1:currentUnit .UNIT_P1
   318 jump *label97 equal .UNIT_P1 null
   319 ubind .UNIT_P1
   320 sensor *tmp108 @unit @dead
 
   361 op or *tmp127 *tmp124 *tmp126
   362 jump *label108 equal *tmp127 false
   363 set :swap.0:t *tmp85
-    * set :swap.0:a *tmp104
-    * set :swap.0:b .UNIT_S1
+  364 set :swap.0:b *tmp85
   365 label *label110
-    * set .UNIT_S1 .UNIT_P1
-    * set .UNIT_P1 :swap.0:t
+  366 set .UNIT_S1 *tmp104
+  367 set .UNIT_P1 *tmp85
   368 label *label108
   369 label *label109
   370 sensor .UNIT_CAPACITY .UNIT_S1 @itemCapacity
 
   385 jump *label113 always
   386 label *label113
   387 jump *label114 equal *tmp134 false
-    * set :acquireUnit.2:currentUnit .UNIT_S2
   388 jump *label118 equal .UNIT_S2 null
   389 ubind .UNIT_S2
   390 sensor *tmp147 @unit @dead
 
   424 jump *label116 always
   425 label *label116
   426 set .UNIT_S2 *tmp143
-    * set :acquireUnit.3:currentUnit .UNIT_P2
   427 jump *label131 equal .UNIT_P2 null
   428 ubind .UNIT_P2
   429 sensor *tmp166 @unit @dead
 
   470 op land *tmp185 *tmp182 *tmp184
   471 jump *label142 equal *tmp185 false
   472 set :swap.1:t .UNIT_S1
-    * set :swap.1:a *tmp162
-    * set :swap.1:b .UNIT_S1
   473 label *label144
-    * set .UNIT_S1 .UNIT_P2
+  474 set .UNIT_S1 *tmp162
   475 set .UNIT_P2 :swap.1:t
   476 label *label142
   477 label *label143
 
   482 op or *tmp191 *tmp188 *tmp190
   483 jump *label145 equal *tmp191 false
   484 set :swap.2:t *tmp143
-    * set :swap.2:a .UNIT_P2
-    * set :swap.2:b .UNIT_S2
+  485 set :swap.2:b *tmp143
   486 label *label147
   487 set .UNIT_S2 .UNIT_P2
-    * set .UNIT_P2 :swap.2:t
+  488 set .UNIT_P2 *tmp143
   489 label *label145
   490 label *label146
   491 set .GROUP1 "unit  1"
 
   539 print "\n"
   540 label *label153
   541 label *label151
-    * set :processUnit.0:unit .UNIT_S1
   542 jump *label156 equal .UNIT_S1 null
   543 ubind .UNIT_S1
   544 sensor *tmp211 @unit @dead
 
   683 set .UNIT_S1 :processUnit.0:unit
   684 jump *label191 equal *tmp134 false
   685 op equal *tmp273 .SUPPLY_S_FIRST false
-    * set :processUnit.1:unit .UNIT_S2
   686 jump *label195 equal .UNIT_S2 null
   687 ubind .UNIT_S2
   688 sensor *tmp277 @unit @dead
 
   853 print "\n"
   854 label *label234
   855 label *label232
-    * set :processUnit.2:unit .UNIT_P1
   856 jump *label237 equal .UNIT_P1 null
   857 ubind .UNIT_P1
   858 sensor *tmp349 @unit @dead
 
   997 set .UNIT_P1 :processUnit.2:unit
   998 jump *label272 equal *tmp134 false
   999 op equal *tmp411 .SUPPLY_P_FIRST false
-    * set :processUnit.3:unit .UNIT_P2
  1000 jump *label276 equal .UNIT_P2 null
  1001 ubind .UNIT_P2
  1002 sensor *tmp415 @unit @dead

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 4 (-4 instructions):
 
   360 op equal *tmp126 *tmp125 @silicon
   361 op or *tmp127 *tmp124 *tmp126
   362 jump *label108 equal *tmp127 false
-    * set :swap.0:t *tmp85
-    * set :swap.0:b *tmp85
   363 label *label110
   364 set .UNIT_S1 *tmp104
   365 set .UNIT_P1 *tmp85
 
   479 op equal *tmp190 *tmp189 @silicon
   480 op or *tmp191 *tmp188 *tmp190
   481 jump *label145 equal *tmp191 false
-    * set :swap.2:t *tmp143
-    * set :swap.2:b *tmp143
   482 label *label147
   483 set .UNIT_S2 .UNIT_P2
   484 set .UNIT_P2 *tmp143

Modifications by Iterated phase, Loop Optimization, pass 1, iteration 1:
 
     4 set .DOME dome1
     5 label *label2
     6 jump *label4 notEqual .DOME null
+    7 label *label337
     8 print "[gold]Waiting for an overdrive dome to be connected..."
     9 printflush message1
    10 set .DOME dome1
    11 label *label3
-    * jump *label2 always
+   12 jump *label337 equal .DOME null
    13 label *label4
    14 print "[gold]Locating core..."
    15 printflush message1

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 1 (-2 instructions):
 
    69 ubind UNIT_TYPE
    70 set :areUnitsAvailable.0:firstUnit @unit
    71 jump *label26 equal :areUnitsAvailable.0:firstUnit null
+   72 set *tmp21 2
    73 set :needsFourUnits.0:unit @unit
    74 op sub *tmp14 .DOME_X .CORE_X
    75 op sub *tmp15 .DOME_Y .CORE_Y
 
    80 op greaterThanEq *tmp13 :needsFourUnits.0:travel_time 47
    81 jump *label28 always
    82 label *label28
-    * jump *label29 equal *tmp13 false
+   83 jump *label30 equal *tmp13 false
    84 set *tmp21 4
    85 jump *label30 always
-    * label *label29
-    * set *tmp21 2
    86 label *label30
    87 set :areUnitsAvailable.0:needed *tmp21
    88 label *label31
 
   158 ubind :chooseUnitType.0:type
   159 set :areUnitsAvailable.1:firstUnit @unit
   160 jump *label54 equal :areUnitsAvailable.1:firstUnit null
+  161 set *tmp53 2
   162 set :needsFourUnits.1:unit @unit
   163 op sub *tmp46 .DOME_X .CORE_X
   164 op sub *tmp47 .DOME_Y .CORE_Y
 
   169 op greaterThanEq *tmp45 :needsFourUnits.1:travel_time 47
   170 jump *label56 always
   171 label *label56
-    * jump *label57 equal *tmp45 false
+  172 jump *label58 equal *tmp45 false
   173 set *tmp53 4
   174 jump *label58 always
-    * label *label57
-    * set *tmp53 2
   175 label *label58
   176 set :areUnitsAvailable.1:needed *tmp53
   177 label *label59
 
   822 set .UNIT_S2 :processUnit.1:unit
   823 jump *label230 equal .SUPPLY_S_FIRST false
   824 sensor *tmp339 :processUnit.0:unit @totalItems
-    * op greaterThan *tmp338 *tmp339 0
+  825 op greaterThan .SUPPLY_S_FIRST *tmp339 0
   826 jump *label231 always
   827 label *label230
   828 sensor *tmp341 :processUnit.1:unit @totalItems
-    * op equal *tmp338 *tmp341 0
+  829 op equal .SUPPLY_S_FIRST *tmp341 0
   830 label *label231
-    * set .SUPPLY_S_FIRST *tmp338
   831 label *label191
   832 label *label192
   833 print "\n[green]Phase fabric[] status:\n"
 
  1135 set .UNIT_P2 :processUnit.3:unit
  1136 jump *label311 equal .SUPPLY_P_FIRST false
  1137 sensor *tmp477 :processUnit.2:unit @totalItems
-    * op greaterThan *tmp476 *tmp477 0
+ 1138 op greaterThan .SUPPLY_P_FIRST *tmp477 0
  1139 jump *label312 always
  1140 label *label311
  1141 sensor *tmp479 :processUnit.3:unit @totalItems
-    * op equal *tmp476 *tmp479 0
+ 1142 op equal .SUPPLY_P_FIRST *tmp479 0
  1143 label *label312
-    * set .SUPPLY_P_FIRST *tmp476
  1144 label *label272
  1145 label *label273
  1146 op sub *tmp481 @time :start
 
  1161 ubind UNIT_TYPE
  1162 set :areUnitsAvailable.2:firstUnit @unit
  1163 jump *label316 equal :areUnitsAvailable.2:firstUnit null
+ 1164 set *tmp498 2
  1165 set :needsFourUnits.3:unit @unit
  1166 sensor *tmp495 :needsFourUnits.3:unit @speed
  1167 op div :needsFourUnits.3:travel_time *tmp138 *tmp495
  1168 op greaterThanEq *tmp490 :needsFourUnits.3:travel_time 47
  1169 jump *label318 always
  1170 label *label318
-    * jump *label319 equal *tmp490 false
+ 1171 jump *label320 equal *tmp490 false
  1172 set *tmp498 4
  1173 jump *label320 always
-    * label *label319
-    * set *tmp498 2
  1174 label *label320
  1175 set :areUnitsAvailable.2:needed *tmp498
  1176 label *label321

Modifications by Unroll iteration loop at line 169:9 (+7 instructions):
 
    15 printflush message1
    16 set .CORE null
    17 label *label5
-    * setaddr *tmp1 *label11
-    * set :locateDomeAndCore.0:type @flare
-    * jump *label8 always
-    * multilabel *label11 marker0
-    * setaddr *tmp1 *label12
-    * set :locateDomeAndCore.0:type @poly
-    * jump *label8 always
-    * multilabel *label12 marker0
-    * setaddr *tmp1 *label13
-    * set :locateDomeAndCore.0:type @mega
-    * jump *label8 always
-    * multilabel *label13 marker0
-    * setaddr *tmp1 *label14
-    * set :locateDomeAndCore.0:type @mono
-    * label *label8
-    * set :locateCore.0:type :locateDomeAndCore.0:type
-    * setaddr :locateCore.0*retaddr *label15
-    * call *label0 :locateCore.0*retval
-    * label *label15
-    * jump *label16 equal :locateCore.0*retval false
-    * jump *label1 always
-    * label *label16
-    * label *label17
-    * label *label9
-    * multijump *tmp1 0 0 marker0
-    * multilabel *label14 marker0
-    * label *label10
+   18 set :locateDomeAndCore.0:type @flare
+   19 label *label338
+   20 set :locateCore.0:type :locateDomeAndCore.0:type
+   21 setaddr :locateCore.0*retaddr *label339
+   22 call *label0 :locateCore.0*retval
+   23 label *label339
+   24 jump *label340 equal :locateCore.0*retval false
+   25 jump *label1 always
+   26 label *label340
+   27 label *label341
+   28 label *label342
+   29 set :locateDomeAndCore.0:type @poly
+   30 label *label345
+   31 set :locateCore.0:type :locateDomeAndCore.0:type
+   32 setaddr :locateCore.0*retaddr *label346
+   33 call *label0 :locateCore.0*retval
+   34 label *label346
+   35 jump *label347 equal :locateCore.0*retval false
+   36 jump *label1 always
+   37 label *label347
+   38 label *label348
+   39 label *label349
+   40 set :locateDomeAndCore.0:type @mega
+   41 label *label352
+   42 set :locateCore.0:type :locateDomeAndCore.0:type
+   43 setaddr :locateCore.0*retaddr *label353
+   44 call *label0 :locateCore.0*retval
+   45 label *label353
+   46 jump *label354 equal :locateCore.0*retval false
+   47 jump *label1 always
+   48 label *label354
+   49 label *label355
+   50 label *label356
+   51 set :locateDomeAndCore.0:type @mono
+   52 label *label359
+   53 set :locateCore.0:type :locateDomeAndCore.0:type
+   54 setaddr :locateCore.0*retaddr *label360
+   55 call *label0 :locateCore.0*retval
+   56 label *label360
+   57 jump *label361 equal :locateCore.0*retval false
+   58 jump *label1 always
+   59 label *label361
+   60 label *label362
+   61 label *label363
+   62 label *label10
    63 label *label6
    64 jump *label5 always
    65 label *label7

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
     3 remark "Do not modify anything below this line."
     4 set .DOME dome1
     5 label *label2
-    * jump *label4 notEqual .DOME null
+    6 jump *label4 notEqual dome1 null
     7 label *label337
     8 print "[gold]Waiting for an overdrive dome to be connected..."
     9 printflush message1
    10 set .DOME dome1
    11 label *label3
-    * jump *label337 equal .DOME null
+   12 jump *label337 equal dome1 null
    13 label *label4
    14 print "[gold]Locating core..."
    15 printflush message1
 
    17 label *label5
    18 set :locateDomeAndCore.0:type @flare
    19 label *label338
-    * set :locateCore.0:type :locateDomeAndCore.0:type
+   20 set :locateCore.0:type @flare
    21 setaddr :locateCore.0*retaddr *label339
    22 call *label0 :locateCore.0*retval
    23 label *label339
 
    28 label *label342
    29 set :locateDomeAndCore.0:type @poly
    30 label *label345
-    * set :locateCore.0:type :locateDomeAndCore.0:type
+   31 set :locateCore.0:type @poly
    32 setaddr :locateCore.0*retaddr *label346
    33 call *label0 :locateCore.0*retval
    34 label *label346
 
    39 label *label349
    40 set :locateDomeAndCore.0:type @mega
    41 label *label352
-    * set :locateCore.0:type :locateDomeAndCore.0:type
+   42 set :locateCore.0:type @mega
    43 setaddr :locateCore.0*retaddr *label353
    44 call *label0 :locateCore.0*retval
    45 label *label353
 
    50 label *label356
    51 set :locateDomeAndCore.0:type @mono
    52 label *label359
-    * set :locateCore.0:type :locateDomeAndCore.0:type
+   53 set :locateCore.0:type @mono
    54 setaddr :locateCore.0*retaddr *label360
    55 call *label0 :locateCore.0*retval
    56 label *label360

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-4 instructions):
 
    15 printflush message1
    16 set .CORE null
    17 label *label5
-    * set :locateDomeAndCore.0:type @flare
    18 label *label338
    19 set :locateCore.0:type @flare
    20 setaddr :locateCore.0*retaddr *label339
 
    25 label *label340
    26 label *label341
    27 label *label342
-    * set :locateDomeAndCore.0:type @poly
    28 label *label345
    29 set :locateCore.0:type @poly
    30 setaddr :locateCore.0*retaddr *label346
 
    35 label *label347
    36 label *label348
    37 label *label349
-    * set :locateDomeAndCore.0:type @mega
    38 label *label352
    39 set :locateCore.0:type @mega
    40 setaddr :locateCore.0*retaddr *label353
 
    45 label *label354
    46 label *label355
    47 label *label356
-    * set :locateDomeAndCore.0:type @mono
    48 label *label359
    49 set :locateCore.0:type @mono
    50 setaddr :locateCore.0*retaddr *label360

Modifications by Replicate loop condition at line 54:5 (+1 instructions):
 
    67 label *label18
    68 sensor *tmp7 switch1 @enabled
    69 jump *label20 notEqual *tmp7 false
+   70 label *label367
    71 print "[coral]Activate switch to begin supplying overdrive dome..."
    72 print "\n"
    73 printflush message1
    74 label *label19
-    * jump *label18 always
+   75 sensor *tmp7 switch1 @enabled
+   76 jump *label367 equal *tmp7 false
    77 label *label20
    78 label *label22
    79 printflush null

Modifications by Replicate loop condition at line 119:5 (+1 instructions):
 
   524 label *label148
   525 sensor *tmp204 switch1 @enabled
   526 jump *label150 equal *tmp204 false
+  527 label *label368
   528 set :start @time
   529 print " === [gold]Supplying Overdrive Dome[] === "
   530 print "\n"
 
  1244 label *label313
  1245 label *label314
  1246 label *label149
-    * jump *label148 always
+ 1247 sensor *tmp204 switch1 @enabled
+ 1248 jump *label368 notEqual *tmp204 false
  1249 label *label150
  1250 end
  1251 label *label0

Modifications by Iterated phase, Jump Normalization, pass 2, iteration 1 (-2 instructions):
 
   128 label *label33
   129 label *label26
   130 label *label27
-    * jump *label38 equal true false
   131 print UNIT_TYPE
   132 print ":"
   133 print " occupied: "
 
   216 label *label61
   217 label *label54
   218 label *label55
-    * jump *label66 equal true false
   219 print :chooseUnitType.0:type
   220 print ":"
   221 print " occupied: "
 
  1215 label *label323
  1216 label *label316
  1217 label *label317
-    * jump *label328 equal false false
+ 1218 jump *label328 always
  1219 print UNIT_TYPE
  1220 print ":"
  1221 print " occupied: "

Modifications by Iterated phase, Single Step Elimination, pass 2, iteration 1 (-14 instructions):
 
    94 sensor *tmp18 :needsFourUnits.0:unit @speed
    95 op div :needsFourUnits.0:travel_time *tmp17 *tmp18
    96 op greaterThanEq *tmp13 :needsFourUnits.0:travel_time 47
-    * jump *label28 always
    97 label *label28
    98 jump *label30 equal *tmp13 false
    99 set *tmp21 4
-    * jump *label30 always
   100 label *label30
   101 set :areUnitsAvailable.0:needed *tmp21
   102 label *label31
 
   142 label *label38
   143 label *label39
   144 set *tmp10 false
-    * jump *label25 always
   145 label *label25
   146 jump *label42 equal *tmp10 false
   147 set *tmp9 UNIT_TYPE
 
   179 sensor *tmp50 :needsFourUnits.1:unit @speed
   180 op div :needsFourUnits.1:travel_time *tmp49 *tmp50
   181 op greaterThanEq *tmp45 :needsFourUnits.1:travel_time 47
-    * jump *label56 always
   182 label *label56
   183 jump *label58 equal *tmp45 false
   184 set *tmp53 4
-    * jump *label58 always
   185 label *label58
   186 set :areUnitsAvailable.1:needed *tmp53
   187 label *label59
 
   227 label *label66
   228 label *label67
   229 set *tmp42 false
-    * jump *label53 always
   230 label *label53
   231 jump *label70 equal *tmp42 false
   232 printflush null
 
   319 label *label83
   320 ucontrol flag 1
   321 set *tmp85 @unit
-    * jump *label82 always
   322 label *label82
   323 set .UNIT_S1 *tmp85
   324 jump *label97 equal .UNIT_P1 null
 
   357 label *label96
   358 ucontrol flag 1
   359 set *tmp104 @unit
-    * jump *label95 always
   360 label *label95
   361 set .UNIT_P1 *tmp104
   362 sensor *tmp123 *tmp85 @firstItem
 
   385 sensor *tmp139 .UNIT_S1 @speed
   386 op div :needsFourUnits.2:travel_time *tmp138 .SPEED
   387 op greaterThanEq *tmp134 :needsFourUnits.2:travel_time 47
-    * jump *label113 always
   388 label *label113
   389 jump *label114 equal *tmp134 false
   390 jump *label118 equal .UNIT_S2 null
 
   423 label *label117
   424 ucontrol flag 1
   425 set *tmp143 @unit
-    * jump *label116 always
   426 label *label116
   427 set .UNIT_S2 *tmp143
   428 jump *label131 equal .UNIT_P2 null
 
   461 label *label130
   462 ucontrol flag 1
   463 set *tmp162 @unit
-    * jump *label129 always
   464 label *label129
   465 set .UNIT_P2 *tmp162
   466 sensor *tmp181 .UNIT_S1 @firstItem
 
  1170 sensor *tmp495 :needsFourUnits.3:unit @speed
  1171 op div :needsFourUnits.3:travel_time *tmp138 *tmp495
  1172 op greaterThanEq *tmp490 :needsFourUnits.3:travel_time 47
-    * jump *label318 always
  1173 label *label318
  1174 jump *label320 equal *tmp490 false
  1175 set *tmp498 4
-    * jump *label320 always
  1176 label *label320
  1177 set :areUnitsAvailable.2:needed *tmp498
  1178 label *label321
 
  1219 label *label328
  1220 label *label329
  1221 set *tmp487 false
-    * jump *label315 always
  1222 label *label315
  1223 jump *label332 equal *tmp487 false
  1224 end

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1 (-1 instructions):
 
   469 op notEqual *tmp184 *tmp183 @phase-fabric
   470 op land *tmp185 *tmp182 *tmp184
   471 jump *label142 equal *tmp185 false
-    * set :swap.1:t .UNIT_S1
+  472 set .UNIT_P2 .UNIT_S1
   473 label *label144
   474 set .UNIT_S1 *tmp162
-    * set .UNIT_P2 :swap.1:t
   475 label *label142
   476 label *label143
   477 sensor *tmp187 *tmp143 @firstItem

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 2 (-2 instructions):
 
  1160 jump *label313 equal *tmp485 false
  1161 set :areUnitsAvailable.2:free 0
  1162 set :areUnitsAvailable.2:occupied 0
-    * set :areUnitsAvailable.2:needed 0
  1163 ubind UNIT_TYPE
  1164 set :areUnitsAvailable.2:firstUnit @unit
  1165 jump *label316 equal :areUnitsAvailable.2:firstUnit null
 
  1172 jump *label320 equal *tmp490 false
  1173 set *tmp498 4
  1174 label *label320
-    * set :areUnitsAvailable.2:needed *tmp498
  1175 label *label321
  1176 sensor *tmp499 @unit @controlled
  1177 op equal *tmp500 *tmp499 0

Modifications by Unroll iteration loop at line 201:9 (+151 instructions):
 
   148 jump *label21 always
   149 label *label42
   150 label *label43
-    * setaddr *tmp39 *label47
-    * set :chooseUnitType.0:type @flare
-    * jump *label44 always
-    * multilabel *label47 marker1
-    * setaddr *tmp39 *label48
-    * set :chooseUnitType.0:type @poly
-    * jump *label44 always
-    * multilabel *label48 marker1
-    * setaddr *tmp39 *label49
-    * set :chooseUnitType.0:type @mega
-    * jump *label44 always
-    * multilabel *label49 marker1
-    * setaddr *tmp39 *label50
-    * set :chooseUnitType.0:type @mono
-    * label *label44
-    * jump *label51 equal :chooseUnitType.0:type UNIT_TYPE
-    * set :areUnitsAvailable.1:free 0
-    * set :areUnitsAvailable.1:occupied 0
-    * set :areUnitsAvailable.1:needed 0
-    * ubind :chooseUnitType.0:type
-    * set :areUnitsAvailable.1:firstUnit @unit
-    * jump *label54 equal :areUnitsAvailable.1:firstUnit null
-    * set *tmp53 2
-    * set :needsFourUnits.1:unit @unit
-    * op sub *tmp46 .DOME_X .CORE_X
-    * op sub *tmp47 .DOME_Y .CORE_Y
-    * op len *tmp48 *tmp46 *tmp47
-    * op mul *tmp49 2 *tmp48
-    * sensor *tmp50 :needsFourUnits.1:unit @speed
-    * op div :needsFourUnits.1:travel_time *tmp49 *tmp50
-    * op greaterThanEq *tmp45 :needsFourUnits.1:travel_time 47
-    * label *label56
-    * jump *label58 equal *tmp45 false
-    * set *tmp53 4
-    * label *label58
-    * set :areUnitsAvailable.1:needed *tmp53
-    * label *label59
-    * sensor *tmp54 @unit @controlled
-    * op equal *tmp55 *tmp54 0
-    * sensor *tmp56 @unit @controller
-    * op equal *tmp57 *tmp56 @this
-    * op or *tmp58 *tmp55 *tmp57
-    * jump *label62 equal *tmp58 false
-    * op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
-    * jump *label64 lessThan :areUnitsAvailable.1:free *tmp53
-    * set *tmp42 true
-    * jump *label53 always
-    * label *label64
-    * label *label65
-    * jump *label63 always
-    * label *label62
-    * op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
-    * label *label63
-    * ubind :chooseUnitType.0:type
-    * label *label60
-    * op notEqual *tmp63 @unit :areUnitsAvailable.1:firstUnit
-    * sensor *tmp64 :areUnitsAvailable.1:firstUnit @dead
-    * op equal *tmp65 *tmp64 0
-    * op land *tmp66 *tmp63 *tmp65
-    * jump *label59 notEqual *tmp66 false
-    * label *label61
-    * label *label54
-    * label *label55
-    * print :chooseUnitType.0:type
-    * print ":"
-    * print " occupied: "
-    * print :areUnitsAvailable.1:occupied
-    * print ","
-    * print " free: "
-    * print :areUnitsAvailable.1:free
-    * jump *label68 lessThanEq :areUnitsAvailable.1:needed 0
-    * print ", needed: "
-    * print :areUnitsAvailable.1:needed
-    * label *label68
-    * label *label69
-    * print "\n"
-    * label *label66
-    * label *label67
-    * set *tmp42 false
-    * label *label53
-    * jump *label70 equal *tmp42 false
-    * printflush null
-    * set *tmp9 :chooseUnitType.0:type
-    * jump *label21 always
-    * label *label70
-    * label *label71
-    * label *label51
-    * label *label52
-    * label *label45
-    * multijump *tmp39 0 0 marker1
-    * multilabel *label50 marker1
-    * label *label46
+  151 set :chooseUnitType.0:type @flare
+  152 label *label369
+  153 jump *label388 equal :chooseUnitType.0:type UNIT_TYPE
+  154 set :areUnitsAvailable.1:free 0
+  155 set :areUnitsAvailable.1:occupied 0
+  156 set :areUnitsAvailable.1:needed 0
+  157 ubind :chooseUnitType.0:type
+  158 set :areUnitsAvailable.1:firstUnit @unit
+  159 jump *label379 equal :areUnitsAvailable.1:firstUnit null
+  160 set *tmp53 2
+  161 set :needsFourUnits.1:unit @unit
+  162 op sub *tmp46 .DOME_X .CORE_X
+  163 op sub *tmp47 .DOME_Y .CORE_Y
+  164 op len *tmp48 *tmp46 *tmp47
+  165 op mul *tmp49 2 *tmp48
+  166 sensor *tmp50 :needsFourUnits.1:unit @speed
+  167 op div :needsFourUnits.1:travel_time *tmp49 *tmp50
+  168 op greaterThanEq *tmp45 :needsFourUnits.1:travel_time 47
+  169 label *label370
+  170 jump *label371 equal *tmp45 false
+  171 set *tmp53 4
+  172 label *label371
+  173 set :areUnitsAvailable.1:needed *tmp53
+  174 label *label372
+  175 sensor *tmp54 @unit @controlled
+  176 op equal *tmp55 *tmp54 0
+  177 sensor *tmp56 @unit @controller
+  178 op equal *tmp57 *tmp56 @this
+  179 op or *tmp58 *tmp55 *tmp57
+  180 jump *label375 equal *tmp58 false
+  181 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
+  182 jump *label373 lessThan :areUnitsAvailable.1:free *tmp53
+  183 set *tmp42 true
+  184 jump *label385 always
+  185 label *label373
+  186 label *label374
+  187 jump *label376 always
+  188 label *label375
+  189 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
+  190 label *label376
+  191 ubind :chooseUnitType.0:type
+  192 label *label377
+  193 op notEqual *tmp63 @unit :areUnitsAvailable.1:firstUnit
+  194 sensor *tmp64 :areUnitsAvailable.1:firstUnit @dead
+  195 op equal *tmp65 *tmp64 0
+  196 op land *tmp66 *tmp63 *tmp65
+  197 jump *label372 notEqual *tmp66 false
+  198 label *label378
+  199 label *label379
+  200 label *label380
+  201 print :chooseUnitType.0:type
+  202 print ":"
+  203 print " occupied: "
+  204 print :areUnitsAvailable.1:occupied
+  205 print ","
+  206 print " free: "
+  207 print :areUnitsAvailable.1:free
+  208 jump *label381 lessThanEq :areUnitsAvailable.1:needed 0
+  209 print ", needed: "
+  210 print :areUnitsAvailable.1:needed
+  211 label *label381
+  212 label *label382
+  213 print "\n"
+  214 label *label383
+  215 label *label384
+  216 set *tmp42 false
+  217 label *label385
+  218 jump *label386 equal *tmp42 false
+  219 printflush null
+  220 set *tmp9 :chooseUnitType.0:type
+  221 jump *label21 always
+  222 label *label386
+  223 label *label387
+  224 label *label388
+  225 label *label389
+  226 label *label390
+  227 set :chooseUnitType.0:type @poly
+  228 label *label393
+  229 jump *label412 equal :chooseUnitType.0:type UNIT_TYPE
+  230 set :areUnitsAvailable.1:free 0
+  231 set :areUnitsAvailable.1:occupied 0
+  232 set :areUnitsAvailable.1:needed 0
+  233 ubind :chooseUnitType.0:type
+  234 set :areUnitsAvailable.1:firstUnit @unit
+  235 jump *label403 equal :areUnitsAvailable.1:firstUnit null
+  236 set *tmp53 2
+  237 set :needsFourUnits.1:unit @unit
+  238 op sub *tmp46 .DOME_X .CORE_X
+  239 op sub *tmp47 .DOME_Y .CORE_Y
+  240 op len *tmp48 *tmp46 *tmp47
+  241 op mul *tmp49 2 *tmp48
+  242 sensor *tmp50 :needsFourUnits.1:unit @speed
+  243 op div :needsFourUnits.1:travel_time *tmp49 *tmp50
+  244 op greaterThanEq *tmp45 :needsFourUnits.1:travel_time 47
+  245 label *label394
+  246 jump *label395 equal *tmp45 false
+  247 set *tmp53 4
+  248 label *label395
+  249 set :areUnitsAvailable.1:needed *tmp53
+  250 label *label396
+  251 sensor *tmp54 @unit @controlled
+  252 op equal *tmp55 *tmp54 0
+  253 sensor *tmp56 @unit @controller
+  254 op equal *tmp57 *tmp56 @this
+  255 op or *tmp58 *tmp55 *tmp57
+  256 jump *label399 equal *tmp58 false
+  257 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
+  258 jump *label397 lessThan :areUnitsAvailable.1:free *tmp53
+  259 set *tmp42 true
+  260 jump *label409 always
+  261 label *label397
+  262 label *label398
+  263 jump *label400 always
+  264 label *label399
+  265 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
+  266 label *label400
+  267 ubind :chooseUnitType.0:type
+  268 label *label401
+  269 op notEqual *tmp63 @unit :areUnitsAvailable.1:firstUnit
+  270 sensor *tmp64 :areUnitsAvailable.1:firstUnit @dead
+  271 op equal *tmp65 *tmp64 0
+  272 op land *tmp66 *tmp63 *tmp65
+  273 jump *label396 notEqual *tmp66 false
+  274 label *label402
+  275 label *label403
+  276 label *label404
+  277 print :chooseUnitType.0:type
+  278 print ":"
+  279 print " occupied: "
+  280 print :areUnitsAvailable.1:occupied
+  281 print ","
+  282 print " free: "
+  283 print :areUnitsAvailable.1:free
+  284 jump *label405 lessThanEq :areUnitsAvailable.1:needed 0
+  285 print ", needed: "
+  286 print :areUnitsAvailable.1:needed
+  287 label *label405
+  288 label *label406
+  289 print "\n"
+  290 label *label407
+  291 label *label408
+  292 set *tmp42 false
+  293 label *label409
+  294 jump *label410 equal *tmp42 false
+  295 printflush null
+  296 set *tmp9 :chooseUnitType.0:type
+  297 jump *label21 always
+  298 label *label410
+  299 label *label411
+  300 label *label412
+  301 label *label413
+  302 label *label414
+  303 set :chooseUnitType.0:type @mega
+  304 label *label417
+  305 jump *label436 equal :chooseUnitType.0:type UNIT_TYPE
+  306 set :areUnitsAvailable.1:free 0
+  307 set :areUnitsAvailable.1:occupied 0
+  308 set :areUnitsAvailable.1:needed 0
+  309 ubind :chooseUnitType.0:type
+  310 set :areUnitsAvailable.1:firstUnit @unit
+  311 jump *label427 equal :areUnitsAvailable.1:firstUnit null
+  312 set *tmp53 2
+  313 set :needsFourUnits.1:unit @unit
+  314 op sub *tmp46 .DOME_X .CORE_X
+  315 op sub *tmp47 .DOME_Y .CORE_Y
+  316 op len *tmp48 *tmp46 *tmp47
+  317 op mul *tmp49 2 *tmp48
+  318 sensor *tmp50 :needsFourUnits.1:unit @speed
+  319 op div :needsFourUnits.1:travel_time *tmp49 *tmp50
+  320 op greaterThanEq *tmp45 :needsFourUnits.1:travel_time 47
+  321 label *label418
+  322 jump *label419 equal *tmp45 false
+  323 set *tmp53 4
+  324 label *label419
+  325 set :areUnitsAvailable.1:needed *tmp53
+  326 label *label420
+  327 sensor *tmp54 @unit @controlled
+  328 op equal *tmp55 *tmp54 0
+  329 sensor *tmp56 @unit @controller
+  330 op equal *tmp57 *tmp56 @this
+  331 op or *tmp58 *tmp55 *tmp57
+  332 jump *label423 equal *tmp58 false
+  333 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
+  334 jump *label421 lessThan :areUnitsAvailable.1:free *tmp53
+  335 set *tmp42 true
+  336 jump *label433 always
+  337 label *label421
+  338 label *label422
+  339 jump *label424 always
+  340 label *label423
+  341 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
+  342 label *label424
+  343 ubind :chooseUnitType.0:type
+  344 label *label425
+  345 op notEqual *tmp63 @unit :areUnitsAvailable.1:firstUnit
+  346 sensor *tmp64 :areUnitsAvailable.1:firstUnit @dead
+  347 op equal *tmp65 *tmp64 0
+  348 op land *tmp66 *tmp63 *tmp65
+  349 jump *label420 notEqual *tmp66 false
+  350 label *label426
+  351 label *label427
+  352 label *label428
+  353 print :chooseUnitType.0:type
+  354 print ":"
+  355 print " occupied: "
+  356 print :areUnitsAvailable.1:occupied
+  357 print ","
+  358 print " free: "
+  359 print :areUnitsAvailable.1:free
+  360 jump *label429 lessThanEq :areUnitsAvailable.1:needed 0
+  361 print ", needed: "
+  362 print :areUnitsAvailable.1:needed
+  363 label *label429
+  364 label *label430
+  365 print "\n"
+  366 label *label431
+  367 label *label432
+  368 set *tmp42 false
+  369 label *label433
+  370 jump *label434 equal *tmp42 false
+  371 printflush null
+  372 set *tmp9 :chooseUnitType.0:type
+  373 jump *label21 always
+  374 label *label434
+  375 label *label435
+  376 label *label436
+  377 label *label437
+  378 label *label438
+  379 set :chooseUnitType.0:type @mono
+  380 label *label441
+  381 jump *label460 equal :chooseUnitType.0:type UNIT_TYPE
+  382 set :areUnitsAvailable.1:free 0
+  383 set :areUnitsAvailable.1:occupied 0
+  384 set :areUnitsAvailable.1:needed 0
+  385 ubind :chooseUnitType.0:type
+  386 set :areUnitsAvailable.1:firstUnit @unit
+  387 jump *label451 equal :areUnitsAvailable.1:firstUnit null
+  388 set *tmp53 2
+  389 set :needsFourUnits.1:unit @unit
+  390 op sub *tmp46 .DOME_X .CORE_X
+  391 op sub *tmp47 .DOME_Y .CORE_Y
+  392 op len *tmp48 *tmp46 *tmp47
+  393 op mul *tmp49 2 *tmp48
+  394 sensor *tmp50 :needsFourUnits.1:unit @speed
+  395 op div :needsFourUnits.1:travel_time *tmp49 *tmp50
+  396 op greaterThanEq *tmp45 :needsFourUnits.1:travel_time 47
+  397 label *label442
+  398 jump *label443 equal *tmp45 false
+  399 set *tmp53 4
+  400 label *label443
+  401 set :areUnitsAvailable.1:needed *tmp53
+  402 label *label444
+  403 sensor *tmp54 @unit @controlled
+  404 op equal *tmp55 *tmp54 0
+  405 sensor *tmp56 @unit @controller
+  406 op equal *tmp57 *tmp56 @this
+  407 op or *tmp58 *tmp55 *tmp57
+  408 jump *label447 equal *tmp58 false
+  409 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
+  410 jump *label445 lessThan :areUnitsAvailable.1:free *tmp53
+  411 set *tmp42 true
+  412 jump *label457 always
+  413 label *label445
+  414 label *label446
+  415 jump *label448 always
+  416 label *label447
+  417 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
+  418 label *label448
+  419 ubind :chooseUnitType.0:type
+  420 label *label449
+  421 op notEqual *tmp63 @unit :areUnitsAvailable.1:firstUnit
+  422 sensor *tmp64 :areUnitsAvailable.1:firstUnit @dead
+  423 op equal *tmp65 *tmp64 0
+  424 op land *tmp66 *tmp63 *tmp65
+  425 jump *label444 notEqual *tmp66 false
+  426 label *label450
+  427 label *label451
+  428 label *label452
+  429 print :chooseUnitType.0:type
+  430 print ":"
+  431 print " occupied: "
+  432 print :areUnitsAvailable.1:occupied
+  433 print ","
+  434 print " free: "
+  435 print :areUnitsAvailable.1:free
+  436 jump *label453 lessThanEq :areUnitsAvailable.1:needed 0
+  437 print ", needed: "
+  438 print :areUnitsAvailable.1:needed
+  439 label *label453
+  440 label *label454
+  441 print "\n"
+  442 label *label455
+  443 label *label456
+  444 set *tmp42 false
+  445 label *label457
+  446 jump *label458 equal *tmp42 false
+  447 printflush null
+  448 set *tmp9 :chooseUnitType.0:type
+  449 jump *label21 always
+  450 label *label458
+  451 label *label459
+  452 label *label460
+  453 label *label461
+  454 label *label462
+  455 label *label46
   456 printflush message1
   457 label *label23
   458 jump *label22 always

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1:
 
   150 label *label43
   151 set :chooseUnitType.0:type @flare
   152 label *label369
-    * jump *label388 equal :chooseUnitType.0:type UNIT_TYPE
+  153 jump *label388 equal @flare UNIT_TYPE
   154 set :areUnitsAvailable.1:free 0
   155 set :areUnitsAvailable.1:occupied 0
   156 set :areUnitsAvailable.1:needed 0
-    * ubind :chooseUnitType.0:type
+  157 ubind @flare
   158 set :areUnitsAvailable.1:firstUnit @unit
   159 jump *label379 equal :areUnitsAvailable.1:firstUnit null
   160 set *tmp53 2
 
   188 label *label375
   189 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   190 label *label376
-    * ubind :chooseUnitType.0:type
+  191 ubind @flare
   192 label *label377
   193 op notEqual *tmp63 @unit :areUnitsAvailable.1:firstUnit
   194 sensor *tmp64 :areUnitsAvailable.1:firstUnit @dead
 
   198 label *label378
   199 label *label379
   200 label *label380
-    * print :chooseUnitType.0:type
+  201 print @flare
   202 print ":"
   203 print " occupied: "
   204 print :areUnitsAvailable.1:occupied
 
   217 label *label385
   218 jump *label386 equal *tmp42 false
   219 printflush null
-    * set *tmp9 :chooseUnitType.0:type
+  220 set *tmp9 @flare
   221 jump *label21 always
   222 label *label386
   223 label *label387
 
   226 label *label390
   227 set :chooseUnitType.0:type @poly
   228 label *label393
-    * jump *label412 equal :chooseUnitType.0:type UNIT_TYPE
+  229 jump *label412 equal @poly UNIT_TYPE
   230 set :areUnitsAvailable.1:free 0
   231 set :areUnitsAvailable.1:occupied 0
   232 set :areUnitsAvailable.1:needed 0
-    * ubind :chooseUnitType.0:type
+  233 ubind @poly
   234 set :areUnitsAvailable.1:firstUnit @unit
   235 jump *label403 equal :areUnitsAvailable.1:firstUnit null
   236 set *tmp53 2
 
   264 label *label399
   265 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   266 label *label400
-    * ubind :chooseUnitType.0:type
+  267 ubind @poly
   268 label *label401
   269 op notEqual *tmp63 @unit :areUnitsAvailable.1:firstUnit
   270 sensor *tmp64 :areUnitsAvailable.1:firstUnit @dead
 
   274 label *label402
   275 label *label403
   276 label *label404
-    * print :chooseUnitType.0:type
+  277 print @poly
   278 print ":"
   279 print " occupied: "
   280 print :areUnitsAvailable.1:occupied
 
   293 label *label409
   294 jump *label410 equal *tmp42 false
   295 printflush null
-    * set *tmp9 :chooseUnitType.0:type
+  296 set *tmp9 @poly
   297 jump *label21 always
   298 label *label410
   299 label *label411
 
   302 label *label414
   303 set :chooseUnitType.0:type @mega
   304 label *label417
-    * jump *label436 equal :chooseUnitType.0:type UNIT_TYPE
+  305 jump *label436 equal @mega UNIT_TYPE
   306 set :areUnitsAvailable.1:free 0
   307 set :areUnitsAvailable.1:occupied 0
   308 set :areUnitsAvailable.1:needed 0
-    * ubind :chooseUnitType.0:type
+  309 ubind @mega
   310 set :areUnitsAvailable.1:firstUnit @unit
   311 jump *label427 equal :areUnitsAvailable.1:firstUnit null
   312 set *tmp53 2
 
   340 label *label423
   341 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   342 label *label424
-    * ubind :chooseUnitType.0:type
+  343 ubind @mega
   344 label *label425
   345 op notEqual *tmp63 @unit :areUnitsAvailable.1:firstUnit
   346 sensor *tmp64 :areUnitsAvailable.1:firstUnit @dead
 
   350 label *label426
   351 label *label427
   352 label *label428
-    * print :chooseUnitType.0:type
+  353 print @mega
   354 print ":"
   355 print " occupied: "
   356 print :areUnitsAvailable.1:occupied
 
   369 label *label433
   370 jump *label434 equal *tmp42 false
   371 printflush null
-    * set *tmp9 :chooseUnitType.0:type
+  372 set *tmp9 @mega
   373 jump *label21 always
   374 label *label434
   375 label *label435
 
   378 label *label438
   379 set :chooseUnitType.0:type @mono
   380 label *label441
-    * jump *label460 equal :chooseUnitType.0:type UNIT_TYPE
+  381 jump *label460 equal @mono UNIT_TYPE
   382 set :areUnitsAvailable.1:free 0
   383 set :areUnitsAvailable.1:occupied 0
   384 set :areUnitsAvailable.1:needed 0
-    * ubind :chooseUnitType.0:type
+  385 ubind @mono
   386 set :areUnitsAvailable.1:firstUnit @unit
   387 jump *label451 equal :areUnitsAvailable.1:firstUnit null
   388 set *tmp53 2
 
   416 label *label447
   417 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   418 label *label448
-    * ubind :chooseUnitType.0:type
+  419 ubind @mono
   420 label *label449
   421 op notEqual *tmp63 @unit :areUnitsAvailable.1:firstUnit
   422 sensor *tmp64 :areUnitsAvailable.1:firstUnit @dead
 
   426 label *label450
   427 label *label451
   428 label *label452
-    * print :chooseUnitType.0:type
+  429 print @mono
   430 print ":"
   431 print " occupied: "
   432 print :areUnitsAvailable.1:occupied
 
   445 label *label457
   446 jump *label458 equal *tmp42 false
   447 printflush null
-    * set *tmp9 :chooseUnitType.0:type
+  448 set *tmp9 @mono
   449 jump *label21 always
   450 label *label458
   451 label *label459

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 2 (-4 instructions):
 
   148 jump *label21 always
   149 label *label42
   150 label *label43
-    * set :chooseUnitType.0:type @flare
   151 label *label369
   152 jump *label388 equal @flare UNIT_TYPE
   153 set :areUnitsAvailable.1:free 0
 
   223 label *label388
   224 label *label389
   225 label *label390
-    * set :chooseUnitType.0:type @poly
   226 label *label393
   227 jump *label412 equal @poly UNIT_TYPE
   228 set :areUnitsAvailable.1:free 0
 
   298 label *label412
   299 label *label413
   300 label *label414
-    * set :chooseUnitType.0:type @mega
   301 label *label417
   302 jump *label436 equal @mega UNIT_TYPE
   303 set :areUnitsAvailable.1:free 0
 
   373 label *label436
   374 label *label437
   375 label *label438
-    * set :chooseUnitType.0:type @mono
   376 label *label441
   377 jump *label460 equal @mono UNIT_TYPE
   378 set :areUnitsAvailable.1:free 0

Modifications by Iterated phase, Jump Optimization, pass 3, iteration 1 (-2 instructions):
 
    93 op mul *tmp17 2 *tmp16
    94 sensor *tmp18 :needsFourUnits.0:unit @speed
    95 op div :needsFourUnits.0:travel_time *tmp17 *tmp18
-    * op greaterThanEq *tmp13 :needsFourUnits.0:travel_time 47
    96 label *label28
-    * jump *label30 equal *tmp13 false
+   97 jump *label30 lessThan :needsFourUnits.0:travel_time 47
    98 set *tmp21 4
    99 label *label30
   100 set :areUnitsAvailable.0:needed *tmp21
 
  1375 set :needsFourUnits.3:unit @unit
  1376 sensor *tmp495 :needsFourUnits.3:unit @speed
  1377 op div :needsFourUnits.3:travel_time *tmp138 *tmp495
-    * op greaterThanEq *tmp490 :needsFourUnits.3:travel_time 47
  1378 label *label318
-    * jump *label320 equal *tmp490 false
+ 1379 jump *label320 lessThan :needsFourUnits.3:travel_time 47
  1380 set *tmp498 4
  1381 label *label320
  1382 label *label321

Modifications by Final phase, Jump Straightening, iteration 1 (-21 instructions):
 
    20 setaddr :locateCore.0*retaddr *label339
    21 call *label0 :locateCore.0*retval
    22 label *label339
-    * jump *label340 equal :locateCore.0*retval false
-    * jump *label1 always
+   23 jump *label1 notEqual :locateCore.0*retval false
    24 label *label340
    25 label *label341
    26 label *label342
 
    29 setaddr :locateCore.0*retaddr *label346
    30 call *label0 :locateCore.0*retval
    31 label *label346
-    * jump *label347 equal :locateCore.0*retval false
-    * jump *label1 always
+   32 jump *label1 notEqual :locateCore.0*retval false
    33 label *label347
    34 label *label348
    35 label *label349
 
    38 setaddr :locateCore.0*retaddr *label353
    39 call *label0 :locateCore.0*retval
    40 label *label353
-    * jump *label354 equal :locateCore.0*retval false
-    * jump *label1 always
+   41 jump *label1 notEqual :locateCore.0*retval false
    42 label *label354
    43 label *label355
    44 label *label356
 
    47 setaddr :locateCore.0*retaddr *label360
    48 call *label0 :locateCore.0*retval
    49 label *label360
-    * jump *label361 equal :locateCore.0*retval false
-    * jump *label1 always
+   50 jump *label1 notEqual :locateCore.0*retval false
    51 label *label361
    52 label *label362
    53 label *label363
 
   472 set .UNIT_P2 .UNIT_S1
   473 set .UNIT_S1 .UNIT_P1
   474 set .UNIT_P1 @unit
-    * jump *label80 equal .UNIT_S2 null
-    * jump *label77 always
+  475 jump *label77 notEqual .UNIT_S2 null
   476 label *label80
   477 label *label81
   478 label *label78
 
   493 sensor *tmp91 @unit @controller
   494 op equal *tmp92 *tmp91 @this
   495 op land *tmp93 *tmp90 *tmp92
-    * jump *label86 equal *tmp93 false
-    * jump *label83 always
+  496 jump *label83 notEqual *tmp93 false
   497 label *label86
   498 label *label87
   499 label *label84
 
   503 jump *label88 equal :rebindUnit.0:firstUnit null
   504 label *label90
   505 sensor *tmp97 @unit @controlled
-    * jump *label93 notEqual *tmp97 0
-    * jump *label83 always
+  506 jump *label83 equal *tmp97 0
   507 label *label93
   508 label *label94
   509 ubind *tmp9
 
   529 sensor *tmp110 @unit @controller
   530 op equal *tmp111 *tmp110 @this
   531 op land *tmp112 *tmp109 *tmp111
-    * jump *label99 equal *tmp112 false
-    * jump *label96 always
+  532 jump *label96 notEqual *tmp112 false
   533 label *label99
   534 label *label100
   535 label *label97
 
   539 jump *label101 equal :rebindUnit.1:firstUnit null
   540 label *label103
   541 sensor *tmp116 @unit @controlled
-    * jump *label106 notEqual *tmp116 0
-    * jump *label96 always
+  542 jump *label96 equal *tmp116 0
   543 label *label106
   544 label *label107
   545 ubind *tmp9
 
   593 sensor *tmp149 @unit @controller
   594 op equal *tmp150 *tmp149 @this
   595 op land *tmp151 *tmp148 *tmp150
-    * jump *label120 equal *tmp151 false
-    * jump *label117 always
+  596 jump *label117 notEqual *tmp151 false
   597 label *label120
   598 label *label121
   599 label *label118
 
   603 jump *label122 equal :rebindUnit.2:firstUnit null
   604 label *label124
   605 sensor *tmp155 @unit @controlled
-    * jump *label127 notEqual *tmp155 0
-    * jump *label117 always
+  606 jump *label117 equal *tmp155 0
   607 label *label127
   608 label *label128
   609 ubind *tmp9
 
   629 sensor *tmp168 @unit @controller
   630 op equal *tmp169 *tmp168 @this
   631 op land *tmp170 *tmp167 *tmp169
-    * jump *label133 equal *tmp170 false
-    * jump *label130 always
+  632 jump *label130 notEqual *tmp170 false
   633 label *label133
   634 label *label134
   635 label *label131
 
   639 jump *label135 equal :rebindUnit.3:firstUnit null
   640 label *label137
   641 sensor *tmp174 @unit @controlled
-    * jump *label140 notEqual *tmp174 0
-    * jump *label130 always
+  642 jump *label130 equal *tmp174 0
   643 label *label140
   644 label *label141
   645 ubind *tmp9
 
   739 sensor *tmp213 @unit @controller
   740 op equal *tmp214 *tmp213 @this
   741 op land *tmp215 *tmp212 *tmp214
-    * jump *label158 equal *tmp215 false
-    * jump *label155 always
+  742 jump *label155 notEqual *tmp215 false
   743 label *label158
   744 label *label159
   745 label *label156
 
   749 jump *label160 equal :rebindUnit.4:firstUnit null
   750 label *label162
   751 sensor *tmp219 @unit @controlled
-    * jump *label165 notEqual *tmp219 0
-    * jump *label155 always
+  752 jump *label155 equal *tmp219 0
   753 label *label165
   754 label *label166
   755 ubind *tmp9
 
   881 sensor *tmp279 @unit @controller
   882 op equal *tmp280 *tmp279 @this
   883 op land *tmp281 *tmp278 *tmp280
-    * jump *label197 equal *tmp281 false
-    * jump *label194 always
+  884 jump *label194 notEqual *tmp281 false
   885 label *label197
   886 label *label198
   887 label *label195
 
   891 jump *label199 equal :rebindUnit.5:firstUnit null
   892 label *label201
   893 sensor *tmp285 @unit @controlled
-    * jump *label204 notEqual *tmp285 0
-    * jump *label194 always
+  894 jump *label194 equal *tmp285 0
   895 label *label204
   896 label *label205
   897 ubind *tmp9
 
  1048 sensor *tmp351 @unit @controller
  1049 op equal *tmp352 *tmp351 @this
  1050 op land *tmp353 *tmp350 *tmp352
-    * jump *label239 equal *tmp353 false
-    * jump *label236 always
+ 1051 jump *label236 notEqual *tmp353 false
  1052 label *label239
  1053 label *label240
  1054 label *label237
 
  1058 jump *label241 equal :rebindUnit.6:firstUnit null
  1059 label *label243
  1060 sensor *tmp357 @unit @controlled
-    * jump *label246 notEqual *tmp357 0
-    * jump *label236 always
+ 1061 jump *label236 equal *tmp357 0
  1062 label *label246
  1063 label *label247
  1064 ubind *tmp9
 
  1190 sensor *tmp417 @unit @controller
  1191 op equal *tmp418 *tmp417 @this
  1192 op land *tmp419 *tmp416 *tmp418
-    * jump *label278 equal *tmp419 false
-    * jump *label275 always
+ 1193 jump *label275 notEqual *tmp419 false
  1194 label *label278
  1195 label *label279
  1196 label *label276
 
  1200 jump *label280 equal :rebindUnit.7:firstUnit null
  1201 label *label282
  1202 sensor *tmp423 @unit @controlled
-    * jump *label285 notEqual *tmp423 0
-    * jump *label275 always
+ 1203 jump *label275 equal *tmp423 0
  1204 label *label285
  1205 label *label286
  1206 ubind *tmp9

Modifications by Final phase, Jump Threading, iteration 1:
+    0 label __start__
     1 remark "This is the preferred unit type to use for bringing in supplies."
     2 remark "If no units of this type exist, we'll try using other types."
     3 set UNIT_TYPE @flare
 
   103 op or *tmp26 *tmp23 *tmp25
   104 jump *label34 equal *tmp26 false
   105 op add :areUnitsAvailable.0:free :areUnitsAvailable.0:free 1
-    * jump *label36 lessThan :areUnitsAvailable.0:free *tmp21
+  106 jump *label35 lessThan :areUnitsAvailable.0:free *tmp21
   107 set *tmp10 true
   108 jump *label25 always
   109 label *label36
 
   174 op or *tmp58 *tmp55 *tmp57
   175 jump *label375 equal *tmp58 false
   176 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
-    * jump *label373 lessThan :areUnitsAvailable.1:free *tmp53
+  177 jump *label376 lessThan :areUnitsAvailable.1:free *tmp53
   178 set *tmp42 true
   179 jump *label385 always
   180 label *label373
 
   249 op or *tmp58 *tmp55 *tmp57
   250 jump *label399 equal *tmp58 false
   251 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
-    * jump *label397 lessThan :areUnitsAvailable.1:free *tmp53
+  252 jump *label400 lessThan :areUnitsAvailable.1:free *tmp53
   253 set *tmp42 true
   254 jump *label409 always
   255 label *label397
 
   324 op or *tmp58 *tmp55 *tmp57
   325 jump *label423 equal *tmp58 false
   326 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
-    * jump *label421 lessThan :areUnitsAvailable.1:free *tmp53
+  327 jump *label424 lessThan :areUnitsAvailable.1:free *tmp53
   328 set *tmp42 true
   329 jump *label433 always
   330 label *label421
 
   399 op or *tmp58 *tmp55 *tmp57
   400 jump *label447 equal *tmp58 false
   401 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
-    * jump *label445 lessThan :areUnitsAvailable.1:free *tmp53
+  402 jump *label448 lessThan :areUnitsAvailable.1:free *tmp53
   403 set *tmp42 true
   404 jump *label457 always
   405 label *label445
 
   501 label *label85
   502 ubind *tmp9
   503 set :rebindUnit.0:firstUnit @unit
-    * jump *label88 equal :rebindUnit.0:firstUnit null
+  504 jump __start__ equal :rebindUnit.0:firstUnit null
   505 label *label90
   506 sensor *tmp97 @unit @controlled
   507 jump *label83 equal *tmp97 0
 
   537 label *label98
   538 ubind *tmp9
   539 set :rebindUnit.1:firstUnit @unit
-    * jump *label101 equal :rebindUnit.1:firstUnit null
+  540 jump __start__ equal :rebindUnit.1:firstUnit null
   541 label *label103
   542 sensor *tmp116 @unit @controlled
   543 jump *label96 equal *tmp116 0
 
   601 label *label119
   602 ubind *tmp9
   603 set :rebindUnit.2:firstUnit @unit
-    * jump *label122 equal :rebindUnit.2:firstUnit null
+  604 jump __start__ equal :rebindUnit.2:firstUnit null
   605 label *label124
   606 sensor *tmp155 @unit @controlled
   607 jump *label117 equal *tmp155 0
 
   637 label *label132
   638 ubind *tmp9
   639 set :rebindUnit.3:firstUnit @unit
-    * jump *label135 equal :rebindUnit.3:firstUnit null
+  640 jump __start__ equal :rebindUnit.3:firstUnit null
   641 label *label137
   642 sensor *tmp174 @unit @controlled
   643 jump *label130 equal *tmp174 0
 
   705 op add :unitCheck @time 5000
   706 label *label148
   707 sensor *tmp204 switch1 @enabled
-    * jump *label150 equal *tmp204 false
+  708 jump __start__ equal *tmp204 false
   709 label *label368
   710 set :start @time
   711 print " === [gold]Supplying Overdrive Dome[] === "
 
   747 label *label157
   748 ubind *tmp9
   749 set :rebindUnit.4:firstUnit @unit
-    * jump *label160 equal :rebindUnit.4:firstUnit null
+  750 jump __start__ equal :rebindUnit.4:firstUnit null
   751 label *label162
   752 sensor *tmp219 @unit @controlled
   753 jump *label155 equal *tmp219 0
 
   800 jump *label179 lessThan *tmp243 .UNIT_CAPACITY
   801 ucontrol approach .DOME_X .DOME_Y 6
   802 set :processUnit.0:state 3
-    * jump *label180 always
+  803 jump *label178 always
   804 label *label179
   805 set .MSG ", loading\n"
   806 label *label180
 
   830 set .MSG ", waiting\n"
   831 label *label186
   832 sensor *tmp258 @unit @totalItems
-    * jump *label187 greaterThan *tmp258 0
+  833 jump *label184 greaterThan *tmp258 0
   834 ucontrol approach .CORE_X .CORE_Y 6
   835 set :processUnit.0:state 2
   836 label *label187
 
   889 label *label196
   890 ubind *tmp9
   891 set :rebindUnit.5:firstUnit @unit
-    * jump *label199 equal :rebindUnit.5:firstUnit null
+  892 jump __start__ equal :rebindUnit.5:firstUnit null
   893 label *label201
   894 sensor *tmp285 @unit @controlled
   895 jump *label194 equal *tmp285 0
 
   942 jump *label218 lessThan *tmp309 .UNIT_CAPACITY
   943 ucontrol approach .DOME_X .DOME_Y 6
   944 set :processUnit.1:state 3
-    * jump *label219 always
+  945 jump *label217 always
   946 label *label218
   947 set .MSG ", loading\n"
   948 label *label219
 
   972 set .MSG ", waiting\n"
   973 label *label225
   974 sensor *tmp324 @unit @totalItems
-    * jump *label226 greaterThan *tmp324 0
+  975 jump *label223 greaterThan *tmp324 0
   976 ucontrol approach .CORE_X .CORE_Y 6
   977 set :processUnit.1:state 2
   978 label *label226
 
  1056 label *label238
  1057 ubind *tmp9
  1058 set :rebindUnit.6:firstUnit @unit
-    * jump *label241 equal :rebindUnit.6:firstUnit null
+ 1059 jump __start__ equal :rebindUnit.6:firstUnit null
  1060 label *label243
  1061 sensor *tmp357 @unit @controlled
  1062 jump *label236 equal *tmp357 0
 
  1109 jump *label260 lessThan *tmp381 .UNIT_CAPACITY
  1110 ucontrol approach .DOME_X .DOME_Y 6
  1111 set :processUnit.2:state 3
-    * jump *label261 always
+ 1112 jump *label259 always
  1113 label *label260
  1114 set .MSG ", loading\n"
  1115 label *label261
 
  1139 set .MSG ", waiting\n"
  1140 label *label267
  1141 sensor *tmp396 @unit @totalItems
-    * jump *label268 greaterThan *tmp396 0
+ 1142 jump *label265 greaterThan *tmp396 0
  1143 ucontrol approach .CORE_X .CORE_Y 6
  1144 set :processUnit.2:state 2
  1145 label *label268
 
  1198 label *label277
  1199 ubind *tmp9
  1200 set :rebindUnit.7:firstUnit @unit
-    * jump *label280 equal :rebindUnit.7:firstUnit null
+ 1201 jump __start__ equal :rebindUnit.7:firstUnit null
  1202 label *label282
  1203 sensor *tmp423 @unit @controlled
  1204 jump *label275 equal *tmp423 0
 
  1251 jump *label299 lessThan *tmp447 .UNIT_CAPACITY
  1252 ucontrol approach .DOME_X .DOME_Y 6
  1253 set :processUnit.3:state 3
-    * jump *label300 always
+ 1254 jump *label298 always
  1255 label *label299
  1256 set .MSG ", loading\n"
  1257 label *label300
 
  1281 set .MSG ", waiting\n"
  1282 label *label306
  1283 sensor *tmp462 @unit @totalItems
-    * jump *label307 greaterThan *tmp462 0
+ 1284 jump *label304 greaterThan *tmp462 0
  1285 ucontrol approach .CORE_X .CORE_Y 6
  1286 set :processUnit.3:state 2
  1287 label *label307
 
  1350 set :areUnitsAvailable.2:occupied 0
  1351 ubind UNIT_TYPE
  1352 set :areUnitsAvailable.2:firstUnit @unit
-    * jump *label316 equal :areUnitsAvailable.2:firstUnit null
+ 1353 jump *label328 equal :areUnitsAvailable.2:firstUnit null
  1354 set *tmp498 2
  1355 set :needsFourUnits.3:unit @unit
  1356 sensor *tmp495 :needsFourUnits.3:unit @speed
 
  1367 op or *tmp503 *tmp500 *tmp502
  1368 jump *label324 equal *tmp503 false
  1369 op add :areUnitsAvailable.2:free :areUnitsAvailable.2:free 1
-    * jump *label326 lessThan :areUnitsAvailable.2:free *tmp498
+ 1370 jump *label325 lessThan :areUnitsAvailable.2:free *tmp498
  1371 set *tmp487 true
  1372 jump *label315 always
  1373 label *label326

Modifications by Final phase, Unreachable Code Elimination, iteration 1 (-19 instructions):
 
    55 label *label10
    56 label *label6
    57 jump *label5 always
-    * label *label7
    58 label *label1
    59 sensor .CORE_X .CORE @x
    60 sensor .CORE_Y .CORE @y
 
   105 jump *label35 lessThan :areUnitsAvailable.0:free *tmp21
   106 set *tmp10 true
   107 jump *label25 always
-    * label *label36
-    * label *label37
-    * jump *label35 always
   108 label *label34
   109 op add :areUnitsAvailable.0:occupied :areUnitsAvailable.0:occupied 1
   110 label *label35
 
   173 jump *label376 lessThan :areUnitsAvailable.1:free *tmp53
   174 set *tmp42 true
   175 jump *label385 always
-    * label *label373
-    * label *label374
-    * jump *label376 always
   176 label *label375
   177 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   178 label *label376
 
   245 jump *label400 lessThan :areUnitsAvailable.1:free *tmp53
   246 set *tmp42 true
   247 jump *label409 always
-    * label *label397
-    * label *label398
-    * jump *label400 always
   248 label *label399
   249 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   250 label *label400
 
   317 jump *label424 lessThan :areUnitsAvailable.1:free *tmp53
   318 set *tmp42 true
   319 jump *label433 always
-    * label *label421
-    * label *label422
-    * jump *label424 always
   320 label *label423
   321 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   322 label *label424
 
   389 jump *label448 lessThan :areUnitsAvailable.1:free *tmp53
   390 set *tmp42 true
   391 jump *label457 always
-    * label *label445
-    * label *label446
-    * jump *label448 always
   392 label *label447
   393 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   394 label *label448
 
   432 printflush message1
   433 label *label23
   434 jump *label22 always
-    * label *label24
-    * set *tmp9 null
   435 label *label21
   436 print "[gold]Binding units..."
   437 printflush message1
 
  1352 jump *label325 lessThan :areUnitsAvailable.2:free *tmp498
  1353 set *tmp487 true
  1354 jump *label315 always
-    * label *label326
-    * label *label327
-    * jump *label325 always
  1355 label *label324
  1356 op add :areUnitsAvailable.2:occupied :areUnitsAvailable.2:occupied 1
  1357 label *label325
 
  1366 label *label316
  1367 label *label317
  1368 jump *label328 always
-    * print UNIT_TYPE
-    * print ":"
-    * print " occupied: "
-    * print :areUnitsAvailable.2:occupied
-    * print ","
-    * print " free: "
-    * print :areUnitsAvailable.2:free
-    * jump *label330 lessThanEq :areUnitsAvailable.2:needed 0
-    * print ", needed: "
-    * print :areUnitsAvailable.2:needed
-    * label *label330
-    * label *label331
-    * print "\n"
  1369 label *label328
  1370 label *label329
  1371 set *tmp487 false
 
  1396 set :locateCore.0*retval .CORE
  1397 label *label334
  1398 return :locateCore.0*retaddr
-    * end

Modifications by Final phase, Dead Code Elimination, iteration 1 (-1 instructions):
 
   564 op sub *tmp136 .DOME_Y .CORE_Y
   565 op len *tmp137 *tmp135 *tmp136
   566 op mul *tmp138 2 *tmp137
-    * sensor *tmp139 .UNIT_S1 @speed
   567 op div :needsFourUnits.2:travel_time *tmp138 .SPEED
   568 op greaterThanEq *tmp134 :needsFourUnits.2:travel_time 47
   569 label *label113

Modifications by Final phase, Single Step Elimination, iteration 1 (-1 instructions):
 
  1364 label *label323
  1365 label *label316
  1366 label *label317
-    * jump *label328 always
  1367 label *label328
  1368 label *label329
  1369 set *tmp487 false

Modifications by Final phase, Print Merging, iteration 1 (-56 instructions):
 
    64 sensor *tmp7 switch1 @enabled
    65 jump *label20 notEqual *tmp7 false
    66 label *label367
-    * print "[coral]Activate switch to begin supplying overdrive dome..."
-    * print "\n"
+   67 print "[coral]Activate switch to begin supplying overdrive dome...\n"
    68 printflush message1
    69 label *label19
    70 sensor *tmp7 switch1 @enabled
 
    72 label *label20
    73 label *label22
    74 printflush null
-    * print "[gold]Looking for suitable unit type:[]"
-    * print "\n"
+   75 print "[gold]Looking for suitable unit type:[]\n"
    76 set :areUnitsAvailable.0:free 0
    77 set :areUnitsAvailable.0:occupied 0
    78 set :areUnitsAvailable.0:needed 0
 
   117 label *label26
   118 label *label27
   119 print UNIT_TYPE
-    * print ":"
-    * print " occupied: "
+  120 print ": occupied: "
   121 print :areUnitsAvailable.0:occupied
-    * print ","
-    * print " free: "
+  122 print ", free: "
   123 print :areUnitsAvailable.0:free
   124 jump *label40 lessThanEq :areUnitsAvailable.0:needed 0
   125 print ", needed: "
 
   182 label *label378
   183 label *label379
   184 label *label380
-    * print @flare
-    * print ":"
-    * print " occupied: "
+  185 print "flare: occupied: "
   186 print :areUnitsAvailable.1:occupied
-    * print ","
-    * print " free: "
+  187 print ", free: "
   188 print :areUnitsAvailable.1:free
   189 jump *label381 lessThanEq :areUnitsAvailable.1:needed 0
   190 print ", needed: "
 
   251 label *label402
   252 label *label403
   253 label *label404
-    * print @poly
-    * print ":"
-    * print " occupied: "
+  254 print "poly: occupied: "
   255 print :areUnitsAvailable.1:occupied
-    * print ","
-    * print " free: "
+  256 print ", free: "
   257 print :areUnitsAvailable.1:free
   258 jump *label405 lessThanEq :areUnitsAvailable.1:needed 0
   259 print ", needed: "
 
   320 label *label426
   321 label *label427
   322 label *label428
-    * print @mega
-    * print ":"
-    * print " occupied: "
+  323 print "mega: occupied: "
   324 print :areUnitsAvailable.1:occupied
-    * print ","
-    * print " free: "
+  325 print ", free: "
   326 print :areUnitsAvailable.1:free
   327 jump *label429 lessThanEq :areUnitsAvailable.1:needed 0
   328 print ", needed: "
 
   389 label *label450
   390 label *label451
   391 label *label452
-    * print @mono
-    * print ":"
-    * print " occupied: "
+  392 print "mono: occupied: "
   393 print :areUnitsAvailable.1:occupied
-    * print ","
-    * print " free: "
+  394 print ", free: "
   395 print :areUnitsAvailable.1:free
   396 jump *label453 lessThanEq :areUnitsAvailable.1:needed 0
   397 print ", needed: "
 
   673 jump __start__ equal *tmp204 false
   674 label *label368
   675 set :start @time
-    * print " === [gold]Supplying Overdrive Dome[] === "
-    * print "\n"
-    * print "\n"
-    * print "Unit type: [green]"
+  676 print " === [gold]Supplying Overdrive Dome[] === \n\nUnit type: [green]"
   677 print *tmp9
-    * print "["
-    * print "]"
-    * print "\n"
-    * print "\n[green]Silicon[] status:\n"
+  678 print "[]\n\n[green]Silicon[] status:\n"
   679 sensor :printDomeStatus.0:level .DOME @silicon
   680 jump *label152 lessThanEq :printDomeStatus.0:level 3
   681 print "  dome:  [green]"
   682 print :printDomeStatus.0:level
-    * print "["
-    * print "]"
-    * print "\n"
+  683 print "[]\n"
   684 jump *label153 always
   685 label *label152
   686 print "  dome:  [coral]"
   687 print :printDomeStatus.0:level
-    * print "["
-    * print "]"
-    * print "\n"
+  688 print "[]\n"
   689 label *label153
   690 label *label151
   691 jump *label156 equal .UNIT_S1 null
 
   808 sensor *tmp268 @unit @totalItems
   809 print "  "
   810 print .GROUP1
-    * print ":"
-    * print " ["
-    * print "gold"
-    * print "]"
+  811 print ": [gold]"
   812 print *tmp268
-    * print "["
-    * print "]"
+  813 print "[]"
   814 jump *label189 lessThan :processUnit.0:distance 0
   815 print .MSG
   816 print :processUnit.0:distance
-    * print "["
-    * print "] sec"
-    * print "\n"
+  817 print "[] sec\n"
   818 jump *label190 always
   819 label *label189
   820 print .MSG
 
   944 sensor *tmp334 @unit @totalItems
   945 print "  "
   946 print .GROUP2
-    * print ":"
-    * print " ["
-    * print "gold"
-    * print "]"
+  947 print ": [gold]"
   948 print *tmp334
-    * print "["
-    * print "]"
+  949 print "[]"
   950 jump *label228 lessThan :processUnit.1:distance 0
   951 print .MSG
   952 print :processUnit.1:distance
-    * print "["
-    * print "] sec"
-    * print "\n"
+  953 print "[] sec\n"
   954 jump *label229 always
   955 label *label228
   956 print .MSG
 
   973 jump *label233 lessThanEq :printDomeStatus.1:level 3
   974 print "  dome:  [green]"
   975 print :printDomeStatus.1:level
-    * print "["
-    * print "]"
-    * print "\n"
+  976 print "[]\n"
   977 jump *label234 always
   978 label *label233
   979 print "  dome:  [coral]"
   980 print :printDomeStatus.1:level
-    * print "["
-    * print "]"
-    * print "\n"
+  981 print "[]\n"
   982 label *label234
   983 label *label232
   984 jump *label237 equal .UNIT_P1 null
 
  1101 sensor *tmp406 @unit @totalItems
  1102 print "  "
  1103 print .GROUP1
-    * print ":"
-    * print " ["
-    * print "gold"
-    * print "]"
+ 1104 print ": [gold]"
  1105 print *tmp406
-    * print "["
-    * print "]"
+ 1106 print "[]"
  1107 jump *label270 lessThan :processUnit.2:distance 0
  1108 print .MSG
  1109 print :processUnit.2:distance
-    * print "["
-    * print "] sec"
-    * print "\n"
+ 1110 print "[] sec\n"
  1111 jump *label271 always
  1112 label *label270
  1113 print .MSG
 
  1237 sensor *tmp472 @unit @totalItems
  1238 print "  "
  1239 print .GROUP2
-    * print ":"
-    * print " ["
-    * print "gold"
-    * print "]"
+ 1240 print ": [gold]"
  1241 print *tmp472
-    * print "["
-    * print "]"
+ 1242 print "[]"
  1243 jump *label309 lessThan :processUnit.3:distance 0
  1244 print .MSG
  1245 print :processUnit.3:distance
-    * print "["
-    * print "] sec"
-    * print "\n"
+ 1246 print "[] sec\n"
  1247 jump *label310 always
  1248 label *label309
  1249 print .MSG
 
  1263 label *label273
  1264 op sub *tmp481 @time :start
  1265 op floor *tmp482 *tmp481
-    * print "\n"
-    * print "[lightgray]Loop time: "
+ 1266 print "\n[lightgray]Loop time: "
  1267 print *tmp482
-    * print " "
-    * print "ms"
+ 1268 print " ms"
  1269 printflush message1
  1270 op notEqual *tmp483 *tmp9 UNIT_TYPE
  1271 op greaterThan *tmp484 :unitCheck @time

Final code before resolving virtual instructions:

        label __start__                                              /// This is the preferred unit type to use for bringing in supplies.
    0:  remark "This is the preferred unit type to use for bringing  ...
    2:  remark "If no units of this type exist, we'll try using othe /// If no units of this type exist, we'll try using other types.
    3:  set UNIT_TYPE @flare                                         param UNIT_TYPE         = @flare;  // Which unit to use
    4:  remark "Do not modify anything below this line."             /// Do not modify anything below this line.
    6:  set .DOME dome1                                              DOME = dome1;
    7:  jump *label4 notEqual dome1 null                             while DOME == null do
        label *label337                                              ...
    8:  print "[gold]Waiting for an overdrive dome to be connected.. print("[gold]Waiting for an overdrive dome to be connected...");
    9:  printflush message1                                          printflush(message1);
   10:  set .DOME dome1                                              DOME = dome1;
   11:  jump *label337 equal dome1 null                              while DOME == null do
        label *label4                                                ...
   12:  print "[gold]Locating core..."                               print("[gold]Locating core...");
   13:  printflush message1                                          printflush(message1);
   14:  set .CORE null                                               CORE = null;
        label *label5                                                while true do
   15:  set :locateCore.0:type @flare                                if locateCore(type) then return; end;
   16:  setaddr :locateCore.0*retaddr *label339                      ...
   17:  call *label0 :locateCore.0*retval                            ...
        label *label339                                              ...
   18:  jump *label1 notEqual :locateCore.0*retval false             ...
   19:  set :locateCore.0:type @poly                                 ...
   20:  setaddr :locateCore.0*retaddr *label346                      ...
   21:  call *label0 :locateCore.0*retval                            ...
        label *label346                                              ...
   22:  jump *label1 notEqual :locateCore.0*retval false             ...
   23:  set :locateCore.0:type @mega                                 ...
   24:  setaddr :locateCore.0*retaddr *label353                      ...
   25:  call *label0 :locateCore.0*retval                            ...
        label *label353                                              ...
   26:  jump *label1 notEqual :locateCore.0*retval false             ...
   27:  set :locateCore.0:type @mono                                 ...
   28:  setaddr :locateCore.0*retaddr *label360                      ...
   29:  call *label0 :locateCore.0*retval                            ...
        label *label360                                              ...
   30:  jump *label1 notEqual :locateCore.0*retval false             ...
   31:  jump *label5 always 0 0                                      while true do
        label *label1                                                locateDomeAndCore();
   32:  sensor .CORE_X .CORE @x                                      CORE_X = CORE.@x;
   33:  sensor .CORE_Y .CORE @y                                      CORE_Y = CORE.@y;
   34:  sensor .DOME_X .DOME @x                                      DOME_X = DOME.@x;
   35:  sensor .DOME_Y .DOME @y                                      DOME_Y = DOME.@y;
   36:  sensor *tmp7 switch1 @enabled                                while not switch1.@enabled do
   37:  jump *label20 notEqual *tmp7 false                           ...
        label *label367                                              ...
   38:  print "[coral]Activate switch to begin supplying overdrive d println("[coral]Activate switch to begin supplying overdrive dome...");
   39:  printflush message1                                          printflush(message1);
   40:  sensor *tmp7 switch1 @enabled                                while not switch1.@enabled do
   41:  jump *label367 equal *tmp7 false                             ...
        label *label20                                               ...
        label *label22                                               while true do
   42:  printflush null                                              printflush(null);       // empty text buffer
   43:  print "[gold]Looking for suitable unit type:[]\n"            println("[gold]Looking for suitable unit type:[]");
   44:  set :areUnitsAvailable.0:free 0                              var free = 0, occupied = 0, needed = 0;
   45:  set :areUnitsAvailable.0:occupied 0                          ...
   46:  set :areUnitsAvailable.0:needed 0                            ...
   47:  ubind UNIT_TYPE                                              var firstUnit = ubind(type);
   48:  set :areUnitsAvailable.0:firstUnit @unit                     ...
   49:  jump *label26 equal :areUnitsAvailable.0:firstUnit null      if firstUnit != null then
   50:  set *tmp21 2                                                 needed = needsFourUnits(@unit) ? 4 : 2;
   51:  set :needsFourUnits.0:unit @unit                             ...
   52:  op sub *tmp14 .DOME_X .CORE_X                                var travel_time = 2 * len(DOME_X - CORE_X, DOME_Y - CORE_Y) / unit.@speed;
   53:  op sub *tmp15 .DOME_Y .CORE_Y                                ...
   54:  op len *tmp16 *tmp14 *tmp15                                  ...
   55:  op mul *tmp17 2 *tmp16                                       ...
   56:  sensor *tmp18 :needsFourUnits.0:unit @speed                  ...
   57:  op div :needsFourUnits.0:travel_time *tmp17 *tmp18           ...
   58:  jump *label30 lessThan :needsFourUnits.0:travel_time 47      needed = needsFourUnits(@unit) ? 4 : 2;
   59:  set *tmp21 4                                                 ...
        label *label30                                               ...
   60:  set :areUnitsAvailable.0:needed *tmp21                       ...
        label *label31                                               do
   61:  sensor *tmp22 @unit @controlled                              if @unit.@controlled == 0 or @unit.@controller == @this then
   62:  op equal *tmp23 *tmp22 0                                     ...
   63:  sensor *tmp24 @unit @controller                              ...
   64:  op equal *tmp25 *tmp24 @this                                 ...
   65:  op or *tmp26 *tmp23 *tmp25                                   ...
   66:  jump *label34 equal *tmp26 false                             ...
   67:  op add :areUnitsAvailable.0:free :areUnitsAvailable.0:free 1 if ++free >= needed then
   68:  jump *label35 lessThan :areUnitsAvailable.0:free *tmp21      ...
   69:  set *tmp10 true                                              return true;
   70:  jump *label25 always 0 0                                     ...
        label *label34                                               if @unit.@controlled == 0 or @unit.@controller == @this then
   71:  op add :areUnitsAvailable.0:occupied :areUnitsAvailable.0:oc ...
        label *label35                                               ...
   72:  ubind UNIT_TYPE                                              ubind(type);
   73:  op notEqual *tmp31 @unit :areUnitsAvailable.0:firstUnit      while @unit != firstUnit and firstUnit.@dead == 0;
   74:  sensor *tmp32 :areUnitsAvailable.0:firstUnit @dead           ...
   75:  op equal *tmp33 *tmp32 0                                     ...
   76:  op land *tmp34 *tmp31 *tmp33                                 ...
   77:  jump *label31 notEqual *tmp34 false                          do
        label *label26                                               if firstUnit != null then
   78:  print UNIT_TYPE                                              print($"$type: occupied: $occupied, free: $free");
   79:  print ": occupied: "                                         ...
   80:  print :areUnitsAvailable.0:occupied                          ...
   81:  print ", free: "                                             ...
   82:  print :areUnitsAvailable.0:free                              ...
   83:  jump *label40 lessThanEq :areUnitsAvailable.0:needed 0       if needed > 0 then print($", needed: $needed"); end;
   84:  print ", needed: "                                           ...
   85:  print :areUnitsAvailable.0:needed                            ...
        label *label40                                               ...
   86:  print "\n"                                                   println();
   87:  set *tmp10 false                                             return false;
        label *label25                                               if areUnitsAvailable(UNIT_TYPE, true) then
   88:  jump *label42 equal *tmp10 false                             ...
   89:  set *tmp9 UNIT_TYPE                                          return UNIT_TYPE;
   90:  jump *label21 always 0 0                                     ...
        label *label42                                               if areUnitsAvailable(UNIT_TYPE, true) then
   91:  jump *label388 equal @flare UNIT_TYPE                        if type != UNIT_TYPE then
   92:  set :areUnitsAvailable.1:free 0                              var free = 0, occupied = 0, needed = 0;
   93:  set :areUnitsAvailable.1:occupied 0                          ...
   94:  set :areUnitsAvailable.1:needed 0                            ...
   95:  ubind @flare                                                 var firstUnit = ubind(type);
   96:  set :areUnitsAvailable.1:firstUnit @unit                     ...
   97:  jump *label379 equal :areUnitsAvailable.1:firstUnit null     if firstUnit != null then
   98:  set *tmp53 2                                                 needed = needsFourUnits(@unit) ? 4 : 2;
   99:  set :needsFourUnits.1:unit @unit                             ...
  100:  op sub *tmp46 .DOME_X .CORE_X                                var travel_time = 2 * len(DOME_X - CORE_X, DOME_Y - CORE_Y) / unit.@speed;
  101:  op sub *tmp47 .DOME_Y .CORE_Y                                ...
  102:  op len *tmp48 *tmp46 *tmp47                                  ...
  103:  op mul *tmp49 2 *tmp48                                       ...
  104:  sensor *tmp50 :needsFourUnits.1:unit @speed                  ...
  105:  op div :needsFourUnits.1:travel_time *tmp49 *tmp50           ...
  106:  op greaterThanEq *tmp45 :needsFourUnits.1:travel_time 47     return travel_time >= SUPPLY_INTERVAL;
  107:  jump *label371 equal *tmp45 false                            needed = needsFourUnits(@unit) ? 4 : 2;
  108:  set *tmp53 4                                                 ...
        label *label371                                              ...
  109:  set :areUnitsAvailable.1:needed *tmp53                       ...
        label *label372                                              do
  110:  sensor *tmp54 @unit @controlled                              if @unit.@controlled == 0 or @unit.@controller == @this then
  111:  op equal *tmp55 *tmp54 0                                     ...
  112:  sensor *tmp56 @unit @controller                              ...
  113:  op equal *tmp57 *tmp56 @this                                 ...
  114:  op or *tmp58 *tmp55 *tmp57                                   ...
  115:  jump *label375 equal *tmp58 false                            ...
  116:  op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1 if ++free >= needed then
  117:  jump *label376 lessThan :areUnitsAvailable.1:free *tmp53     ...
  118:  set *tmp42 true                                              return true;
  119:  jump *label385 always 0 0                                    ...
        label *label375                                              if @unit.@controlled == 0 or @unit.@controller == @this then
  120:  op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:oc ...
        label *label376                                              ...
  121:  ubind @flare                                                 ubind(type);
  122:  op notEqual *tmp63 @unit :areUnitsAvailable.1:firstUnit      while @unit != firstUnit and firstUnit.@dead == 0;
  123:  sensor *tmp64 :areUnitsAvailable.1:firstUnit @dead           ...
  124:  op equal *tmp65 *tmp64 0                                     ...
  125:  op land *tmp66 *tmp63 *tmp65                                 ...
  126:  jump *label372 notEqual *tmp66 false                         do
        label *label379                                              if firstUnit != null then
  127:  print "flare: occupied: "                                    print($"$type: occupied: $occupied, free: $free");
  128:  print :areUnitsAvailable.1:occupied                          ...
  129:  print ", free: "                                             ...
  130:  print :areUnitsAvailable.1:free                              ...
  131:  jump *label381 lessThanEq :areUnitsAvailable.1:needed 0      if needed > 0 then print($", needed: $needed"); end;
  132:  print ", needed: "                                           ...
  133:  print :areUnitsAvailable.1:needed                            ...
        label *label381                                              ...
  134:  print "\n"                                                   println();
  135:  set *tmp42 false                                             return false;
        label *label385                                              if areUnitsAvailable(type, true) then
  136:  jump *label386 equal *tmp42 false                            ...
  137:  printflush null                                              printflush(null);
  138:  set *tmp9 @flare                                             return type;
  139:  jump *label21 always 0 0                                     ...
        label *label386                                              if areUnitsAvailable(type, true) then
        label *label388                                              if type != UNIT_TYPE then
  140:  jump *label412 equal @poly UNIT_TYPE                         ...
  141:  set :areUnitsAvailable.1:free 0                              var free = 0, occupied = 0, needed = 0;
  142:  set :areUnitsAvailable.1:occupied 0                          ...
  143:  set :areUnitsAvailable.1:needed 0                            ...
  144:  ubind @poly                                                  var firstUnit = ubind(type);
  145:  set :areUnitsAvailable.1:firstUnit @unit                     ...
  146:  jump *label403 equal :areUnitsAvailable.1:firstUnit null     if firstUnit != null then
  147:  set *tmp53 2                                                 needed = needsFourUnits(@unit) ? 4 : 2;
  148:  set :needsFourUnits.1:unit @unit                             ...
  149:  op sub *tmp46 .DOME_X .CORE_X                                var travel_time = 2 * len(DOME_X - CORE_X, DOME_Y - CORE_Y) / unit.@speed;
  150:  op sub *tmp47 .DOME_Y .CORE_Y                                ...
  151:  op len *tmp48 *tmp46 *tmp47                                  ...
  152:  op mul *tmp49 2 *tmp48                                       ...
  153:  sensor *tmp50 :needsFourUnits.1:unit @speed                  ...
  154:  op div :needsFourUnits.1:travel_time *tmp49 *tmp50           ...
  155:  op greaterThanEq *tmp45 :needsFourUnits.1:travel_time 47     return travel_time >= SUPPLY_INTERVAL;
  156:  jump *label395 equal *tmp45 false                            needed = needsFourUnits(@unit) ? 4 : 2;
  157:  set *tmp53 4                                                 ...
        label *label395                                              ...
  158:  set :areUnitsAvailable.1:needed *tmp53                       ...
        label *label396                                              do
  159:  sensor *tmp54 @unit @controlled                              if @unit.@controlled == 0 or @unit.@controller == @this then
  160:  op equal *tmp55 *tmp54 0                                     ...
  161:  sensor *tmp56 @unit @controller                              ...
  162:  op equal *tmp57 *tmp56 @this                                 ...
  163:  op or *tmp58 *tmp55 *tmp57                                   ...
  164:  jump *label399 equal *tmp58 false                            ...
  165:  op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1 if ++free >= needed then
  166:  jump *label400 lessThan :areUnitsAvailable.1:free *tmp53     ...
  167:  set *tmp42 true                                              return true;
  168:  jump *label409 always 0 0                                    ...
        label *label399                                              if @unit.@controlled == 0 or @unit.@controller == @this then
  169:  op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:oc ...
        label *label400                                              ...
  170:  ubind @poly                                                  ubind(type);
  171:  op notEqual *tmp63 @unit :areUnitsAvailable.1:firstUnit      while @unit != firstUnit and firstUnit.@dead == 0;
  172:  sensor *tmp64 :areUnitsAvailable.1:firstUnit @dead           ...
  173:  op equal *tmp65 *tmp64 0                                     ...
  174:  op land *tmp66 *tmp63 *tmp65                                 ...
  175:  jump *label396 notEqual *tmp66 false                         do
        label *label403                                              if firstUnit != null then
  176:  print "poly: occupied: "                                     print($"$type: occupied: $occupied, free: $free");
  177:  print :areUnitsAvailable.1:occupied                          ...
  178:  print ", free: "                                             ...
  179:  print :areUnitsAvailable.1:free                              ...
  180:  jump *label405 lessThanEq :areUnitsAvailable.1:needed 0      if needed > 0 then print($", needed: $needed"); end;
  181:  print ", needed: "                                           ...
  182:  print :areUnitsAvailable.1:needed                            ...
        label *label405                                              ...
  183:  print "\n"                                                   println();
  184:  set *tmp42 false                                             return false;
        label *label409                                              if areUnitsAvailable(type, true) then
  185:  jump *label410 equal *tmp42 false                            ...
  186:  printflush null                                              printflush(null);
  187:  set *tmp9 @poly                                              return type;
  188:  jump *label21 always 0 0                                     ...
        label *label410                                              if areUnitsAvailable(type, true) then
        label *label412                                              if type != UNIT_TYPE then
  189:  jump *label436 equal @mega UNIT_TYPE                         ...
  190:  set :areUnitsAvailable.1:free 0                              var free = 0, occupied = 0, needed = 0;
  191:  set :areUnitsAvailable.1:occupied 0                          ...
  192:  set :areUnitsAvailable.1:needed 0                            ...
  193:  ubind @mega                                                  var firstUnit = ubind(type);
  194:  set :areUnitsAvailable.1:firstUnit @unit                     ...
  195:  jump *label427 equal :areUnitsAvailable.1:firstUnit null     if firstUnit != null then
  196:  set *tmp53 2                                                 needed = needsFourUnits(@unit) ? 4 : 2;
  197:  set :needsFourUnits.1:unit @unit                             ...
  198:  op sub *tmp46 .DOME_X .CORE_X                                var travel_time = 2 * len(DOME_X - CORE_X, DOME_Y - CORE_Y) / unit.@speed;
  199:  op sub *tmp47 .DOME_Y .CORE_Y                                ...
  200:  op len *tmp48 *tmp46 *tmp47                                  ...
  201:  op mul *tmp49 2 *tmp48                                       ...
  202:  sensor *tmp50 :needsFourUnits.1:unit @speed                  ...
  203:  op div :needsFourUnits.1:travel_time *tmp49 *tmp50           ...
  204:  op greaterThanEq *tmp45 :needsFourUnits.1:travel_time 47     return travel_time >= SUPPLY_INTERVAL;
  205:  jump *label419 equal *tmp45 false                            needed = needsFourUnits(@unit) ? 4 : 2;
  206:  set *tmp53 4                                                 ...
        label *label419                                              ...
  207:  set :areUnitsAvailable.1:needed *tmp53                       ...
        label *label420                                              do
  208:  sensor *tmp54 @unit @controlled                              if @unit.@controlled == 0 or @unit.@controller == @this then
  209:  op equal *tmp55 *tmp54 0                                     ...
  210:  sensor *tmp56 @unit @controller                              ...
  211:  op equal *tmp57 *tmp56 @this                                 ...
  212:  op or *tmp58 *tmp55 *tmp57                                   ...
  213:  jump *label423 equal *tmp58 false                            ...
  214:  op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1 if ++free >= needed then
  215:  jump *label424 lessThan :areUnitsAvailable.1:free *tmp53     ...
  216:  set *tmp42 true                                              return true;
  217:  jump *label433 always 0 0                                    ...
        label *label423                                              if @unit.@controlled == 0 or @unit.@controller == @this then
  218:  op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:oc ...
        label *label424                                              ...
  219:  ubind @mega                                                  ubind(type);
  220:  op notEqual *tmp63 @unit :areUnitsAvailable.1:firstUnit      while @unit != firstUnit and firstUnit.@dead == 0;
  221:  sensor *tmp64 :areUnitsAvailable.1:firstUnit @dead           ...
  222:  op equal *tmp65 *tmp64 0                                     ...
  223:  op land *tmp66 *tmp63 *tmp65                                 ...
  224:  jump *label420 notEqual *tmp66 false                         do
        label *label427                                              if firstUnit != null then
  225:  print "mega: occupied: "                                     print($"$type: occupied: $occupied, free: $free");
  226:  print :areUnitsAvailable.1:occupied                          ...
  227:  print ", free: "                                             ...
  228:  print :areUnitsAvailable.1:free                              ...
  229:  jump *label429 lessThanEq :areUnitsAvailable.1:needed 0      if needed > 0 then print($", needed: $needed"); end;
  230:  print ", needed: "                                           ...
  231:  print :areUnitsAvailable.1:needed                            ...
        label *label429                                              ...
  232:  print "\n"                                                   println();
  233:  set *tmp42 false                                             return false;
        label *label433                                              if areUnitsAvailable(type, true) then
  234:  jump *label434 equal *tmp42 false                            ...
  235:  printflush null                                              printflush(null);
  236:  set *tmp9 @mega                                              return type;
  237:  jump *label21 always 0 0                                     ...
        label *label434                                              if areUnitsAvailable(type, true) then
        label *label436                                              if type != UNIT_TYPE then
  238:  jump *label460 equal @mono UNIT_TYPE                         ...
  239:  set :areUnitsAvailable.1:free 0                              var free = 0, occupied = 0, needed = 0;
  240:  set :areUnitsAvailable.1:occupied 0                          ...
  241:  set :areUnitsAvailable.1:needed 0                            ...
  242:  ubind @mono                                                  var firstUnit = ubind(type);
  243:  set :areUnitsAvailable.1:firstUnit @unit                     ...
  244:  jump *label451 equal :areUnitsAvailable.1:firstUnit null     if firstUnit != null then
  245:  set *tmp53 2                                                 needed = needsFourUnits(@unit) ? 4 : 2;
  246:  set :needsFourUnits.1:unit @unit                             ...
  247:  op sub *tmp46 .DOME_X .CORE_X                                var travel_time = 2 * len(DOME_X - CORE_X, DOME_Y - CORE_Y) / unit.@speed;
  248:  op sub *tmp47 .DOME_Y .CORE_Y                                ...
  249:  op len *tmp48 *tmp46 *tmp47                                  ...
  250:  op mul *tmp49 2 *tmp48                                       ...
  251:  sensor *tmp50 :needsFourUnits.1:unit @speed                  ...
  252:  op div :needsFourUnits.1:travel_time *tmp49 *tmp50           ...
  253:  op greaterThanEq *tmp45 :needsFourUnits.1:travel_time 47     return travel_time >= SUPPLY_INTERVAL;
  254:  jump *label443 equal *tmp45 false                            needed = needsFourUnits(@unit) ? 4 : 2;
  255:  set *tmp53 4                                                 ...
        label *label443                                              ...
  256:  set :areUnitsAvailable.1:needed *tmp53                       ...
        label *label444                                              do
  257:  sensor *tmp54 @unit @controlled                              if @unit.@controlled == 0 or @unit.@controller == @this then
  258:  op equal *tmp55 *tmp54 0                                     ...
  259:  sensor *tmp56 @unit @controller                              ...
  260:  op equal *tmp57 *tmp56 @this                                 ...
  261:  op or *tmp58 *tmp55 *tmp57                                   ...
  262:  jump *label447 equal *tmp58 false                            ...
  263:  op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1 if ++free >= needed then
  264:  jump *label448 lessThan :areUnitsAvailable.1:free *tmp53     ...
  265:  set *tmp42 true                                              return true;
  266:  jump *label457 always 0 0                                    ...
        label *label447                                              if @unit.@controlled == 0 or @unit.@controller == @this then
  267:  op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:oc ...
        label *label448                                              ...
  268:  ubind @mono                                                  ubind(type);
  269:  op notEqual *tmp63 @unit :areUnitsAvailable.1:firstUnit      while @unit != firstUnit and firstUnit.@dead == 0;
  270:  sensor *tmp64 :areUnitsAvailable.1:firstUnit @dead           ...
  271:  op equal *tmp65 *tmp64 0                                     ...
  272:  op land *tmp66 *tmp63 *tmp65                                 ...
  273:  jump *label444 notEqual *tmp66 false                         do
        label *label451                                              if firstUnit != null then
  274:  print "mono: occupied: "                                     print($"$type: occupied: $occupied, free: $free");
  275:  print :areUnitsAvailable.1:occupied                          ...
  276:  print ", free: "                                             ...
  277:  print :areUnitsAvailable.1:free                              ...
  278:  jump *label453 lessThanEq :areUnitsAvailable.1:needed 0      if needed > 0 then print($", needed: $needed"); end;
  279:  print ", needed: "                                           ...
  280:  print :areUnitsAvailable.1:needed                            ...
        label *label453                                              ...
  281:  print "\n"                                                   println();
  282:  set *tmp42 false                                             return false;
        label *label457                                              if areUnitsAvailable(type, true) then
  283:  jump *label458 equal *tmp42 false                            ...
  284:  printflush null                                              printflush(null);
  285:  set *tmp9 @mono                                              return type;
  286:  jump *label21 always 0 0                                     ...
        label *label458                                              if areUnitsAvailable(type, true) then
        label *label460                                              if type != UNIT_TYPE then
  287:  printflush message1                                          printflush(message1);
  288:  jump *label22 always 0 0                                     while true do
        label *label21                                               TYPE = chooseUnitType();
  289:  print "[gold]Binding units..."                               print("[gold]Binding units...");
  290:  printflush message1                                          printflush(message1);
  291:  set .UNIT_P2 null                                            UNIT_S1 = UNIT_P1 = UNIT_S2 = UNIT_P2 = null;
  292:  set .UNIT_S2 null                                            ...
  293:  set .UNIT_P1 null                                            ...
  294:  set .UNIT_S1 null                                            ...
  295:  set :rebindUnits.0:count 0                                   var count = 0;
  296:  ubind *tmp9                                                  var firstUnit = ubind(TYPE);
  297:  set :rebindUnits.0:firstUnit @unit                           ...
  298:  jump *label73 notEqual :rebindUnits.0:firstUnit null         if firstUnit == null then
  299:  end                                                          end();
        label *label73                                               if firstUnit == null then
        label *label75                                               do
  300:  sensor *tmp74 @unit @controller                              if @unit.@controller == @this then
  301:  jump *label78 notEqual *tmp74 @this                          ...
  302:  op add :rebindUnits.0:count :rebindUnits.0:count 1           ...
  303:  ucontrol flag 1 0 0 0 0                                      flag(S_INIT);
  304:  set .UNIT_S2 .UNIT_P2                                        UNIT_S2 = UNIT_P2;
  305:  set .UNIT_P2 .UNIT_S1                                        UNIT_P2 = UNIT_S1;
  306:  set .UNIT_S1 .UNIT_P1                                        UNIT_S1 = UNIT_P1;
  307:  set .UNIT_P1 @unit                                           UNIT_P1 = @unit;
  308:  jump *label77 notEqual .UNIT_S2 null                         if UNIT_S2 != null then
        label *label78                                               if @unit.@controller == @this then
  309:  ubind *tmp9                                                  ubind(TYPE);
  310:  op notEqual *tmp81 @unit :rebindUnits.0:firstUnit            while @unit != firstUnit and firstUnit.@dead == 0;
  311:  sensor *tmp82 :rebindUnits.0:firstUnit @dead                 ...
  312:  op equal *tmp83 *tmp82 0                                     ...
  313:  op land *tmp84 *tmp81 *tmp83                                 ...
  314:  jump *label75 notEqual *tmp84 false                          do
        label *label77                                               ...
  315:  jump *label84 equal .UNIT_S1 null                            if currentUnit != null then
  316:  ubind .UNIT_S1                                               ubind(currentUnit);
  317:  sensor *tmp89 @unit @dead                                    if @unit.@dead === 0 && @unit.@controller == @this then
  318:  op strictEqual *tmp90 *tmp89 0                               ...
  319:  sensor *tmp91 @unit @controller                              ...
  320:  op equal *tmp92 *tmp91 @this                                 ...
  321:  op land *tmp93 *tmp90 *tmp92                                 ...
  322:  jump *label83 notEqual *tmp93 false                          ...
        label *label84                                               if currentUnit != null then
  323:  ubind *tmp9                                                  var firstUnit = ubind(TYPE);
  324:  set :rebindUnit.0:firstUnit @unit                            ...
  325:  jump __start__ equal :rebindUnit.0:firstUnit null            if firstUnit != null then
        label *label90                                               do
  326:  sensor *tmp97 @unit @controlled                              if @unit.@controlled == 0 then
  327:  jump *label83 equal *tmp97 0                                 ...
  328:  ubind *tmp9                                                  ubind(TYPE);
  329:  op notEqual *tmp100 @unit :rebindUnit.0:firstUnit            while @unit != firstUnit and firstUnit.@dead == 0;
  330:  sensor *tmp101 :rebindUnit.0:firstUnit @dead                 ...
  331:  op equal *tmp102 *tmp101 0                                   ...
  332:  op land *tmp103 *tmp100 *tmp102                              ...
  333:  jump *label90 notEqual *tmp103 false                         do
  334:  end                                                          end();
        label *label83                                               rebindUnit(currentUnit);
  335:  ucontrol flag 1 0 0 0 0                                      flag(S_INIT);
  336:  set *tmp85 @unit                                             return @unit;
  337:  set .UNIT_S1 *tmp85                                          UNIT_S1 = acquireUnit(UNIT_S1);
  338:  jump *label97 equal .UNIT_P1 null                            if currentUnit != null then
  339:  ubind .UNIT_P1                                               ubind(currentUnit);
  340:  sensor *tmp108 @unit @dead                                   if @unit.@dead === 0 && @unit.@controller == @this then
  341:  op strictEqual *tmp109 *tmp108 0                             ...
  342:  sensor *tmp110 @unit @controller                             ...
  343:  op equal *tmp111 *tmp110 @this                               ...
  344:  op land *tmp112 *tmp109 *tmp111                              ...
  345:  jump *label96 notEqual *tmp112 false                         ...
        label *label97                                               if currentUnit != null then
  346:  ubind *tmp9                                                  var firstUnit = ubind(TYPE);
  347:  set :rebindUnit.1:firstUnit @unit                            ...
  348:  jump __start__ equal :rebindUnit.1:firstUnit null            if firstUnit != null then
        label *label103                                              do
  349:  sensor *tmp116 @unit @controlled                             if @unit.@controlled == 0 then
  350:  jump *label96 equal *tmp116 0                                ...
  351:  ubind *tmp9                                                  ubind(TYPE);
  352:  op notEqual *tmp119 @unit :rebindUnit.1:firstUnit            while @unit != firstUnit and firstUnit.@dead == 0;
  353:  sensor *tmp120 :rebindUnit.1:firstUnit @dead                 ...
  354:  op equal *tmp121 *tmp120 0                                   ...
  355:  op land *tmp122 *tmp119 *tmp121                              ...
  356:  jump *label103 notEqual *tmp122 false                        do
  357:  end                                                          end();
        label *label96                                               rebindUnit(currentUnit);
  358:  ucontrol flag 1 0 0 0 0                                      flag(S_INIT);
  359:  set *tmp104 @unit                                            return @unit;
  360:  set .UNIT_P1 *tmp104                                         UNIT_P1 = acquireUnit(UNIT_P1);
  361:  sensor *tmp123 *tmp85 @firstItem                             if UNIT_S1.@firstItem == @phase-fabric or UNIT_P1.@firstItem == @silicon then
  362:  op equal *tmp124 *tmp123 @phase-fabric                       ...
  363:  sensor *tmp125 *tmp104 @firstItem                            ...
  364:  op equal *tmp126 *tmp125 @silicon                            ...
  365:  op or *tmp127 *tmp124 *tmp126                                ...
  366:  jump *label108 equal *tmp127 false                           ...
  367:  set .UNIT_S1 *tmp104                                         swap(out UNIT_S1, out UNIT_P1);
  368:  set .UNIT_P1 *tmp85                                          ...
        label *label108                                              if UNIT_S1.@firstItem == @phase-fabric or UNIT_P1.@firstItem == @silicon then
  369:  sensor .UNIT_CAPACITY .UNIT_S1 @itemCapacity                 UNIT_CAPACITY = UNIT_S1.@itemCapacity;
  370:  sensor .SPEED .UNIT_S1 @speed                                SPEED = UNIT_S1.@speed;
  371:  op div .SPEED_TENTHS .SPEED 10                               SPEED_TENTHS = SPEED / 10;
  372:  op strictEqual *tmp132 .SPEED null                           if SPEED === null then
  373:  jump *label111 equal *tmp132 false                           ...
  374:  stop                                                         stopProcessor();
        label *label111                                              if SPEED === null then
  375:  op sub *tmp135 .DOME_X .CORE_X                               var travel_time = 2 * len(DOME_X - CORE_X, DOME_Y - CORE_Y) / unit.@speed;
  376:  op sub *tmp136 .DOME_Y .CORE_Y                               ...
  377:  op len *tmp137 *tmp135 *tmp136                               ...
  378:  op mul *tmp138 2 *tmp137                                     ...
  379:  op div :needsFourUnits.2:travel_time *tmp138 .SPEED          ...
  380:  op greaterThanEq *tmp134 :needsFourUnits.2:travel_time 47    return travel_time >= SUPPLY_INTERVAL;
  381:  jump *label114 equal *tmp134 false                           if FOUR_UNITS then
  382:  jump *label118 equal .UNIT_S2 null                           if currentUnit != null then
  383:  ubind .UNIT_S2                                               ubind(currentUnit);
  384:  sensor *tmp147 @unit @dead                                   if @unit.@dead === 0 && @unit.@controller == @this then
  385:  op strictEqual *tmp148 *tmp147 0                             ...
  386:  sensor *tmp149 @unit @controller                             ...
  387:  op equal *tmp150 *tmp149 @this                               ...
  388:  op land *tmp151 *tmp148 *tmp150                              ...
  389:  jump *label117 notEqual *tmp151 false                        ...
        label *label118                                              if currentUnit != null then
  390:  ubind *tmp9                                                  var firstUnit = ubind(TYPE);
  391:  set :rebindUnit.2:firstUnit @unit                            ...
  392:  jump __start__ equal :rebindUnit.2:firstUnit null            if firstUnit != null then
        label *label124                                              do
  393:  sensor *tmp155 @unit @controlled                             if @unit.@controlled == 0 then
  394:  jump *label117 equal *tmp155 0                               ...
  395:  ubind *tmp9                                                  ubind(TYPE);
  396:  op notEqual *tmp158 @unit :rebindUnit.2:firstUnit            while @unit != firstUnit and firstUnit.@dead == 0;
  397:  sensor *tmp159 :rebindUnit.2:firstUnit @dead                 ...
  398:  op equal *tmp160 *tmp159 0                                   ...
  399:  op land *tmp161 *tmp158 *tmp160                              ...
  400:  jump *label124 notEqual *tmp161 false                        do
  401:  end                                                          end();
        label *label117                                              rebindUnit(currentUnit);
  402:  ucontrol flag 1 0 0 0 0                                      flag(S_INIT);
  403:  set *tmp143 @unit                                            return @unit;
  404:  set .UNIT_S2 *tmp143                                         UNIT_S2 = acquireUnit(UNIT_S2);
  405:  jump *label131 equal .UNIT_P2 null                           if currentUnit != null then
  406:  ubind .UNIT_P2                                               ubind(currentUnit);
  407:  sensor *tmp166 @unit @dead                                   if @unit.@dead === 0 && @unit.@controller == @this then
  408:  op strictEqual *tmp167 *tmp166 0                             ...
  409:  sensor *tmp168 @unit @controller                             ...
  410:  op equal *tmp169 *tmp168 @this                               ...
  411:  op land *tmp170 *tmp167 *tmp169                              ...
  412:  jump *label130 notEqual *tmp170 false                        ...
        label *label131                                              if currentUnit != null then
  413:  ubind *tmp9                                                  var firstUnit = ubind(TYPE);
  414:  set :rebindUnit.3:firstUnit @unit                            ...
  415:  jump __start__ equal :rebindUnit.3:firstUnit null            if firstUnit != null then
        label *label137                                              do
  416:  sensor *tmp174 @unit @controlled                             if @unit.@controlled == 0 then
  417:  jump *label130 equal *tmp174 0                               ...
  418:  ubind *tmp9                                                  ubind(TYPE);
  419:  op notEqual *tmp177 @unit :rebindUnit.3:firstUnit            while @unit != firstUnit and firstUnit.@dead == 0;
  420:  sensor *tmp178 :rebindUnit.3:firstUnit @dead                 ...
  421:  op equal *tmp179 *tmp178 0                                   ...
  422:  op land *tmp180 *tmp177 *tmp179                              ...
  423:  jump *label137 notEqual *tmp180 false                        do
  424:  end                                                          end();
        label *label130                                              rebindUnit(currentUnit);
  425:  ucontrol flag 1 0 0 0 0                                      flag(S_INIT);
  426:  set *tmp162 @unit                                            return @unit;
  427:  set .UNIT_P2 *tmp162                                         UNIT_P2 = acquireUnit(UNIT_P2);
  428:  sensor *tmp181 .UNIT_S1 @firstItem                           if UNIT_S1.@firstItem == @phase-fabric and UNIT_P2.@firstItem != @phase-fabric then
  429:  op equal *tmp182 *tmp181 @phase-fabric                       ...
  430:  sensor *tmp183 *tmp162 @firstItem                            ...
  431:  op notEqual *tmp184 *tmp183 @phase-fabric                    ...
  432:  op land *tmp185 *tmp182 *tmp184                              ...
  433:  jump *label142 equal *tmp185 false                           ...
  434:  set .UNIT_P2 .UNIT_S1                                        var t = a; a = b; b = t;
  435:  set .UNIT_S1 *tmp162                                         swap(out UNIT_S1, out UNIT_P2);
        label *label142                                              if UNIT_S1.@firstItem == @phase-fabric and UNIT_P2.@firstItem != @phase-fabric then
  436:  sensor *tmp187 *tmp143 @firstItem                            if UNIT_S2.@firstItem == @phase-fabric or UNIT_P2.@firstItem == @silicon then
  437:  op equal *tmp188 *tmp187 @phase-fabric                       ...
  438:  sensor *tmp189 .UNIT_P2 @firstItem                           ...
  439:  op equal *tmp190 *tmp189 @silicon                            ...
  440:  op or *tmp191 *tmp188 *tmp190                                ...
  441:  jump *label145 equal *tmp191 false                           ...
  442:  set .UNIT_S2 .UNIT_P2                                        swap(out UNIT_S2, out UNIT_P2);
  443:  set .UNIT_P2 *tmp143                                         ...
        label *label145                                              if UNIT_S2.@firstItem == @phase-fabric or UNIT_P2.@firstItem == @silicon then
  444:  set .GROUP1 "unit  1"                                        GROUP1 = "unit  1";
  445:  set .GROUP2 "unit 2"                                         GROUP2 = "unit 2";
  446:  jump *label115 always 0 0                                    if FOUR_UNITS then
        label *label114                                              ...
  447:  ubind .UNIT_S2                                               ubind(UNIT_S2); unbind(); UNIT_S2 = null;
  448:  ucontrol unbind 0 0 0 0 0                                    ...
  449:  set .UNIT_S2 null                                            ...
  450:  ubind .UNIT_P2                                               ubind(UNIT_P2); unbind(); UNIT_P2 = null;
  451:  ucontrol unbind 0 0 0 0 0                                    ...
  452:  set .UNIT_P2 null                                            ...
  453:  set .GROUP1 "unit"                                           GROUP1 = "unit";
        label *label115                                              if FOUR_UNITS then
  454:  op equal *tmp193 *tmp134 false                               SUPPLY_S_FIRST = not FOUR_UNITS or UNIT_S1.@totalItems < UNIT_S2.@totalItems;
  455:  sensor *tmp194 .UNIT_S1 @totalItems                          ...
  456:  sensor *tmp195 .UNIT_S2 @totalItems                          ...
  457:  op lessThan *tmp196 *tmp194 *tmp195                          ...
  458:  op or .SUPPLY_S_FIRST *tmp193 *tmp196                        ...
  459:  sensor *tmp199 .UNIT_P1 @totalItems                          SUPPLY_P_FIRST = not FOUR_UNITS or UNIT_P1.@totalItems < UNIT_P2.@totalItems;
  460:  sensor *tmp200 .UNIT_P2 @totalItems                          ...
  461:  op lessThan *tmp201 *tmp199 *tmp200                          ...
  462:  op or .SUPPLY_P_FIRST *tmp193 *tmp201                        ...
  463:  op add :unitCheck @time 5000                                 var unitCheck = @time + UNIT_CHECK_TIME;
  464:  sensor *tmp204 switch1 @enabled                              while switch1.@enabled do
  465:  jump __start__ equal *tmp204 false                           ...
        label *label368                                              ...
  466:  set :start @time                                             var start = @time;
  467:  print " === [gold]Supplying Overdrive Dome[] === \n\nUnit ty println($"Unit type: [green]$TYPE[]");
  468:  print *tmp9                                                  ...
  469:  print "[]\n\n[green]Silicon[] status:\n"                     print(text);
  470:  sensor :printDomeStatus.0:level .DOME @silicon               var level = DOME.sensor(item);
  471:  jump *label152 lessThanEq :printDomeStatus.0:level 3         if level > 3 then
  472:  print "  dome:  [green]"                                     println($"  dome:  [green]$level[]");
  473:  print :printDomeStatus.0:level                               ...
  474:  print "[]\n"                                                 ...
  475:  jump *label153 always 0 0                                    if level > 3 then
        label *label152                                              ...
  476:  print "  dome:  [coral]"                                     println($"  dome:  [coral]$level[]");
  477:  print :printDomeStatus.0:level                               ...
  478:  print "[]\n"                                                 ...
        label *label153                                              if level > 3 then
  479:  jump *label156 equal .UNIT_S1 null                           if currentUnit != null then
  480:  ubind .UNIT_S1                                               ubind(currentUnit);
  481:  sensor *tmp211 @unit @dead                                   if @unit.@dead === 0 && @unit.@controller == @this then
  482:  op strictEqual *tmp212 *tmp211 0                             ...
  483:  sensor *tmp213 @unit @controller                             ...
  484:  op equal *tmp214 *tmp213 @this                               ...
  485:  op land *tmp215 *tmp212 *tmp214                              ...
  486:  jump *label155 notEqual *tmp215 false                        ...
        label *label156                                              if currentUnit != null then
  487:  ubind *tmp9                                                  var firstUnit = ubind(TYPE);
  488:  set :rebindUnit.4:firstUnit @unit                            ...
  489:  jump __start__ equal :rebindUnit.4:firstUnit null            if firstUnit != null then
        label *label162                                              do
  490:  sensor *tmp219 @unit @controlled                             if @unit.@controlled == 0 then
  491:  jump *label155 equal *tmp219 0                               ...
  492:  ubind *tmp9                                                  ubind(TYPE);
  493:  op notEqual *tmp222 @unit :rebindUnit.4:firstUnit            while @unit != firstUnit and firstUnit.@dead == 0;
  494:  sensor *tmp223 :rebindUnit.4:firstUnit @dead                 ...
  495:  op equal *tmp224 *tmp223 0                                   ...
  496:  op land *tmp225 *tmp222 *tmp224                              ...
  497:  jump *label162 notEqual *tmp225 false                        do
  498:  end                                                          end();
        label *label155                                              rebindUnit(unit);
  499:  sensor :processUnit.0:state @unit @flag                      var state = @unit.@flag;
  500:  set :processUnit.0:distance -1                               var distance = -1;
  501:  op lessThan *tmp227 :processUnit.0:state 2                   if state < S_APPROACH_SRC or state > S_APPROACH_DST then
  502:  op greaterThan *tmp228 :processUnit.0:state 3                ...
  503:  op or *tmp229 *tmp227 *tmp228                                ...
  504:  jump *label167 equal *tmp229 false                           ...
  505:  sensor *tmp231 @unit @firstItem                              if @unit.@firstItem == item then
  506:  jump *label169 notEqual *tmp231 @silicon                     ...
  507:  set :processUnit.0:state 3                                   state = S_APPROACH_DST;
  508:  jump *label170 always 0 0                                    if @unit.@firstItem == item then
        label *label169                                              ...
  509:  sensor *tmp234 @unit @totalItems                             elsif @unit.@totalItems == 0 then
  510:  jump *label171 notEqual *tmp234 0                            ...
  511:  set :processUnit.0:state 2                                   state = S_APPROACH_SRC;
  512:  jump *label172 always 0 0                                    elsif @unit.@totalItems == 0 then
        label *label171                                              ...
  513:  set .MSG ", initializing\n"                                  MSG = ", initializing\n";
  514:  ucontrol approach .CORE_X .CORE_Y 6 0 0                      approach(CORE_X, CORE_Y, RADIUS_APPROACH);
  515:  ucontrol within .CORE_X .CORE_Y 8 *tmp237 0                  if within(CORE_X, CORE_Y, RADIUS_WITHIN) then
  516:  jump *label173 equal *tmp237 false                           ...
  517:  ucontrol itemDrop .CORE .UNIT_CAPACITY 0 0 0                 itemDrop(CORE, UNIT_CAPACITY);
        label *label173                                              if within(CORE_X, CORE_Y, RADIUS_WITHIN) then
        label *label172                                              elsif @unit.@totalItems == 0 then
        label *label170                                              if @unit.@firstItem == item then
        label *label167                                              if state < S_APPROACH_SRC or state > S_APPROACH_DST then
  518:  jump *label175 notEqual :processUnit.0:state 2               if state == S_APPROACH_SRC then
  519:  ucontrol within .CORE_X .CORE_Y 8 *tmp241 0                  if within(CORE_X, CORE_Y, RADIUS_WITHIN) then
  520:  jump *label177 equal *tmp241 false                           ...
  521:  ucontrol itemTake .CORE @silicon .UNIT_CAPACITY 0 0          itemTake(CORE, item, UNIT_CAPACITY);
  522:  sensor *tmp243 @unit @totalItems                             if @unit.@totalItems >= UNIT_CAPACITY then
  523:  jump *label179 lessThan *tmp243 .UNIT_CAPACITY               ...
  524:  ucontrol approach .DOME_X .DOME_Y 6 0 0                      approach(DOME_X, DOME_Y, RADIUS_APPROACH);
  525:  set :processUnit.0:state 3                                   state = S_APPROACH_DST;
  526:  jump *label178 always 0 0                                    if @unit.@totalItems >= UNIT_CAPACITY then
        label *label179                                              ...
  527:  set .MSG ", loading\n"                                       MSG = ", loading\n";
  528:  jump *label178 always 0 0                                    if within(CORE_X, CORE_Y, RADIUS_WITHIN) then
        label *label177                                              ...
  529:  ucontrol approach .CORE_X .CORE_Y 6 0 0                      approach(CORE_X, CORE_Y, RADIUS_APPROACH);
  530:  set .MSG ", fetching in [gold]"                              MSG = ", fetching in [gold]";
  531:  sensor *tmp246 @unit @x                                      distance = len(CORE_X - @unit.@x, CORE_Y - @unit.@y) \ SPEED_TENTHS / 10;
  532:  op sub *tmp247 .CORE_X *tmp246                               ...
  533:  sensor *tmp248 @unit @y                                      ...
  534:  op sub *tmp249 .CORE_Y *tmp248                               ...
  535:  op len *tmp250 *tmp247 *tmp249                               ...
  536:  op idiv *tmp251 *tmp250 .SPEED_TENTHS                        ...
  537:  op div :processUnit.0:distance *tmp251 10                    ...
        label *label178                                              if within(CORE_X, CORE_Y, RADIUS_WITHIN) then
        label *label175                                              if state == S_APPROACH_SRC then
  538:  jump *label181 notEqual :processUnit.0:state 3               if state == S_APPROACH_DST then
  539:  ucontrol within .DOME_X .DOME_Y 8 *tmp255 0                  if within(DOME_X, DOME_Y, RADIUS_WITHIN) then
  540:  jump *label183 equal *tmp255 false                           ...
  541:  jump *label185 equal .SUPPLY_S_FIRST false                   if supply then
  542:  ucontrol itemDrop .DOME .UNIT_CAPACITY 0 0 0                 itemDrop(DOME, UNIT_CAPACITY);
  543:  set .MSG ", supplying\n"                                     MSG = ", supplying\n";
  544:  jump *label186 always 0 0                                    if supply then
        label *label185                                              ...
  545:  ucontrol approach .DOME_X .DOME_Y 6 0 0                      approach(DOME_X, DOME_Y, RADIUS_APPROACH);   // Keep the unit active
  546:  set .MSG ", waiting\n"                                       MSG = ", waiting\n";
        label *label186                                              if supply then
  547:  sensor *tmp258 @unit @totalItems                             if @unit.@totalItems <= 0 then
  548:  jump *label184 greaterThan *tmp258 0                         ...
  549:  ucontrol approach .CORE_X .CORE_Y 6 0 0                      approach(CORE_X, CORE_Y, RADIUS_APPROACH);
  550:  set :processUnit.0:state 2                                   state = S_APPROACH_SRC;
  551:  jump *label184 always 0 0                                    if within(DOME_X, DOME_Y, RADIUS_WITHIN) then
        label *label183                                              ...
  552:  ucontrol approach .DOME_X .DOME_Y 6 0 0                      approach(DOME_X, DOME_Y, RADIUS_APPROACH);
  553:  set .MSG ", returning in [gold]"                             MSG = ", returning in [gold]";
  554:  sensor *tmp261 @unit @x                                      distance = len(DOME_X - @unit.@x, DOME_Y - @unit.@y) \ SPEED_TENTHS / 10;
  555:  op sub *tmp262 .DOME_X *tmp261                               ...
  556:  sensor *tmp263 @unit @y                                      ...
  557:  op sub *tmp264 .DOME_Y *tmp263                               ...
  558:  op len *tmp265 *tmp262 *tmp264                               ...
  559:  op idiv *tmp266 *tmp265 .SPEED_TENTHS                        ...
  560:  op div :processUnit.0:distance *tmp266 10                    ...
        label *label184                                              if within(DOME_X, DOME_Y, RADIUS_WITHIN) then
        label *label181                                              if state == S_APPROACH_DST then
  561:  ucontrol flag :processUnit.0:state 0 0 0 0                   flag(state);
  562:  sensor *tmp268 @unit @totalItems                             print($"  $group: [$color]$[]", @unit.@totalItems);
  563:  print "  "                                                   ...
  564:  print .GROUP1                                                ...
  565:  print ": [gold]"                                             ...
  566:  print *tmp268                                                ...
  567:  print "[]"                                                   ...
  568:  jump *label189 lessThan :processUnit.0:distance 0            if distance >= 0 then
  569:  print .MSG                                                   println($"$MSG$distance[] sec");
  570:  print :processUnit.0:distance                                ...
  571:  print "[] sec\n"                                             ...
  572:  jump *label190 always 0 0                                    if distance >= 0 then
        label *label189                                              ...
  573:  print .MSG                                                   print(MSG);
        label *label190                                              if distance >= 0 then
  574:  set :processUnit.0:unit @unit                                unit = @unit;
  575:  set .UNIT_S1 :processUnit.0:unit                             processUnit(out UNIT_S1, @silicon, GROUP1, SUPPLY_S_FIRST);
  576:  jump *label191 equal *tmp134 false                           if FOUR_UNITS then
  577:  op equal *tmp273 .SUPPLY_S_FIRST false                       processUnit(out UNIT_S2, @silicon, GROUP2, not SUPPLY_S_FIRST);
  578:  jump *label195 equal .UNIT_S2 null                           if currentUnit != null then
  579:  ubind .UNIT_S2                                               ubind(currentUnit);
  580:  sensor *tmp277 @unit @dead                                   if @unit.@dead === 0 && @unit.@controller == @this then
  581:  op strictEqual *tmp278 *tmp277 0                             ...
  582:  sensor *tmp279 @unit @controller                             ...
  583:  op equal *tmp280 *tmp279 @this                               ...
  584:  op land *tmp281 *tmp278 *tmp280                              ...
  585:  jump *label194 notEqual *tmp281 false                        ...
        label *label195                                              if currentUnit != null then
  586:  ubind *tmp9                                                  var firstUnit = ubind(TYPE);
  587:  set :rebindUnit.5:firstUnit @unit                            ...
  588:  jump __start__ equal :rebindUnit.5:firstUnit null            if firstUnit != null then
        label *label201                                              do
  589:  sensor *tmp285 @unit @controlled                             if @unit.@controlled == 0 then
  590:  jump *label194 equal *tmp285 0                               ...
  591:  ubind *tmp9                                                  ubind(TYPE);
  592:  op notEqual *tmp288 @unit :rebindUnit.5:firstUnit            while @unit != firstUnit and firstUnit.@dead == 0;
  593:  sensor *tmp289 :rebindUnit.5:firstUnit @dead                 ...
  594:  op equal *tmp290 *tmp289 0                                   ...
  595:  op land *tmp291 *tmp288 *tmp290                              ...
  596:  jump *label201 notEqual *tmp291 false                        do
  597:  end                                                          end();
        label *label194                                              rebindUnit(unit);
  598:  sensor :processUnit.1:state @unit @flag                      var state = @unit.@flag;
  599:  set :processUnit.1:distance -1                               var distance = -1;
  600:  op lessThan *tmp293 :processUnit.1:state 2                   if state < S_APPROACH_SRC or state > S_APPROACH_DST then
  601:  op greaterThan *tmp294 :processUnit.1:state 3                ...
  602:  op or *tmp295 *tmp293 *tmp294                                ...
  603:  jump *label206 equal *tmp295 false                           ...
  604:  sensor *tmp297 @unit @firstItem                              if @unit.@firstItem == item then
  605:  jump *label208 notEqual *tmp297 @silicon                     ...
  606:  set :processUnit.1:state 3                                   state = S_APPROACH_DST;
  607:  jump *label209 always 0 0                                    if @unit.@firstItem == item then
        label *label208                                              ...
  608:  sensor *tmp300 @unit @totalItems                             elsif @unit.@totalItems == 0 then
  609:  jump *label210 notEqual *tmp300 0                            ...
  610:  set :processUnit.1:state 2                                   state = S_APPROACH_SRC;
  611:  jump *label211 always 0 0                                    elsif @unit.@totalItems == 0 then
        label *label210                                              ...
  612:  set .MSG ", initializing\n"                                  MSG = ", initializing\n";
  613:  ucontrol approach .CORE_X .CORE_Y 6 0 0                      approach(CORE_X, CORE_Y, RADIUS_APPROACH);
  614:  ucontrol within .CORE_X .CORE_Y 8 *tmp303 0                  if within(CORE_X, CORE_Y, RADIUS_WITHIN) then
  615:  jump *label212 equal *tmp303 false                           ...
  616:  ucontrol itemDrop .CORE .UNIT_CAPACITY 0 0 0                 itemDrop(CORE, UNIT_CAPACITY);
        label *label212                                              if within(CORE_X, CORE_Y, RADIUS_WITHIN) then
        label *label211                                              elsif @unit.@totalItems == 0 then
        label *label209                                              if @unit.@firstItem == item then
        label *label206                                              if state < S_APPROACH_SRC or state > S_APPROACH_DST then
  617:  jump *label214 notEqual :processUnit.1:state 2               if state == S_APPROACH_SRC then
  618:  ucontrol within .CORE_X .CORE_Y 8 *tmp307 0                  if within(CORE_X, CORE_Y, RADIUS_WITHIN) then
  619:  jump *label216 equal *tmp307 false                           ...
  620:  ucontrol itemTake .CORE @silicon .UNIT_CAPACITY 0 0          itemTake(CORE, item, UNIT_CAPACITY);
  621:  sensor *tmp309 @unit @totalItems                             if @unit.@totalItems >= UNIT_CAPACITY then
  622:  jump *label218 lessThan *tmp309 .UNIT_CAPACITY               ...
  623:  ucontrol approach .DOME_X .DOME_Y 6 0 0                      approach(DOME_X, DOME_Y, RADIUS_APPROACH);
  624:  set :processUnit.1:state 3                                   state = S_APPROACH_DST;
  625:  jump *label217 always 0 0                                    if @unit.@totalItems >= UNIT_CAPACITY then
        label *label218                                              ...
  626:  set .MSG ", loading\n"                                       MSG = ", loading\n";
  627:  jump *label217 always 0 0                                    if within(CORE_X, CORE_Y, RADIUS_WITHIN) then
        label *label216                                              ...
  628:  ucontrol approach .CORE_X .CORE_Y 6 0 0                      approach(CORE_X, CORE_Y, RADIUS_APPROACH);
  629:  set .MSG ", fetching in [gold]"                              MSG = ", fetching in [gold]";
  630:  sensor *tmp312 @unit @x                                      distance = len(CORE_X - @unit.@x, CORE_Y - @unit.@y) \ SPEED_TENTHS / 10;
  631:  op sub *tmp313 .CORE_X *tmp312                               ...
  632:  sensor *tmp314 @unit @y                                      ...
  633:  op sub *tmp315 .CORE_Y *tmp314                               ...
  634:  op len *tmp316 *tmp313 *tmp315                               ...
  635:  op idiv *tmp317 *tmp316 .SPEED_TENTHS                        ...
  636:  op div :processUnit.1:distance *tmp317 10                    ...
        label *label217                                              if within(CORE_X, CORE_Y, RADIUS_WITHIN) then
        label *label214                                              if state == S_APPROACH_SRC then
  637:  jump *label220 notEqual :processUnit.1:state 3               if state == S_APPROACH_DST then
  638:  ucontrol within .DOME_X .DOME_Y 8 *tmp321 0                  if within(DOME_X, DOME_Y, RADIUS_WITHIN) then
  639:  jump *label222 equal *tmp321 false                           ...
  640:  jump *label224 equal *tmp273 false                           if supply then
  641:  ucontrol itemDrop .DOME .UNIT_CAPACITY 0 0 0                 itemDrop(DOME, UNIT_CAPACITY);
  642:  set .MSG ", supplying\n"                                     MSG = ", supplying\n";
  643:  jump *label225 always 0 0                                    if supply then
        label *label224                                              ...
  644:  ucontrol approach .DOME_X .DOME_Y 6 0 0                      approach(DOME_X, DOME_Y, RADIUS_APPROACH);   // Keep the unit active
  645:  set .MSG ", waiting\n"                                       MSG = ", waiting\n";
        label *label225                                              if supply then
  646:  sensor *tmp324 @unit @totalItems                             if @unit.@totalItems <= 0 then
  647:  jump *label223 greaterThan *tmp324 0                         ...
  648:  ucontrol approach .CORE_X .CORE_Y 6 0 0                      approach(CORE_X, CORE_Y, RADIUS_APPROACH);
  649:  set :processUnit.1:state 2                                   state = S_APPROACH_SRC;
  650:  jump *label223 always 0 0                                    if within(DOME_X, DOME_Y, RADIUS_WITHIN) then
        label *label222                                              ...
  651:  ucontrol approach .DOME_X .DOME_Y 6 0 0                      approach(DOME_X, DOME_Y, RADIUS_APPROACH);
  652:  set .MSG ", returning in [gold]"                             MSG = ", returning in [gold]";
  653:  sensor *tmp327 @unit @x                                      distance = len(DOME_X - @unit.@x, DOME_Y - @unit.@y) \ SPEED_TENTHS / 10;
  654:  op sub *tmp328 .DOME_X *tmp327                               ...
  655:  sensor *tmp329 @unit @y                                      ...
  656:  op sub *tmp330 .DOME_Y *tmp329                               ...
  657:  op len *tmp331 *tmp328 *tmp330                               ...
  658:  op idiv *tmp332 *tmp331 .SPEED_TENTHS                        ...
  659:  op div :processUnit.1:distance *tmp332 10                    ...
        label *label223                                              if within(DOME_X, DOME_Y, RADIUS_WITHIN) then
        label *label220                                              if state == S_APPROACH_DST then
  660:  ucontrol flag :processUnit.1:state 0 0 0 0                   flag(state);
  661:  sensor *tmp334 @unit @totalItems                             print($"  $group: [$color]$[]", @unit.@totalItems);
  662:  print "  "                                                   ...
  663:  print .GROUP2                                                ...
  664:  print ": [gold]"                                             ...
  665:  print *tmp334                                                ...
  666:  print "[]"                                                   ...
  667:  jump *label228 lessThan :processUnit.1:distance 0            if distance >= 0 then
  668:  print .MSG                                                   println($"$MSG$distance[] sec");
  669:  print :processUnit.1:distance                                ...
  670:  print "[] sec\n"                                             ...
  671:  jump *label229 always 0 0                                    if distance >= 0 then
        label *label228                                              ...
  672:  print .MSG                                                   print(MSG);
        label *label229                                              if distance >= 0 then
  673:  set :processUnit.1:unit @unit                                unit = @unit;
  674:  set .UNIT_S2 :processUnit.1:unit                             processUnit(out UNIT_S2, @silicon, GROUP2, not SUPPLY_S_FIRST);
  675:  jump *label230 equal .SUPPLY_S_FIRST false                   SUPPLY_S_FIRST = SUPPLY_S_FIRST ? UNIT_S1.@totalItems > 0 : UNIT_S2.@totalItems == 0;
  676:  sensor *tmp339 :processUnit.0:unit @totalItems               ...
  677:  op greaterThan .SUPPLY_S_FIRST *tmp339 0                     ...
  678:  jump *label231 always 0 0                                    ...
        label *label230                                              ...
  679:  sensor *tmp341 :processUnit.1:unit @totalItems               ...
  680:  op equal .SUPPLY_S_FIRST *tmp341 0                           ...
        label *label231                                              ...
        label *label191                                              if FOUR_UNITS then
  681:  print "\n[green]Phase fabric[] status:\n"                    print(text);
  682:  sensor :printDomeStatus.1:level .DOME @phase-fabric          var level = DOME.sensor(item);
  683:  jump *label233 lessThanEq :printDomeStatus.1:level 3         if level > 3 then
  684:  print "  dome:  [green]"                                     println($"  dome:  [green]$level[]");
  685:  print :printDomeStatus.1:level                               ...
  686:  print "[]\n"                                                 ...
  687:  jump *label234 always 0 0                                    if level > 3 then
        label *label233                                              ...
  688:  print "  dome:  [coral]"                                     println($"  dome:  [coral]$level[]");
  689:  print :printDomeStatus.1:level                               ...
  690:  print "[]\n"                                                 ...
        label *label234                                              if level > 3 then
  691:  jump *label237 equal .UNIT_P1 null                           if currentUnit != null then
  692:  ubind .UNIT_P1                                               ubind(currentUnit);
  693:  sensor *tmp349 @unit @dead                                   if @unit.@dead === 0 && @unit.@controller == @this then
  694:  op strictEqual *tmp350 *tmp349 0                             ...
  695:  sensor *tmp351 @unit @controller                             ...
  696:  op equal *tmp352 *tmp351 @this                               ...
  697:  op land *tmp353 *tmp350 *tmp352                              ...
  698:  jump *label236 notEqual *tmp353 false                        ...
        label *label237                                              if currentUnit != null then
  699:  ubind *tmp9                                                  var firstUnit = ubind(TYPE);
  700:  set :rebindUnit.6:firstUnit @unit                            ...
  701:  jump __start__ equal :rebindUnit.6:firstUnit null            if firstUnit != null then
        label *label243                                              do
  702:  sensor *tmp357 @unit @controlled                             if @unit.@controlled == 0 then
  703:  jump *label236 equal *tmp357 0                               ...
  704:  ubind *tmp9                                                  ubind(TYPE);
  705:  op notEqual *tmp360 @unit :rebindUnit.6:firstUnit            while @unit != firstUnit and firstUnit.@dead == 0;
  706:  sensor *tmp361 :rebindUnit.6:firstUnit @dead                 ...
  707:  op equal *tmp362 *tmp361 0                                   ...
  708:  op land *tmp363 *tmp360 *tmp362                              ...
  709:  jump *label243 notEqual *tmp363 false                        do
  710:  end                                                          end();
        label *label236                                              rebindUnit(unit);
  711:  sensor :processUnit.2:state @unit @flag                      var state = @unit.@flag;
  712:  set :processUnit.2:distance -1                               var distance = -1;
  713:  op lessThan *tmp365 :processUnit.2:state 2                   if state < S_APPROACH_SRC or state > S_APPROACH_DST then
  714:  op greaterThan *tmp366 :processUnit.2:state 3                ...
  715:  op or *tmp367 *tmp365 *tmp366                                ...
  716:  jump *label248 equal *tmp367 false                           ...
  717:  sensor *tmp369 @unit @firstItem                              if @unit.@firstItem == item then
  718:  jump *label250 notEqual *tmp369 @phase-fabric                ...
  719:  set :processUnit.2:state 3                                   state = S_APPROACH_DST;
  720:  jump *label251 always 0 0                                    if @unit.@firstItem == item then
        label *label250                                              ...
  721:  sensor *tmp372 @unit @totalItems                             elsif @unit.@totalItems == 0 then
  722:  jump *label252 notEqual *tmp372 0                            ...
  723:  set :processUnit.2:state 2                                   state = S_APPROACH_SRC;
  724:  jump *label253 always 0 0                                    elsif @unit.@totalItems == 0 then
        label *label252                                              ...
  725:  set .MSG ", initializing\n"                                  MSG = ", initializing\n";
  726:  ucontrol approach .CORE_X .CORE_Y 6 0 0                      approach(CORE_X, CORE_Y, RADIUS_APPROACH);
  727:  ucontrol within .CORE_X .CORE_Y 8 *tmp375 0                  if within(CORE_X, CORE_Y, RADIUS_WITHIN) then
  728:  jump *label254 equal *tmp375 false                           ...
  729:  ucontrol itemDrop .CORE .UNIT_CAPACITY 0 0 0                 itemDrop(CORE, UNIT_CAPACITY);
        label *label254                                              if within(CORE_X, CORE_Y, RADIUS_WITHIN) then
        label *label253                                              elsif @unit.@totalItems == 0 then
        label *label251                                              if @unit.@firstItem == item then
        label *label248                                              if state < S_APPROACH_SRC or state > S_APPROACH_DST then
  730:  jump *label256 notEqual :processUnit.2:state 2               if state == S_APPROACH_SRC then
  731:  ucontrol within .CORE_X .CORE_Y 8 *tmp379 0                  if within(CORE_X, CORE_Y, RADIUS_WITHIN) then
  732:  jump *label258 equal *tmp379 false                           ...
  733:  ucontrol itemTake .CORE @phase-fabric .UNIT_CAPACITY 0 0     itemTake(CORE, item, UNIT_CAPACITY);
  734:  sensor *tmp381 @unit @totalItems                             if @unit.@totalItems >= UNIT_CAPACITY then
  735:  jump *label260 lessThan *tmp381 .UNIT_CAPACITY               ...
  736:  ucontrol approach .DOME_X .DOME_Y 6 0 0                      approach(DOME_X, DOME_Y, RADIUS_APPROACH);
  737:  set :processUnit.2:state 3                                   state = S_APPROACH_DST;
  738:  jump *label259 always 0 0                                    if @unit.@totalItems >= UNIT_CAPACITY then
        label *label260                                              ...
  739:  set .MSG ", loading\n"                                       MSG = ", loading\n";
  740:  jump *label259 always 0 0                                    if within(CORE_X, CORE_Y, RADIUS_WITHIN) then
        label *label258                                              ...
  741:  ucontrol approach .CORE_X .CORE_Y 6 0 0                      approach(CORE_X, CORE_Y, RADIUS_APPROACH);
  742:  set .MSG ", fetching in [gold]"                              MSG = ", fetching in [gold]";
  743:  sensor *tmp384 @unit @x                                      distance = len(CORE_X - @unit.@x, CORE_Y - @unit.@y) \ SPEED_TENTHS / 10;
  744:  op sub *tmp385 .CORE_X *tmp384                               ...
  745:  sensor *tmp386 @unit @y                                      ...
  746:  op sub *tmp387 .CORE_Y *tmp386                               ...
  747:  op len *tmp388 *tmp385 *tmp387                               ...
  748:  op idiv *tmp389 *tmp388 .SPEED_TENTHS                        ...
  749:  op div :processUnit.2:distance *tmp389 10                    ...
        label *label259                                              if within(CORE_X, CORE_Y, RADIUS_WITHIN) then
        label *label256                                              if state == S_APPROACH_SRC then
  750:  jump *label262 notEqual :processUnit.2:state 3               if state == S_APPROACH_DST then
  751:  ucontrol within .DOME_X .DOME_Y 8 *tmp393 0                  if within(DOME_X, DOME_Y, RADIUS_WITHIN) then
  752:  jump *label264 equal *tmp393 false                           ...
  753:  jump *label266 equal .SUPPLY_P_FIRST false                   if supply then
  754:  ucontrol itemDrop .DOME .UNIT_CAPACITY 0 0 0                 itemDrop(DOME, UNIT_CAPACITY);
  755:  set .MSG ", supplying\n"                                     MSG = ", supplying\n";
  756:  jump *label267 always 0 0                                    if supply then
        label *label266                                              ...
  757:  ucontrol approach .DOME_X .DOME_Y 6 0 0                      approach(DOME_X, DOME_Y, RADIUS_APPROACH);   // Keep the unit active
  758:  set .MSG ", waiting\n"                                       MSG = ", waiting\n";
        label *label267                                              if supply then
  759:  sensor *tmp396 @unit @totalItems                             if @unit.@totalItems <= 0 then
  760:  jump *label265 greaterThan *tmp396 0                         ...
  761:  ucontrol approach .CORE_X .CORE_Y 6 0 0                      approach(CORE_X, CORE_Y, RADIUS_APPROACH);
  762:  set :processUnit.2:state 2                                   state = S_APPROACH_SRC;
  763:  jump *label265 always 0 0                                    if within(DOME_X, DOME_Y, RADIUS_WITHIN) then
        label *label264                                              ...
  764:  ucontrol approach .DOME_X .DOME_Y 6 0 0                      approach(DOME_X, DOME_Y, RADIUS_APPROACH);
  765:  set .MSG ", returning in [gold]"                             MSG = ", returning in [gold]";
  766:  sensor *tmp399 @unit @x                                      distance = len(DOME_X - @unit.@x, DOME_Y - @unit.@y) \ SPEED_TENTHS / 10;
  767:  op sub *tmp400 .DOME_X *tmp399                               ...
  768:  sensor *tmp401 @unit @y                                      ...
  769:  op sub *tmp402 .DOME_Y *tmp401                               ...
  770:  op len *tmp403 *tmp400 *tmp402                               ...
  771:  op idiv *tmp404 *tmp403 .SPEED_TENTHS                        ...
  772:  op div :processUnit.2:distance *tmp404 10                    ...
        label *label265                                              if within(DOME_X, DOME_Y, RADIUS_WITHIN) then
        label *label262                                              if state == S_APPROACH_DST then
  773:  ucontrol flag :processUnit.2:state 0 0 0 0                   flag(state);
  774:  sensor *tmp406 @unit @totalItems                             print($"  $group: [$color]$[]", @unit.@totalItems);
  775:  print "  "                                                   ...
  776:  print .GROUP1                                                ...
  777:  print ": [gold]"                                             ...
  778:  print *tmp406                                                ...
  779:  print "[]"                                                   ...
  780:  jump *label270 lessThan :processUnit.2:distance 0            if distance >= 0 then
  781:  print .MSG                                                   println($"$MSG$distance[] sec");
  782:  print :processUnit.2:distance                                ...
  783:  print "[] sec\n"                                             ...
  784:  jump *label271 always 0 0                                    if distance >= 0 then
        label *label270                                              ...
  785:  print .MSG                                                   print(MSG);
        label *label271                                              if distance >= 0 then
  786:  set :processUnit.2:unit @unit                                unit = @unit;
  787:  set .UNIT_P1 :processUnit.2:unit                             processUnit(out UNIT_P1, @phase-fabric, GROUP1, SUPPLY_P_FIRST);
  788:  jump *label272 equal *tmp134 false                           if FOUR_UNITS then
  789:  op equal *tmp411 .SUPPLY_P_FIRST false                       processUnit(out UNIT_P2, @phase-fabric, GROUP2, not SUPPLY_P_FIRST);
  790:  jump *label276 equal .UNIT_P2 null                           if currentUnit != null then
  791:  ubind .UNIT_P2                                               ubind(currentUnit);
  792:  sensor *tmp415 @unit @dead                                   if @unit.@dead === 0 && @unit.@controller == @this then
  793:  op strictEqual *tmp416 *tmp415 0                             ...
  794:  sensor *tmp417 @unit @controller                             ...
  795:  op equal *tmp418 *tmp417 @this                               ...
  796:  op land *tmp419 *tmp416 *tmp418                              ...
  797:  jump *label275 notEqual *tmp419 false                        ...
        label *label276                                              if currentUnit != null then
  798:  ubind *tmp9                                                  var firstUnit = ubind(TYPE);
  799:  set :rebindUnit.7:firstUnit @unit                            ...
  800:  jump __start__ equal :rebindUnit.7:firstUnit null            if firstUnit != null then
        label *label282                                              do
  801:  sensor *tmp423 @unit @controlled                             if @unit.@controlled == 0 then
  802:  jump *label275 equal *tmp423 0                               ...
  803:  ubind *tmp9                                                  ubind(TYPE);
  804:  op notEqual *tmp426 @unit :rebindUnit.7:firstUnit            while @unit != firstUnit and firstUnit.@dead == 0;
  805:  sensor *tmp427 :rebindUnit.7:firstUnit @dead                 ...
  806:  op equal *tmp428 *tmp427 0                                   ...
  807:  op land *tmp429 *tmp426 *tmp428                              ...
  808:  jump *label282 notEqual *tmp429 false                        do
  809:  end                                                          end();
        label *label275                                              rebindUnit(unit);
  810:  sensor :processUnit.3:state @unit @flag                      var state = @unit.@flag;
  811:  set :processUnit.3:distance -1                               var distance = -1;
  812:  op lessThan *tmp431 :processUnit.3:state 2                   if state < S_APPROACH_SRC or state > S_APPROACH_DST then
  813:  op greaterThan *tmp432 :processUnit.3:state 3                ...
  814:  op or *tmp433 *tmp431 *tmp432                                ...
  815:  jump *label287 equal *tmp433 false                           ...
  816:  sensor *tmp435 @unit @firstItem                              if @unit.@firstItem == item then
  817:  jump *label289 notEqual *tmp435 @phase-fabric                ...
  818:  set :processUnit.3:state 3                                   state = S_APPROACH_DST;
  819:  jump *label290 always 0 0                                    if @unit.@firstItem == item then
        label *label289                                              ...
  820:  sensor *tmp438 @unit @totalItems                             elsif @unit.@totalItems == 0 then
  821:  jump *label291 notEqual *tmp438 0                            ...
  822:  set :processUnit.3:state 2                                   state = S_APPROACH_SRC;
  823:  jump *label292 always 0 0                                    elsif @unit.@totalItems == 0 then
        label *label291                                              ...
  824:  set .MSG ", initializing\n"                                  MSG = ", initializing\n";
  825:  ucontrol approach .CORE_X .CORE_Y 6 0 0                      approach(CORE_X, CORE_Y, RADIUS_APPROACH);
  826:  ucontrol within .CORE_X .CORE_Y 8 *tmp441 0                  if within(CORE_X, CORE_Y, RADIUS_WITHIN) then
  827:  jump *label293 equal *tmp441 false                           ...
  828:  ucontrol itemDrop .CORE .UNIT_CAPACITY 0 0 0                 itemDrop(CORE, UNIT_CAPACITY);
        label *label293                                              if within(CORE_X, CORE_Y, RADIUS_WITHIN) then
        label *label292                                              elsif @unit.@totalItems == 0 then
        label *label290                                              if @unit.@firstItem == item then
        label *label287                                              if state < S_APPROACH_SRC or state > S_APPROACH_DST then
  829:  jump *label295 notEqual :processUnit.3:state 2               if state == S_APPROACH_SRC then
  830:  ucontrol within .CORE_X .CORE_Y 8 *tmp445 0                  if within(CORE_X, CORE_Y, RADIUS_WITHIN) then
  831:  jump *label297 equal *tmp445 false                           ...
  832:  ucontrol itemTake .CORE @phase-fabric .UNIT_CAPACITY 0 0     itemTake(CORE, item, UNIT_CAPACITY);
  833:  sensor *tmp447 @unit @totalItems                             if @unit.@totalItems >= UNIT_CAPACITY then
  834:  jump *label299 lessThan *tmp447 .UNIT_CAPACITY               ...
  835:  ucontrol approach .DOME_X .DOME_Y 6 0 0                      approach(DOME_X, DOME_Y, RADIUS_APPROACH);
  836:  set :processUnit.3:state 3                                   state = S_APPROACH_DST;
  837:  jump *label298 always 0 0                                    if @unit.@totalItems >= UNIT_CAPACITY then
        label *label299                                              ...
  838:  set .MSG ", loading\n"                                       MSG = ", loading\n";
  839:  jump *label298 always 0 0                                    if within(CORE_X, CORE_Y, RADIUS_WITHIN) then
        label *label297                                              ...
  840:  ucontrol approach .CORE_X .CORE_Y 6 0 0                      approach(CORE_X, CORE_Y, RADIUS_APPROACH);
  841:  set .MSG ", fetching in [gold]"                              MSG = ", fetching in [gold]";
  842:  sensor *tmp450 @unit @x                                      distance = len(CORE_X - @unit.@x, CORE_Y - @unit.@y) \ SPEED_TENTHS / 10;
  843:  op sub *tmp451 .CORE_X *tmp450                               ...
  844:  sensor *tmp452 @unit @y                                      ...
  845:  op sub *tmp453 .CORE_Y *tmp452                               ...
  846:  op len *tmp454 *tmp451 *tmp453                               ...
  847:  op idiv *tmp455 *tmp454 .SPEED_TENTHS                        ...
  848:  op div :processUnit.3:distance *tmp455 10                    ...
        label *label298                                              if within(CORE_X, CORE_Y, RADIUS_WITHIN) then
        label *label295                                              if state == S_APPROACH_SRC then
  849:  jump *label301 notEqual :processUnit.3:state 3               if state == S_APPROACH_DST then
  850:  ucontrol within .DOME_X .DOME_Y 8 *tmp459 0                  if within(DOME_X, DOME_Y, RADIUS_WITHIN) then
  851:  jump *label303 equal *tmp459 false                           ...
  852:  jump *label305 equal *tmp411 false                           if supply then
  853:  ucontrol itemDrop .DOME .UNIT_CAPACITY 0 0 0                 itemDrop(DOME, UNIT_CAPACITY);
  854:  set .MSG ", supplying\n"                                     MSG = ", supplying\n";
  855:  jump *label306 always 0 0                                    if supply then
        label *label305                                              ...
  856:  ucontrol approach .DOME_X .DOME_Y 6 0 0                      approach(DOME_X, DOME_Y, RADIUS_APPROACH);   // Keep the unit active
  857:  set .MSG ", waiting\n"                                       MSG = ", waiting\n";
        label *label306                                              if supply then
  858:  sensor *tmp462 @unit @totalItems                             if @unit.@totalItems <= 0 then
  859:  jump *label304 greaterThan *tmp462 0                         ...
  860:  ucontrol approach .CORE_X .CORE_Y 6 0 0                      approach(CORE_X, CORE_Y, RADIUS_APPROACH);
  861:  set :processUnit.3:state 2                                   state = S_APPROACH_SRC;
  862:  jump *label304 always 0 0                                    if within(DOME_X, DOME_Y, RADIUS_WITHIN) then
        label *label303                                              ...
  863:  ucontrol approach .DOME_X .DOME_Y 6 0 0                      approach(DOME_X, DOME_Y, RADIUS_APPROACH);
  864:  set .MSG ", returning in [gold]"                             MSG = ", returning in [gold]";
  865:  sensor *tmp465 @unit @x                                      distance = len(DOME_X - @unit.@x, DOME_Y - @unit.@y) \ SPEED_TENTHS / 10;
  866:  op sub *tmp466 .DOME_X *tmp465                               ...
  867:  sensor *tmp467 @unit @y                                      ...
  868:  op sub *tmp468 .DOME_Y *tmp467                               ...
  869:  op len *tmp469 *tmp466 *tmp468                               ...
  870:  op idiv *tmp470 *tmp469 .SPEED_TENTHS                        ...
  871:  op div :processUnit.3:distance *tmp470 10                    ...
        label *label304                                              if within(DOME_X, DOME_Y, RADIUS_WITHIN) then
        label *label301                                              if state == S_APPROACH_DST then
  872:  ucontrol flag :processUnit.3:state 0 0 0 0                   flag(state);
  873:  sensor *tmp472 @unit @totalItems                             print($"  $group: [$color]$[]", @unit.@totalItems);
  874:  print "  "                                                   ...
  875:  print .GROUP2                                                ...
  876:  print ": [gold]"                                             ...
  877:  print *tmp472                                                ...
  878:  print "[]"                                                   ...
  879:  jump *label309 lessThan :processUnit.3:distance 0            if distance >= 0 then
  880:  print .MSG                                                   println($"$MSG$distance[] sec");
  881:  print :processUnit.3:distance                                ...
  882:  print "[] sec\n"                                             ...
  883:  jump *label310 always 0 0                                    if distance >= 0 then
        label *label309                                              ...
  884:  print .MSG                                                   print(MSG);
        label *label310                                              if distance >= 0 then
  885:  set :processUnit.3:unit @unit                                unit = @unit;
  886:  set .UNIT_P2 :processUnit.3:unit                             processUnit(out UNIT_P2, @phase-fabric, GROUP2, not SUPPLY_P_FIRST);
  887:  jump *label311 equal .SUPPLY_P_FIRST false                   SUPPLY_P_FIRST = SUPPLY_P_FIRST ? UNIT_P1.@totalItems > 0 : UNIT_P2.@totalItems == 0;
  888:  sensor *tmp477 :processUnit.2:unit @totalItems               ...
  889:  op greaterThan .SUPPLY_P_FIRST *tmp477 0                     ...
  890:  jump *label312 always 0 0                                    ...
        label *label311                                              ...
  891:  sensor *tmp479 :processUnit.3:unit @totalItems               ...
  892:  op equal .SUPPLY_P_FIRST *tmp479 0                           ...
        label *label312                                              ...
        label *label272                                              if FOUR_UNITS then
  893:  op sub *tmp481 @time :start                                  print($"\n[lightgray]Loop time: $ ms", floor(@time - start));
  894:  op floor *tmp482 *tmp481 0                                   ...
  895:  print "\n[lightgray]Loop time: "                             ...
  896:  print *tmp482                                                ...
  897:  print " ms"                                                  ...
  898:  printflush message1                                          printflush(message1);
  899:  op notEqual *tmp483 *tmp9 UNIT_TYPE                          if TYPE != UNIT_TYPE and unitCheck > @time then
  900:  op greaterThan *tmp484 :unitCheck @time                      ...
  901:  op land *tmp485 *tmp483 *tmp484                              ...
  902:  jump *label313 equal *tmp485 false                           ...
  903:  set :areUnitsAvailable.2:free 0                              var free = 0, occupied = 0, needed = 0;
  904:  set :areUnitsAvailable.2:occupied 0                          ...
  905:  ubind UNIT_TYPE                                              var firstUnit = ubind(type);
  906:  set :areUnitsAvailable.2:firstUnit @unit                     ...
  907:  jump *label328 equal :areUnitsAvailable.2:firstUnit null     if firstUnit != null then
  908:  set *tmp498 2                                                needed = needsFourUnits(@unit) ? 4 : 2;
  909:  set :needsFourUnits.3:unit @unit                             ...
  910:  sensor *tmp495 :needsFourUnits.3:unit @speed                 var travel_time = 2 * len(DOME_X - CORE_X, DOME_Y - CORE_Y) / unit.@speed;
  911:  op div :needsFourUnits.3:travel_time *tmp138 *tmp495         ...
  912:  jump *label320 lessThan :needsFourUnits.3:travel_time 47     needed = needsFourUnits(@unit) ? 4 : 2;
  913:  set *tmp498 4                                                ...
        label *label320                                              ...
        label *label321                                              do
  914:  sensor *tmp499 @unit @controlled                             if @unit.@controlled == 0 or @unit.@controller == @this then
  915:  op equal *tmp500 *tmp499 0                                   ...
  916:  sensor *tmp501 @unit @controller                             ...
  917:  op equal *tmp502 *tmp501 @this                               ...
  918:  op or *tmp503 *tmp500 *tmp502                                ...
  919:  jump *label324 equal *tmp503 false                           ...
  920:  op add :areUnitsAvailable.2:free :areUnitsAvailable.2:free 1 if ++free >= needed then
  921:  jump *label325 lessThan :areUnitsAvailable.2:free *tmp498    ...
  922:  set *tmp487 true                                             return true;
  923:  jump *label315 always 0 0                                    ...
        label *label324                                              if @unit.@controlled == 0 or @unit.@controller == @this then
  924:  op add :areUnitsAvailable.2:occupied :areUnitsAvailable.2:oc ...
        label *label325                                              ...
  925:  ubind UNIT_TYPE                                              ubind(type);
  926:  op notEqual *tmp508 @unit :areUnitsAvailable.2:firstUnit     while @unit != firstUnit and firstUnit.@dead == 0;
  927:  sensor *tmp509 :areUnitsAvailable.2:firstUnit @dead          ...
  928:  op equal *tmp510 *tmp509 0                                   ...
  929:  op land *tmp511 *tmp508 *tmp510                              ...
  930:  jump *label321 notEqual *tmp511 false                        do
        label *label328                                              if output then
  931:  set *tmp487 false                                            return false;
        label *label315                                              if areUnitsAvailable(UNIT_TYPE, false) then
  932:  jump *label332 equal *tmp487 false                           ...
  933:  end                                                          end();
        label *label332                                              if areUnitsAvailable(UNIT_TYPE, false) then
  934:  op add :unitCheck @time 5000                                 unitCheck = @time + UNIT_CHECK_TIME;
        label *label313                                              if TYPE != UNIT_TYPE and unitCheck > @time then
  935:  sensor *tmp204 switch1 @enabled                              while switch1.@enabled do
  936:  jump *label368 notEqual *tmp204 false                        ...
  937:  end
        label *label0                                                noinline def locateCore(type)
  938:  ubind :locateCore.0:type                                     ubind(type);
  939:  sensor *tmp517 @unit @controlled                             if @unit.@controlled == 0 or @unit.@controller == @this then
  940:  op equal *tmp518 *tmp517 0                                   ...
  941:  sensor *tmp519 @unit @controller                             ...
  942:  op equal *tmp520 *tmp519 @this                               ...
  943:  op or *tmp521 *tmp518 *tmp520                                ...
  944:  jump *label335 equal *tmp521 false                           ...
  945:  ulocate building core false @copper 0 0 0 .CORE              CORE = ulocate(:building, :core, false);
        label *label335                                              if @unit.@controlled == 0 or @unit.@controller == @this then
  946:  set :locateCore.0*retval .CORE                               noinline def locateCore(type)
  947:  return :locateCore.0*retaddr                                 ...


Performance: parsed in 250 ms, compiled in 185 ms, optimized in 1,532 ms, run in 36 ms.
Error connecting to Mlog Watcher: Connection refused: connect
  - make sure Mindustry with active Mlog Watcher mod is running
  - verify Mlog Watcher listens on port 9992

Program output (100,000 steps):
[gold]Waiting for an overdrive dome to be connected...
[--- Previous segment repeated 24 998,00 times ---]

Execution step limit of 100 000 exceeded.
