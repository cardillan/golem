jump 3 always 0 0
print "This is the preferred unit type to use for bringing in supplies."
print "If no units of this type exist, we'll try using other types."
set UNIT_TYPE @flare
jump 6 always 0 0
print "Do not modify anything below this line."
set .DOME dome1
jump 12 notEqual dome1 null
print "[gold]Waiting for an overdrive dome to be connected..."
printflush message1
set .DOME dome1
jump 8 equal dome1 null
print "[gold]Locating core..."
printflush message1
set .CORE null
set :locateCore:type @flare
set :locateCore*retaddr 18
jump 877 always 0 0
jump 31 notEqual :locateCore*retval false
set :locateCore:type @poly
set :locateCore*retaddr 22
jump 877 always 0 0
jump 31 notEqual :locateCore*retval false
set :locateCore:type @mega
set :locateCore*retaddr 26
jump 877 always 0 0
jump 31 notEqual :locateCore*retval false
set :locateCore:type @mono
set :locateCore*retaddr 30
jump 877 always 0 0
jump 15 equal :locateCore*retval false
sensor .CORE_X .CORE @x
sensor .CORE_Y .CORE @y
sensor .DOME_X .DOME @x
sensor .DOME_Y .DOME @y
sensor *tmp7 switch1 @enabled
jump 41 notEqual *tmp7 false
print "[coral]Activate switch to begin supplying overdrive dome...\n"
printflush message1
sensor *tmp7 switch1 @enabled
jump 37 equal *tmp7 false
printflush null
print "[gold]Looking for suitable unit type:[]\n"
set :areUnitsAvailable:free 0
set :areUnitsAvailable:occupied 0
set :areUnitsAvailable:needed 0
ubind UNIT_TYPE
set :areUnitsAvailable:firstUnit @unit
jump 73 equal :areUnitsAvailable:firstUnit null
set *tmp21 2
set :needsFourUnits:unit @unit
op sub *tmp14 .DOME_X .CORE_X
op sub *tmp15 .DOME_Y .CORE_Y
op len *tmp16 *tmp14 *tmp15
op mul *tmp17 2 *tmp16
sensor *tmp18 :needsFourUnits:unit @speed
op div :needsFourUnits:travel_time *tmp17 *tmp18
jump 59 lessThan :needsFourUnits:travel_time 47
set *tmp21 4
set :areUnitsAvailable:needed *tmp21
sensor *tmp22 @unit @controlled
jump 64 equal *tmp22 0
sensor *tmp24 @unit @controller
jump 68 notEqual *tmp24 @this
op add :areUnitsAvailable:free :areUnitsAvailable:free 1
jump 69 lessThan :areUnitsAvailable:free *tmp21
set *tmp10 true
jump 83 always 0 0
op add :areUnitsAvailable:occupied :areUnitsAvailable:occupied 1
ubind UNIT_TYPE
jump 73 equal @unit :areUnitsAvailable:firstUnit
sensor *tmp31 :areUnitsAvailable:firstUnit @dead
jump 60 equal *tmp31 0
print UNIT_TYPE
print ": occupied: "
print :areUnitsAvailable:occupied
print ", free: "
print :areUnitsAvailable:free
jump 81 lessThanEq :areUnitsAvailable:needed 0
print ", needed: "
print :areUnitsAvailable:needed
print "\n"
set *tmp10 false
jump 86 equal *tmp10 false
set *tmp9 UNIT_TYPE
jump 264 always 0 0
jump 130 equal @flare UNIT_TYPE
set :areUnitsAvailable.1:free 0
set :areUnitsAvailable.1:occupied 0
set :areUnitsAvailable.1:needed 0
ubind @flare
set :areUnitsAvailable.1:firstUnit @unit
jump 117 equal :areUnitsAvailable.1:firstUnit null
set *tmp51 2
set :needsFourUnits.1:unit @unit
op sub *tmp44 .DOME_X .CORE_X
op sub *tmp45 .DOME_Y .CORE_Y
op len *tmp46 *tmp44 *tmp45
op mul *tmp47 2 *tmp46
sensor *tmp48 :needsFourUnits.1:unit @speed
op div :needsFourUnits.1:travel_time *tmp47 *tmp48
jump 103 lessThan :needsFourUnits.1:travel_time 47
set *tmp51 4
set :areUnitsAvailable.1:needed *tmp51
sensor *tmp52 @unit @controlled
jump 108 equal *tmp52 0
sensor *tmp54 @unit @controller
jump 112 notEqual *tmp54 @this
op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
jump 113 lessThan :areUnitsAvailable.1:free *tmp51
set *tmp40 true
jump 126 always 0 0
op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
ubind @flare
jump 117 equal @unit :areUnitsAvailable.1:firstUnit
sensor *tmp61 :areUnitsAvailable.1:firstUnit @dead
jump 104 equal *tmp61 0
print "flare: occupied: "
print :areUnitsAvailable.1:occupied
print ", free: "
print :areUnitsAvailable.1:free
jump 124 lessThanEq :areUnitsAvailable.1:needed 0
print ", needed: "
print :areUnitsAvailable.1:needed
print "\n"
set *tmp40 false
jump 130 equal *tmp40 false
printflush null
set *tmp9 @flare
jump 264 always 0 0
jump 174 equal @poly UNIT_TYPE
set :areUnitsAvailable.1:free 0
set :areUnitsAvailable.1:occupied 0
set :areUnitsAvailable.1:needed 0
ubind @poly
set :areUnitsAvailable.1:firstUnit @unit
jump 161 equal :areUnitsAvailable.1:firstUnit null
set *tmp51 2
set :needsFourUnits.1:unit @unit
op sub *tmp44 .DOME_X .CORE_X
op sub *tmp45 .DOME_Y .CORE_Y
op len *tmp46 *tmp44 *tmp45
op mul *tmp47 2 *tmp46
sensor *tmp48 :needsFourUnits.1:unit @speed
op div :needsFourUnits.1:travel_time *tmp47 *tmp48
jump 147 lessThan :needsFourUnits.1:travel_time 47
set *tmp51 4
set :areUnitsAvailable.1:needed *tmp51
sensor *tmp52 @unit @controlled
jump 152 equal *tmp52 0
sensor *tmp54 @unit @controller
jump 156 notEqual *tmp54 @this
op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
jump 157 lessThan :areUnitsAvailable.1:free *tmp51
set *tmp40 true
jump 170 always 0 0
op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
ubind @poly
jump 161 equal @unit :areUnitsAvailable.1:firstUnit
sensor *tmp61 :areUnitsAvailable.1:firstUnit @dead
jump 148 equal *tmp61 0
print "poly: occupied: "
print :areUnitsAvailable.1:occupied
print ", free: "
print :areUnitsAvailable.1:free
jump 168 lessThanEq :areUnitsAvailable.1:needed 0
print ", needed: "
print :areUnitsAvailable.1:needed
print "\n"
set *tmp40 false
jump 174 equal *tmp40 false
printflush null
set *tmp9 @poly
jump 264 always 0 0
jump 218 equal @mega UNIT_TYPE
set :areUnitsAvailable.1:free 0
set :areUnitsAvailable.1:occupied 0
set :areUnitsAvailable.1:needed 0
ubind @mega
set :areUnitsAvailable.1:firstUnit @unit
jump 205 equal :areUnitsAvailable.1:firstUnit null
set *tmp51 2
set :needsFourUnits.1:unit @unit
op sub *tmp44 .DOME_X .CORE_X
op sub *tmp45 .DOME_Y .CORE_Y
op len *tmp46 *tmp44 *tmp45
op mul *tmp47 2 *tmp46
sensor *tmp48 :needsFourUnits.1:unit @speed
op div :needsFourUnits.1:travel_time *tmp47 *tmp48
jump 191 lessThan :needsFourUnits.1:travel_time 47
set *tmp51 4
set :areUnitsAvailable.1:needed *tmp51
sensor *tmp52 @unit @controlled
jump 196 equal *tmp52 0
sensor *tmp54 @unit @controller
jump 200 notEqual *tmp54 @this
op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
jump 201 lessThan :areUnitsAvailable.1:free *tmp51
set *tmp40 true
jump 214 always 0 0
op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
ubind @mega
jump 205 equal @unit :areUnitsAvailable.1:firstUnit
sensor *tmp61 :areUnitsAvailable.1:firstUnit @dead
jump 192 equal *tmp61 0
print "mega: occupied: "
print :areUnitsAvailable.1:occupied
print ", free: "
print :areUnitsAvailable.1:free
jump 212 lessThanEq :areUnitsAvailable.1:needed 0
print ", needed: "
print :areUnitsAvailable.1:needed
print "\n"
set *tmp40 false
jump 218 equal *tmp40 false
printflush null
set *tmp9 @mega
jump 264 always 0 0
jump 262 equal @mono UNIT_TYPE
set :areUnitsAvailable.1:free 0
set :areUnitsAvailable.1:occupied 0
set :areUnitsAvailable.1:needed 0
ubind @mono
set :areUnitsAvailable.1:firstUnit @unit
jump 249 equal :areUnitsAvailable.1:firstUnit null
set *tmp51 2
set :needsFourUnits.1:unit @unit
op sub *tmp44 .DOME_X .CORE_X
op sub *tmp45 .DOME_Y .CORE_Y
op len *tmp46 *tmp44 *tmp45
op mul *tmp47 2 *tmp46
sensor *tmp48 :needsFourUnits.1:unit @speed
op div :needsFourUnits.1:travel_time *tmp47 *tmp48
jump 235 lessThan :needsFourUnits.1:travel_time 47
set *tmp51 4
set :areUnitsAvailable.1:needed *tmp51
sensor *tmp52 @unit @controlled
jump 240 equal *tmp52 0
sensor *tmp54 @unit @controller
jump 244 notEqual *tmp54 @this
op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
jump 245 lessThan :areUnitsAvailable.1:free *tmp51
set *tmp40 true
jump 258 always 0 0
op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
ubind @mono
jump 249 equal @unit :areUnitsAvailable.1:firstUnit
sensor *tmp61 :areUnitsAvailable.1:firstUnit @dead
jump 236 equal *tmp61 0
print "mono: occupied: "
print :areUnitsAvailable.1:occupied
print ", free: "
print :areUnitsAvailable.1:free
jump 256 lessThanEq :areUnitsAvailable.1:needed 0
print ", needed: "
print :areUnitsAvailable.1:needed
print "\n"
set *tmp40 false
jump 262 equal *tmp40 false
printflush null
set *tmp9 @mono
jump 264 always 0 0
printflush message1
jump 41 always 0 0
print "[gold]Binding units..."
printflush message1
set .UNIT_P2 null
set .UNIT_S2 null
set .UNIT_P1 null
set .UNIT_S1 null
set :rebindUnits:count 0
ubind *tmp9
set :rebindUnits:firstUnit @unit
jump 275 notEqual :rebindUnits:firstUnit null
end
sensor *tmp70 @unit @controller
jump 284 notEqual *tmp70 @this
op add :rebindUnits:count :rebindUnits:count 1
ucontrol flag 1 0 0 0 0
set .UNIT_S2 .UNIT_P2
set .UNIT_P2 .UNIT_S1
set .UNIT_S1 .UNIT_P1
set .UNIT_P1 @unit
jump 288 notEqual .UNIT_S2 null
ubind *tmp9
jump 288 equal @unit :rebindUnits:firstUnit
sensor *tmp78 :rebindUnits:firstUnit @dead
jump 275 equal *tmp78 0
jump 296 equal .UNIT_S1 null
ubind .UNIT_S1
sensor *tmp84 @unit @dead
op equal *tmp85 *tmp84 0
sensor *tmp86 @unit @controller
op equal *tmp87 *tmp86 @this
op land *tmp88 *tmp85 *tmp87
jump 306 notEqual *tmp88 false
ubind *tmp9
set :rebindUnit:firstUnit @unit
jump 0 equal :rebindUnit:firstUnit null
sensor *tmp92 @unit @controlled
jump 306 equal *tmp92 0
ubind *tmp9
jump 0 equal @unit :rebindUnit:firstUnit
sensor *tmp96 :rebindUnit:firstUnit @dead
jump 299 equal *tmp96 0
end
ucontrol flag 1 0 0 0 0
set *tmp80 @unit
set .UNIT_S1 *tmp80
jump 317 equal .UNIT_P1 null
ubind .UNIT_P1
sensor *tmp102 @unit @dead
op equal *tmp103 *tmp102 0
sensor *tmp104 @unit @controller
op equal *tmp105 *tmp104 @this
op land *tmp106 *tmp103 *tmp105
jump 327 notEqual *tmp106 false
ubind *tmp9
set :rebindUnit.1:firstUnit @unit
jump 0 equal :rebindUnit.1:firstUnit null
sensor *tmp110 @unit @controlled
jump 327 equal *tmp110 0
ubind *tmp9
jump 0 equal @unit :rebindUnit.1:firstUnit
sensor *tmp114 :rebindUnit.1:firstUnit @dead
jump 320 equal *tmp114 0
end
ucontrol flag 1 0 0 0 0
set *tmp98 @unit
set .UNIT_P1 *tmp98
sensor *tmp116 *tmp80 @firstItem
jump 334 equal *tmp116 @phase-fabric
sensor *tmp118 *tmp98 @firstItem
jump 336 notEqual *tmp118 @silicon
set .UNIT_S1 *tmp98
set .UNIT_P1 *tmp80
sensor .UNIT_CAPACITY .UNIT_S1 @itemCapacity
sensor .SPEED .UNIT_S1 @speed
op div .SPEED_TENTHS .SPEED 10
op strictEqual *tmp124 .SPEED null
jump 342 equal *tmp124 false
stop
op sub *tmp127 .DOME_X .CORE_X
op sub *tmp128 .DOME_Y .CORE_Y
op len *tmp129 *tmp127 *tmp128
op mul *tmp130 2 *tmp129
op div :needsFourUnits.2:travel_time *tmp130 .SPEED
op greaterThanEq *tmp126 :needsFourUnits.2:travel_time 47
jump 407 lessThan :needsFourUnits.2:travel_time 47
jump 357 equal .UNIT_S2 null
ubind .UNIT_S2
sensor *tmp139 @unit @dead
op equal *tmp140 *tmp139 0
sensor *tmp141 @unit @controller
op equal *tmp142 *tmp141 @this
op land *tmp143 *tmp140 *tmp142
jump 367 notEqual *tmp143 false
ubind *tmp9
set :rebindUnit.2:firstUnit @unit
jump 0 equal :rebindUnit.2:firstUnit null
sensor *tmp147 @unit @controlled
jump 367 equal *tmp147 0
ubind *tmp9
jump 0 equal @unit :rebindUnit.2:firstUnit
sensor *tmp151 :rebindUnit.2:firstUnit @dead
jump 360 equal *tmp151 0
end
ucontrol flag 1 0 0 0 0
set *tmp135 @unit
set .UNIT_S2 *tmp135
jump 378 equal .UNIT_P2 null
ubind .UNIT_P2
sensor *tmp157 @unit @dead
op equal *tmp158 *tmp157 0
sensor *tmp159 @unit @controller
op equal *tmp160 *tmp159 @this
op land *tmp161 *tmp158 *tmp160
jump 388 notEqual *tmp161 false
ubind *tmp9
set :rebindUnit.3:firstUnit @unit
jump 0 equal :rebindUnit.3:firstUnit null
sensor *tmp165 @unit @controlled
jump 388 equal *tmp165 0
ubind *tmp9
jump 0 equal @unit :rebindUnit.3:firstUnit
sensor *tmp169 :rebindUnit.3:firstUnit @dead
jump 381 equal *tmp169 0
end
ucontrol flag 1 0 0 0 0
set *tmp153 @unit
set .UNIT_P2 *tmp153
sensor *tmp171 .UNIT_S1 @firstItem
jump 398 notEqual *tmp171 @phase-fabric
sensor *tmp173 *tmp153 @firstItem
jump 398 equal *tmp173 @phase-fabric
set :swap.1:t .UNIT_S1
set .UNIT_S1 *tmp153
set .UNIT_P2 :swap.1:t
sensor *tmp176 *tmp135 @firstItem
jump 402 equal *tmp176 @phase-fabric
sensor *tmp178 .UNIT_P2 @firstItem
jump 404 notEqual *tmp178 @silicon
set .UNIT_S2 .UNIT_P2
set .UNIT_P2 *tmp135
set .GROUP1 "unit  1"
set .GROUP2 "unit 2"
jump 414 always 0 0
ubind .UNIT_S2
ucontrol unbind 0 0 0 0 0
set .UNIT_S2 null
ubind .UNIT_P2
ucontrol unbind 0 0 0 0 0
set .UNIT_P2 null
set .GROUP1 "unit"
jump 417 notEqual *tmp126 false
set .SUPPLY_S_FIRST true
jump 420 always 0 0
sensor *tmp182 .UNIT_S1 @totalItems
sensor *tmp183 .UNIT_S2 @totalItems
op lessThan .SUPPLY_S_FIRST *tmp182 *tmp183
jump 423 notEqual *tmp126 false
set .SUPPLY_P_FIRST true
jump 426 always 0 0
sensor *tmp187 .UNIT_P1 @totalItems
sensor *tmp188 .UNIT_P2 @totalItems
op lessThan .SUPPLY_P_FIRST *tmp187 *tmp188
op add :unitCheck @time 5000
sensor *tmp192 switch1 @enabled
jump 0 equal *tmp192 false
set :start @time
print " === [gold]Supplying Overdrive Dome[] === \n\nUnit type: [green]"
print *tmp9
print "[]\n\n[green]Silicon[] status:\n"
sensor :printDomeStatus:level .DOME @silicon
jump 439 lessThanEq :printDomeStatus:level 3
print "  dome:  [green]"
print :printDomeStatus:level
print "[]\n"
jump 442 always 0 0
print "  dome:  [coral]"
print :printDomeStatus:level
print "[]\n"
jump 450 equal .UNIT_S1 null
ubind .UNIT_S1
sensor *tmp199 @unit @dead
op equal *tmp200 *tmp199 0
sensor *tmp201 @unit @controller
op equal *tmp202 *tmp201 @this
op land *tmp203 *tmp200 *tmp202
jump 460 notEqual *tmp203 false
ubind *tmp9
set :rebindUnit.4:firstUnit @unit
jump 0 equal :rebindUnit.4:firstUnit null
sensor *tmp207 @unit @controlled
jump 460 equal *tmp207 0
ubind *tmp9
jump 0 equal @unit :rebindUnit.4:firstUnit
sensor *tmp211 :rebindUnit.4:firstUnit @dead
jump 453 equal *tmp211 0
end
sensor :processUnit:state @unit @flag
set :processUnit:distance -1
jump 464 lessThan :processUnit:state 2
jump 477 lessThanEq :processUnit:state 3
sensor *tmp217 @unit @firstItem
jump 468 notEqual *tmp217 @silicon
set :processUnit:state 3
jump 477 always 0 0
sensor *tmp220 @unit @totalItems
jump 472 notEqual *tmp220 0
set :processUnit:state 2
jump 477 always 0 0
set .MSG ", initializing\n"
ucontrol approach .CORE_X .CORE_Y 6 0 0
ucontrol within .CORE_X .CORE_Y 8 *tmp223 0
jump 477 equal *tmp223 false
ucontrol itemDrop .CORE .UNIT_CAPACITY 0 0 0
jump 497 notEqual :processUnit:state 2
ucontrol within .CORE_X .CORE_Y 8 *tmp227 0
jump 488 equal *tmp227 false
ucontrol itemTake .CORE @silicon .UNIT_CAPACITY 0 0
sensor *tmp229 @unit @totalItems
jump 486 lessThan *tmp229 .UNIT_CAPACITY
ucontrol approach .DOME_X .DOME_Y 6 0 0
set :processUnit:state 3
jump 497 always 0 0
set .MSG ", loading\n"
jump 497 always 0 0
ucontrol approach .CORE_X .CORE_Y 6 0 0
set .MSG ", fetching in [gold]"
sensor *tmp232 @unit @x
op sub *tmp233 .CORE_X *tmp232
sensor *tmp234 @unit @y
op sub *tmp235 .CORE_Y *tmp234
op len *tmp236 *tmp233 *tmp235
op idiv *tmp237 *tmp236 .SPEED_TENTHS
op div :processUnit:distance *tmp237 10
jump 520 notEqual :processUnit:state 3
ucontrol within .DOME_X .DOME_Y 8 *tmp241 0
jump 511 equal *tmp241 false
jump 504 equal .SUPPLY_S_FIRST false
ucontrol itemDrop .DOME .UNIT_CAPACITY 0 0 0
set .MSG ", supplying\n"
jump 506 always 0 0
ucontrol approach .DOME_X .DOME_Y 6 0 0
set .MSG ", waiting\n"
sensor *tmp244 @unit @totalItems
jump 520 greaterThan *tmp244 0
ucontrol approach .CORE_X .CORE_Y 6 0 0
set :processUnit:state 2
jump 520 always 0 0
ucontrol approach .DOME_X .DOME_Y 6 0 0
set .MSG ", returning in [gold]"
sensor *tmp247 @unit @x
op sub *tmp248 .DOME_X *tmp247
sensor *tmp249 @unit @y
op sub *tmp250 .DOME_Y *tmp249
op len *tmp251 *tmp248 *tmp250
op idiv *tmp252 *tmp251 .SPEED_TENTHS
op div :processUnit:distance *tmp252 10
ucontrol flag :processUnit:state 0 0 0 0
sensor *tmp254 @unit @totalItems
print "  "
print .GROUP1
print ": [gold]"
print *tmp254
print "[]"
jump 532 lessThan :processUnit:distance 0
print .MSG
print :processUnit:distance
print "[] sec\n"
jump 533 always 0 0
print .MSG
set :processUnit:unit @unit
set .UNIT_S1 :processUnit:unit
jump 635 equal *tmp126 false
jump 544 equal .UNIT_S2 null
ubind .UNIT_S2
sensor *tmp263 @unit @dead
op equal *tmp264 *tmp263 0
sensor *tmp265 @unit @controller
op equal *tmp266 *tmp265 @this
op land *tmp267 *tmp264 *tmp266
jump 554 notEqual *tmp267 false
ubind *tmp9
set :rebindUnit.5:firstUnit @unit
jump 0 equal :rebindUnit.5:firstUnit null
sensor *tmp271 @unit @controlled
jump 554 equal *tmp271 0
ubind *tmp9
jump 0 equal @unit :rebindUnit.5:firstUnit
sensor *tmp275 :rebindUnit.5:firstUnit @dead
jump 547 equal *tmp275 0
end
sensor :processUnit.1:state @unit @flag
set :processUnit.1:distance -1
jump 558 lessThan :processUnit.1:state 2
jump 571 lessThanEq :processUnit.1:state 3
sensor *tmp281 @unit @firstItem
jump 562 notEqual *tmp281 @silicon
set :processUnit.1:state 3
jump 571 always 0 0
sensor *tmp284 @unit @totalItems
jump 566 notEqual *tmp284 0
set :processUnit.1:state 2
jump 571 always 0 0
set .MSG ", initializing\n"
ucontrol approach .CORE_X .CORE_Y 6 0 0
ucontrol within .CORE_X .CORE_Y 8 *tmp287 0
jump 571 equal *tmp287 false
ucontrol itemDrop .CORE .UNIT_CAPACITY 0 0 0
jump 591 notEqual :processUnit.1:state 2
ucontrol within .CORE_X .CORE_Y 8 *tmp291 0
jump 582 equal *tmp291 false
ucontrol itemTake .CORE @silicon .UNIT_CAPACITY 0 0
sensor *tmp293 @unit @totalItems
jump 580 lessThan *tmp293 .UNIT_CAPACITY
ucontrol approach .DOME_X .DOME_Y 6 0 0
set :processUnit.1:state 3
jump 591 always 0 0
set .MSG ", loading\n"
jump 591 always 0 0
ucontrol approach .CORE_X .CORE_Y 6 0 0
set .MSG ", fetching in [gold]"
sensor *tmp296 @unit @x
op sub *tmp297 .CORE_X *tmp296
sensor *tmp298 @unit @y
op sub *tmp299 .CORE_Y *tmp298
op len *tmp300 *tmp297 *tmp299
op idiv *tmp301 *tmp300 .SPEED_TENTHS
op div :processUnit.1:distance *tmp301 10
jump 614 notEqual :processUnit.1:state 3
ucontrol within .DOME_X .DOME_Y 8 *tmp305 0
jump 605 equal *tmp305 false
jump 598 notEqual .SUPPLY_S_FIRST false
ucontrol itemDrop .DOME .UNIT_CAPACITY 0 0 0
set .MSG ", supplying\n"
jump 600 always 0 0
ucontrol approach .DOME_X .DOME_Y 6 0 0
set .MSG ", waiting\n"
sensor *tmp308 @unit @totalItems
jump 614 greaterThan *tmp308 0
ucontrol approach .CORE_X .CORE_Y 6 0 0
set :processUnit.1:state 2
jump 614 always 0 0
ucontrol approach .DOME_X .DOME_Y 6 0 0
set .MSG ", returning in [gold]"
sensor *tmp311 @unit @x
op sub *tmp312 .DOME_X *tmp311
sensor *tmp313 @unit @y
op sub *tmp314 .DOME_Y *tmp313
op len *tmp315 *tmp312 *tmp314
op idiv *tmp316 *tmp315 .SPEED_TENTHS
op div :processUnit.1:distance *tmp316 10
ucontrol flag :processUnit.1:state 0 0 0 0
sensor *tmp318 @unit @totalItems
print "  "
print .GROUP2
print ": [gold]"
print *tmp318
print "[]"
jump 626 lessThan :processUnit.1:distance 0
print .MSG
print :processUnit.1:distance
print "[] sec\n"
jump 627 always 0 0
print .MSG
set :processUnit.1:unit @unit
set .UNIT_S2 :processUnit.1:unit
jump 633 equal .SUPPLY_S_FIRST false
sensor *tmp323 :processUnit:unit @totalItems
op greaterThan .SUPPLY_S_FIRST *tmp323 0
jump 635 always 0 0
sensor *tmp325 :processUnit.1:unit @totalItems
op equal .SUPPLY_S_FIRST *tmp325 0
print "\n[green]Phase fabric[] status:\n"
sensor :printDomeStatus.1:level .DOME @phase-fabric
jump 642 lessThanEq :printDomeStatus.1:level 3
print "  dome:  [green]"
print :printDomeStatus.1:level
print "[]\n"
jump 645 always 0 0
print "  dome:  [coral]"
print :printDomeStatus.1:level
print "[]\n"
jump 653 equal .UNIT_P1 null
ubind .UNIT_P1
sensor *tmp333 @unit @dead
op equal *tmp334 *tmp333 0
sensor *tmp335 @unit @controller
op equal *tmp336 *tmp335 @this
op land *tmp337 *tmp334 *tmp336
jump 663 notEqual *tmp337 false
ubind *tmp9
set :rebindUnit.6:firstUnit @unit
jump 0 equal :rebindUnit.6:firstUnit null
sensor *tmp341 @unit @controlled
jump 663 equal *tmp341 0
ubind *tmp9
jump 0 equal @unit :rebindUnit.6:firstUnit
sensor *tmp345 :rebindUnit.6:firstUnit @dead
jump 656 equal *tmp345 0
end
sensor :processUnit.2:state @unit @flag
set :processUnit.2:distance -1
jump 667 lessThan :processUnit.2:state 2
jump 680 lessThanEq :processUnit.2:state 3
sensor *tmp351 @unit @firstItem
jump 671 notEqual *tmp351 @phase-fabric
set :processUnit.2:state 3
jump 680 always 0 0
sensor *tmp354 @unit @totalItems
jump 675 notEqual *tmp354 0
set :processUnit.2:state 2
jump 680 always 0 0
set .MSG ", initializing\n"
ucontrol approach .CORE_X .CORE_Y 6 0 0
ucontrol within .CORE_X .CORE_Y 8 *tmp357 0
jump 680 equal *tmp357 false
ucontrol itemDrop .CORE .UNIT_CAPACITY 0 0 0
jump 700 notEqual :processUnit.2:state 2
ucontrol within .CORE_X .CORE_Y 8 *tmp361 0
jump 691 equal *tmp361 false
ucontrol itemTake .CORE @phase-fabric .UNIT_CAPACITY 0 0
sensor *tmp363 @unit @totalItems
jump 689 lessThan *tmp363 .UNIT_CAPACITY
ucontrol approach .DOME_X .DOME_Y 6 0 0
set :processUnit.2:state 3
jump 700 always 0 0
set .MSG ", loading\n"
jump 700 always 0 0
ucontrol approach .CORE_X .CORE_Y 6 0 0
set .MSG ", fetching in [gold]"
sensor *tmp366 @unit @x
op sub *tmp367 .CORE_X *tmp366
sensor *tmp368 @unit @y
op sub *tmp369 .CORE_Y *tmp368
op len *tmp370 *tmp367 *tmp369
op idiv *tmp371 *tmp370 .SPEED_TENTHS
op div :processUnit.2:distance *tmp371 10
jump 723 notEqual :processUnit.2:state 3
ucontrol within .DOME_X .DOME_Y 8 *tmp375 0
jump 714 equal *tmp375 false
jump 707 equal .SUPPLY_P_FIRST false
ucontrol itemDrop .DOME .UNIT_CAPACITY 0 0 0
set .MSG ", supplying\n"
jump 709 always 0 0
ucontrol approach .DOME_X .DOME_Y 6 0 0
set .MSG ", waiting\n"
sensor *tmp378 @unit @totalItems
jump 723 greaterThan *tmp378 0
ucontrol approach .CORE_X .CORE_Y 6 0 0
set :processUnit.2:state 2
jump 723 always 0 0
ucontrol approach .DOME_X .DOME_Y 6 0 0
set .MSG ", returning in [gold]"
sensor *tmp381 @unit @x
op sub *tmp382 .DOME_X *tmp381
sensor *tmp383 @unit @y
op sub *tmp384 .DOME_Y *tmp383
op len *tmp385 *tmp382 *tmp384
op idiv *tmp386 *tmp385 .SPEED_TENTHS
op div :processUnit.2:distance *tmp386 10
ucontrol flag :processUnit.2:state 0 0 0 0
sensor *tmp388 @unit @totalItems
print "  "
print .GROUP1
print ": [gold]"
print *tmp388
print "[]"
jump 735 lessThan :processUnit.2:distance 0
print .MSG
print :processUnit.2:distance
print "[] sec\n"
jump 736 always 0 0
print .MSG
set :processUnit.2:unit @unit
set .UNIT_P1 :processUnit.2:unit
jump 838 equal *tmp126 false
jump 747 equal .UNIT_P2 null
ubind .UNIT_P2
sensor *tmp397 @unit @dead
op equal *tmp398 *tmp397 0
sensor *tmp399 @unit @controller
op equal *tmp400 *tmp399 @this
op land *tmp401 *tmp398 *tmp400
jump 757 notEqual *tmp401 false
ubind *tmp9
set :rebindUnit.7:firstUnit @unit
jump 0 equal :rebindUnit.7:firstUnit null
sensor *tmp405 @unit @controlled
jump 757 equal *tmp405 0
ubind *tmp9
jump 0 equal @unit :rebindUnit.7:firstUnit
sensor *tmp409 :rebindUnit.7:firstUnit @dead
jump 750 equal *tmp409 0
end
sensor :processUnit.3:state @unit @flag
set :processUnit.3:distance -1
jump 761 lessThan :processUnit.3:state 2
jump 774 lessThanEq :processUnit.3:state 3
sensor *tmp415 @unit @firstItem
jump 765 notEqual *tmp415 @phase-fabric
set :processUnit.3:state 3
jump 774 always 0 0
sensor *tmp418 @unit @totalItems
jump 769 notEqual *tmp418 0
set :processUnit.3:state 2
jump 774 always 0 0
set .MSG ", initializing\n"
ucontrol approach .CORE_X .CORE_Y 6 0 0
ucontrol within .CORE_X .CORE_Y 8 *tmp421 0
jump 774 equal *tmp421 false
ucontrol itemDrop .CORE .UNIT_CAPACITY 0 0 0
jump 794 notEqual :processUnit.3:state 2
ucontrol within .CORE_X .CORE_Y 8 *tmp425 0
jump 785 equal *tmp425 false
ucontrol itemTake .CORE @phase-fabric .UNIT_CAPACITY 0 0
sensor *tmp427 @unit @totalItems
jump 783 lessThan *tmp427 .UNIT_CAPACITY
ucontrol approach .DOME_X .DOME_Y 6 0 0
set :processUnit.3:state 3
jump 794 always 0 0
set .MSG ", loading\n"
jump 794 always 0 0
ucontrol approach .CORE_X .CORE_Y 6 0 0
set .MSG ", fetching in [gold]"
sensor *tmp430 @unit @x
op sub *tmp431 .CORE_X *tmp430
sensor *tmp432 @unit @y
op sub *tmp433 .CORE_Y *tmp432
op len *tmp434 *tmp431 *tmp433
op idiv *tmp435 *tmp434 .SPEED_TENTHS
op div :processUnit.3:distance *tmp435 10
jump 817 notEqual :processUnit.3:state 3
ucontrol within .DOME_X .DOME_Y 8 *tmp439 0
jump 808 equal *tmp439 false
jump 801 notEqual .SUPPLY_P_FIRST false
ucontrol itemDrop .DOME .UNIT_CAPACITY 0 0 0
set .MSG ", supplying\n"
jump 803 always 0 0
ucontrol approach .DOME_X .DOME_Y 6 0 0
set .MSG ", waiting\n"
sensor *tmp442 @unit @totalItems
jump 817 greaterThan *tmp442 0
ucontrol approach .CORE_X .CORE_Y 6 0 0
set :processUnit.3:state 2
jump 817 always 0 0
ucontrol approach .DOME_X .DOME_Y 6 0 0
set .MSG ", returning in [gold]"
sensor *tmp445 @unit @x
op sub *tmp446 .DOME_X *tmp445
sensor *tmp447 @unit @y
op sub *tmp448 .DOME_Y *tmp447
op len *tmp449 *tmp446 *tmp448
op idiv *tmp450 *tmp449 .SPEED_TENTHS
op div :processUnit.3:distance *tmp450 10
ucontrol flag :processUnit.3:state 0 0 0 0
sensor *tmp452 @unit @totalItems
print "  "
print .GROUP2
print ": [gold]"
print *tmp452
print "[]"
jump 829 lessThan :processUnit.3:distance 0
print .MSG
print :processUnit.3:distance
print "[] sec\n"
jump 830 always 0 0
print .MSG
set :processUnit.3:unit @unit
set .UNIT_P2 :processUnit.3:unit
jump 836 equal .SUPPLY_P_FIRST false
sensor *tmp457 :processUnit.2:unit @totalItems
op greaterThan .SUPPLY_P_FIRST *tmp457 0
jump 838 always 0 0
sensor *tmp459 :processUnit.3:unit @totalItems
op equal .SUPPLY_P_FIRST *tmp459 0
op sub *tmp461 @time :start
op floor *tmp462 *tmp461 0
print "\n[lightgray]Loop time: "
print *tmp462
print " ms"
printflush message1
jump 874 equal *tmp9 UNIT_TYPE
jump 874 lessThanEq :unitCheck @time
set :areUnitsAvailable.2:free 0
set :areUnitsAvailable.2:occupied 0
ubind UNIT_TYPE
set :areUnitsAvailable.2:firstUnit @unit
jump 870 equal :areUnitsAvailable.2:firstUnit null
set *tmp477 2
set :needsFourUnits.3:unit @unit
sensor *tmp474 :needsFourUnits.3:unit @speed
op div :needsFourUnits.3:travel_time *tmp130 *tmp474
jump 857 lessThan :needsFourUnits.3:travel_time 47
set *tmp477 4
sensor *tmp478 @unit @controlled
jump 861 equal *tmp478 0
sensor *tmp480 @unit @controller
jump 865 notEqual *tmp480 @this
op add :areUnitsAvailable.2:free :areUnitsAvailable.2:free 1
jump 866 lessThan :areUnitsAvailable.2:free *tmp477
set *tmp466 true
jump 871 always 0 0
op add :areUnitsAvailable.2:occupied :areUnitsAvailable.2:occupied 1
ubind UNIT_TYPE
jump 870 equal @unit :areUnitsAvailable.2:firstUnit
sensor *tmp487 :areUnitsAvailable.2:firstUnit @dead
jump 857 equal *tmp487 0
set *tmp466 false
jump 873 equal *tmp466 false
end
op add :unitCheck @time 5000
sensor *tmp192 switch1 @enabled
jump 429 notEqual *tmp192 false
end
ubind :locateCore:type
sensor *tmp494 @unit @controlled
jump 882 equal *tmp494 0
sensor *tmp496 @unit @controller
jump 883 notEqual *tmp496 @this
ulocate building core false @copper 0 0 0 .CORE
set :locateCore*retval .CORE
set @counter :locateCore*retaddr
print "Compiled by Mindcode - github.com/cardillan/mindcode"

