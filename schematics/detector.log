   253 instructions before optimizations.
     2 instructions eliminated by Temp Variables Elimination.
     1 instructions eliminated by Case Expression Optimization.
    13 instructions eliminated by Dead Code Elimination (2 passes, 5 iterations).
     1 instructions eliminated by Jump Normalization (3 iterations).
     1 instructions eliminated by Jump Optimization (3 iterations).
     2 instructions eliminated by Single Step Elimination (4 iterations).
     2 instructions eliminated by If Expression Optimization (2 iterations).
     1 instructions modified by Data Flow Optimization (3 iterations).
     7 instructions eliminated by Jump Straightening (3 iterations).
     1 instructions updated by JumpThreading.
     1 instructions eliminated by Unreachable Code Elimination.
    52 instructions eliminated by Print Merging.
   171 instructions after optimizations.

Modifications by Initial phase, Case Expression Optimization, iteration 1 (-1 instructions):
 
    13 sensor *tmp4 :block @type
    14 print *tmp4
    15 print " - "
-    * set *tmp6 :page
-    * jump *label7 equal *tmp6 1
+   16 jump *label7 equal :page 1
    17 jump *label6 always
    18 label *label7
    19 print "contents:"
 
    42 set *tmp5 *tmp12
    43 jump *label5 always
    44 label *label6
-    * jump *label9 equal *tmp6 2
+   45 jump *label9 equal :page 2
    46 jump *label8 always
    47 label *label9
    48 print "power:"
 
    78 set *tmp5 *tmp22
    79 jump *label5 always
    80 label *label8
-    * jump *label11 equal *tmp6 3
+   81 jump *label11 equal :page 3
    82 jump *label10 always
    83 label *label11
    84 print "combat:"
 
   102 set *tmp5 *tmp26
   103 jump *label5 always
   104 label *label10
-    * jump *label13 equal *tmp6 4
+  105 jump *label13 equal :page 4
   106 jump *label12 always
   107 label *label13
   108 print "status:"
 
   130 set *tmp5 *tmp31
   131 jump *label5 always
   132 label *label12
-    * jump *label15 equal *tmp6 5
+  133 jump *label15 equal :page 5
   134 jump *label14 always
   135 label *label15
   136 print "position:"
 
   154 set *tmp5 *tmp35
   155 jump *label5 always
   156 label *label14
-    * jump *label17 equal *tmp6 6
+  157 jump *label17 equal :page 6
   158 jump *label16 always
   159 label *label17
   160 print "unit:"
 
   206 set *tmp5 *tmp46
   207 jump *label5 always
   208 label *label16
-    * jump *label19 equal *tmp6 7
+  209 jump *label19 equal :page 7
   210 jump *label18 always
   211 label *label19
   212 print "other:"

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-4 instructions):
 
   244 label *label18
   245 set *tmp5 null
   246 label *label5
-    * set *tmp3 *tmp5
   247 jump *label4 always
   248 label *label3
   249 print "No linked block found."
   250 print "\n"
-    * set *tmp3 "No linked block found."
   251 label *label4
   252 printflush message1
   253 sensor *tmp54 switch1 @enabled
 
   262 label *label23
   263 set :page *tmp57
   264 control enabled switch1 false
-    * set *tmp55 false
   265 jump *label21 always
   266 label *label20
-    * set *tmp55 null
   267 label *label21
   268 label *label1
   269 jump *label0 always

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-8 instructions):
 
    39 print "liquidCapacity: "
    40 print *tmp12
    41 print "\n"
-    * set *tmp5 *tmp12
    42 jump *label5 always
    43 label *label6
    44 jump *label9 equal :page 2
 
    74 print "powerNetOut: "
    75 print *tmp22
    76 print "\n"
-    * set *tmp5 *tmp22
    77 jump *label5 always
    78 label *label8
    79 jump *label11 equal :page 3
 
    97 print "maxHealth: "
    98 print *tmp26
    99 print "\n"
-    * set *tmp5 *tmp26
   100 jump *label5 always
   101 label *label10
   102 jump *label13 equal :page 4
 
   124 print "range: "
   125 print *tmp31
   126 print "\n"
-    * set *tmp5 *tmp31
   127 jump *label5 always
   128 label *label12
   129 jump *label15 equal :page 5
 
   147 print "size: "
   148 print *tmp35
   149 print "\n"
-    * set *tmp5 *tmp35
   150 jump *label5 always
   151 label *label14
   152 jump *label17 equal :page 6
 
   198 print "controller: "
   199 print *tmp46
   200 print "\n"
-    * set *tmp5 *tmp46
   201 jump *label5 always
   202 label *label16
   203 jump *label19 equal :page 7
 
   233 print "configure: "
   234 print *tmp53
   235 print "\n"
-    * set *tmp5 *tmp53
   236 jump *label5 always
   237 label *label18
-    * set *tmp5 null
   238 label *label5
   239 jump *label4 always
   240 label *label3

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-2 instructions):
     0 set :page 1
     1 label *label0
     2 jump *label2 equal true false
-    * getlink *tmp0 2
-    * set :block *tmp0
+    3 getlink :block 2
     4 print "Property detector - page "
     5 print :page
     6 print "/"
 
   248 set *tmp57 1
   249 jump *label23 always
   250 label *label22
-    * op add *tmp58 :page 1
-    * set *tmp57 *tmp58
+  251 op add *tmp57 :page 1
   252 label *label23
   253 set :page *tmp57
   254 control enabled switch1 false

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-1 instructions):
     0 set :page 1
     1 label *label0
-    * jump *label2 equal true false
     2 getlink :block 2
     3 print "Property detector - page "
     4 print :page

Modifications by Iterated phase, Jump Straightening, pass 1, iteration 1 (-7 instructions):
 
    11 sensor *tmp4 :block @type
    12 print *tmp4
    13 print " - "
-    * jump *label7 equal :page 1
-    * jump *label6 always
+   14 jump *label6 notEqual :page 1
    15 label *label7
    16 print "contents:"
    17 print "\n"
 
    38 print "\n"
    39 jump *label5 always
    40 label *label6
-    * jump *label9 equal :page 2
-    * jump *label8 always
+   41 jump *label8 notEqual :page 2
    42 label *label9
    43 print "power:"
    44 print "\n"
 
    72 print "\n"
    73 jump *label5 always
    74 label *label8
-    * jump *label11 equal :page 3
-    * jump *label10 always
+   75 jump *label10 notEqual :page 3
    76 label *label11
    77 print "combat:"
    78 print "\n"
 
    94 print "\n"
    95 jump *label5 always
    96 label *label10
-    * jump *label13 equal :page 4
-    * jump *label12 always
+   97 jump *label12 notEqual :page 4
    98 label *label13
    99 print "status:"
   100 print "\n"
 
   120 print "\n"
   121 jump *label5 always
   122 label *label12
-    * jump *label15 equal :page 5
-    * jump *label14 always
+  123 jump *label14 notEqual :page 5
   124 label *label15
   125 print "position:"
   126 print "\n"
 
   142 print "\n"
   143 jump *label5 always
   144 label *label14
-    * jump *label17 equal :page 6
-    * jump *label16 always
+  145 jump *label16 notEqual :page 6
   146 label *label17
   147 print "unit:"
   148 print "\n"
 
   192 print "\n"
   193 jump *label5 always
   194 label *label16
-    * jump *label19 equal :page 7
-    * jump *label18 always
+  195 jump *label18 notEqual :page 7
   196 label *label19
   197 print "other:"
   198 print "\n"

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-1 instructions):
 
   235 printflush message1
   236 sensor *tmp54 switch1 @enabled
   237 jump *label20 equal *tmp54 false
-    * op equal *tmp56 :page 7
-    * jump *label22 equal *tmp56 false
+  238 jump *label22 notEqual :page 7
   239 set *tmp57 1
   240 jump *label23 always
   241 label *label22

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-2 instructions):
 
   224 print "configure: "
   225 print *tmp53
   226 print "\n"
-    * jump *label5 always
   227 label *label18
   228 label *label5
   229 jump *label4 always
 
   242 label *label23
   243 set :page *tmp57
   244 control enabled switch1 false
-    * jump *label21 always
   245 label *label20
   246 label *label21
   247 label *label1

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
   202 print "\n"
   203 sensor *tmp48 :block @type
   204 print "type: "
-    * print *tmp48
+  205 print *tmp4
   206 print "\n"
   207 sensor *tmp49 :block @flag
   208 print "flag: "

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 1 (-2 instructions):
 
     6 print 7
     7 print "\n"
     8 sensor *tmp1 :block @dead
-    * op strictEqual *tmp2 *tmp1 0
-    * jump *label3 equal *tmp2 false
+    9 jump *label3 strictEqual *tmp1 0
+   10 print "No linked block found."
+   11 print "\n"
+   12 jump *label4 always
+   13 label *label3
    14 sensor *tmp4 :block @type
    15 print *tmp4
    16 print " - "
 
   229 print "\n"
   230 label *label18
   231 label *label5
-    * jump *label4 always
-    * label *label3
-    * print "No linked block found."
-    * print "\n"
   232 label *label4
   233 printflush message1
   234 sensor *tmp54 switch1 @enabled
   235 jump *label20 equal *tmp54 false
   236 jump *label22 notEqual :page 7
-    * set *tmp57 1
+  237 set :page 1
   238 jump *label23 always
   239 label *label22
-    * op add *tmp57 :page 1
+  240 op add :page :page 1
   241 label *label23
-    * set :page *tmp57
   242 control enabled switch1 false
   243 label *label20
   244 label *label21

Modifications by Final phase, Jump Threading, iteration 1:
 
   232 label *label4
   233 printflush message1
   234 sensor *tmp54 switch1 @enabled
-    * jump *label20 equal *tmp54 false
+  235 jump *label0 equal *tmp54 false
   236 jump *label22 notEqual :page 7
   237 set :page 1
   238 jump *label23 always

Modifications by Final phase, Unreachable Code Elimination, iteration 1 (-1 instructions):
 
   244 label *label21
   245 label *label1
   246 jump *label0 always
-    * label *label2
-    * end

Modifications by Final phase, Dead Code Elimination, iteration 1 (-1 instructions):
 
   203 print "team: "
   204 print *tmp47
   205 print "\n"
-    * sensor *tmp48 :block @type
   206 print "type: "
   207 print *tmp4
   208 print "\n"

Modifications by Final phase, Print Merging, iteration 1 (-52 instructions):
 
     2 getlink :block 2
     3 print "Property detector - page "
     4 print :page
-    * print "/"
-    * print 7
-    * print "\n"
+    5 print "/7\n"
     6 sensor *tmp1 :block @dead
     7 jump *label3 strictEqual *tmp1 0
-    * print "No linked block found."
-    * print "\n"
+    8 print "No linked block found.\n"
     9 jump *label4 always
    10 label *label3
    11 sensor *tmp4 :block @type
 
    13 print " - "
    14 jump *label6 notEqual :page 1
    15 label *label7
-    * print "contents:"
-    * print "\n"
    16 sensor *tmp7 :block @totalItems
-    * print "totalItems: "
+   17 print "contents:\ntotalItems: "
    18 print *tmp7
-    * print "\n"
    19 sensor *tmp8 :block @firstItem
-    * print "firstItem: "
+   20 print "\nfirstItem: "
    21 print *tmp8
-    * print "\n"
    22 sensor *tmp9 :block @itemCapacity
-    * print "itemCapacity: "
+   23 print "\nitemCapacity: "
    24 print *tmp9
-    * print "\n"
    25 sensor *tmp10 :block @totalLiquids
    26 op floor *tmp11 *tmp10
-    * print "totalLiquids: "
+   27 print "\ntotalLiquids: "
    28 print *tmp11
-    * print "\n"
    29 sensor *tmp12 :block @liquidCapacity
-    * print "liquidCapacity: "
+   30 print "\nliquidCapacity: "
    31 print *tmp12
    32 print "\n"
    33 jump *label5 always
    34 label *label6
    35 jump *label8 notEqual :page 2
    36 label *label9
-    * print "power:"
-    * print "\n"
    37 sensor *tmp13 :block @totalPower
    38 op floor *tmp14 *tmp13
-    * print "totalPower: "
+   39 print "power:\ntotalPower: "
    40 print *tmp14
-    * print "\n"
    41 sensor *tmp15 :block @powerCapacity
-    * print "powerCapacity: "
+   42 print "\npowerCapacity: "
    43 print *tmp15
-    * print "\n"
    44 sensor *tmp16 :block @powerNetStored
    45 op floor *tmp17 *tmp16
-    * print "powerNetStored: "
+   46 print "\npowerNetStored: "
    47 print *tmp17
-    * print "\n"
    48 sensor *tmp18 :block @powerNetCapacity
-    * print "powerNetCapacity: "
+   49 print "\npowerNetCapacity: "
    50 print *tmp18
-    * print "\n"
    51 sensor *tmp19 :block @powerNetIn
    52 op floor *tmp20 *tmp19
-    * print "powerNetIn: "
+   53 print "\npowerNetIn: "
    54 print *tmp20
-    * print "\n"
    55 sensor *tmp21 :block @powerNetOut
    56 op floor *tmp22 *tmp21
-    * print "powerNetOut: "
+   57 print "\npowerNetOut: "
    58 print *tmp22
    59 print "\n"
    60 jump *label5 always
    61 label *label8
    62 jump *label10 notEqual :page 3
    63 label *label11
-    * print "combat:"
-    * print "\n"
    64 sensor *tmp23 :block @ammo
-    * print "ammo: "
+   65 print "combat:\nammo: "
    66 print *tmp23
-    * print "\n"
    67 sensor *tmp24 :block @ammoCapacity
-    * print "ammoCapacity: "
+   68 print "\nammoCapacity: "
    69 print *tmp24
-    * print "\n"
    70 sensor *tmp25 :block @health
-    * print "health: "
+   71 print "\nhealth: "
    72 print *tmp25
-    * print "\n"
    73 sensor *tmp26 :block @maxHealth
-    * print "maxHealth: "
+   74 print "\nmaxHealth: "
    75 print *tmp26
    76 print "\n"
    77 jump *label5 always
    78 label *label10
    79 jump *label12 notEqual :page 4
    80 label *label13
-    * print "status:"
-    * print "\n"
    81 sensor *tmp27 :block @heat
-    * print "heat: "
+   82 print "status:\nheat: "
    83 print *tmp27
-    * print "\n"
    84 sensor *tmp28 :block @efficiency
-    * print "efficiency: "
+   85 print "\nefficiency: "
    86 print *tmp28
-    * print "\n"
    87 sensor *tmp29 :block @timescale
-    * print "timescale: "
+   88 print "\ntimescale: "
    89 print *tmp29
-    * print "\n"
    90 sensor *tmp30 :block @dead
-    * print "dead: "
+   91 print "\ndead: "
    92 print *tmp30
-    * print "\n"
    93 sensor *tmp31 :block @range
-    * print "range: "
+   94 print "\nrange: "
    95 print *tmp31
    96 print "\n"
    97 jump *label5 always
    98 label *label12
    99 jump *label14 notEqual :page 5
   100 label *label15
-    * print "position:"
-    * print "\n"
   101 sensor *tmp32 :block @rotation
-    * print "rotation: "
+  102 print "position:\nrotation: "
   103 print *tmp32
-    * print "\n"
   104 sensor *tmp33 :block @x
-    * print "x: "
+  105 print "\nx: "
   106 print *tmp33
-    * print "\n"
   107 sensor *tmp34 :block @y
-    * print "y: "
+  108 print "\ny: "
   109 print *tmp34
-    * print "\n"
   110 sensor *tmp35 :block @size
-    * print "size: "
+  111 print "\nsize: "
   112 print *tmp35
   113 print "\n"
   114 jump *label5 always
   115 label *label14
   116 jump *label16 notEqual :page 6
   117 label *label17
-    * print "unit:"
-    * print "\n"
   118 sensor *tmp36 :block @shootX
-    * print "shootX: "
+  119 print "unit:\nshootX: "
   120 print *tmp36
-    * print "\n"
   121 sensor *tmp37 :block @shootY
-    * print "shootY: "
+  122 print "\nshootY: "
   123 print *tmp37
-    * print "\n"
   124 sensor *tmp38 :block @shooting
-    * print "shooting: "
+  125 print "\nshooting: "
   126 print *tmp38
-    * print "\n"
   127 sensor *tmp39 :block @boosting
-    * print "boosting: "
+  128 print "\nboosting: "
   129 print *tmp39
-    * print "\n"
   130 sensor *tmp40 :block @mineX
-    * print "mineX: "
+  131 print "\nmineX: "
   132 print *tmp40
-    * print "\n"
   133 sensor *tmp41 :block @mineY
-    * print "mineY: "
+  134 print "\nmineY: "
   135 print *tmp41
-    * print "\n"
   136 sensor *tmp42 :block @mining
-    * print "mining: "
+  137 print "\nmining: "
   138 print *tmp42
-    * print "\n"
   139 sensor *tmp43 :block @payloadCount
-    * print "payloadCount: "
+  140 print "\npayloadCount: "
   141 print *tmp43
-    * print "\n"
   142 sensor *tmp44 :block @payloadType
-    * print "payloadType: "
+  143 print "\npayloadType: "
   144 print *tmp44
-    * print "\n"
   145 sensor *tmp45 :block @controlled
-    * print "controlled: "
+  146 print "\ncontrolled: "
   147 print *tmp45
-    * print "\n"
   148 sensor *tmp46 :block @controller
-    * print "controller: "
+  149 print "\ncontroller: "
   150 print *tmp46
   151 print "\n"
   152 jump *label5 always
   153 label *label16
   154 jump *label18 notEqual :page 7
   155 label *label19
-    * print "other:"
-    * print "\n"
   156 sensor *tmp47 :block @team
-    * print "team: "
+  157 print "other:\nteam: "
   158 print *tmp47
-    * print "\n"
-    * print "type: "
+  159 print "\ntype: "
   160 print *tmp4
-    * print "\n"
   161 sensor *tmp49 :block @flag
-    * print "flag: "
+  162 print "\nflag: "
   163 print *tmp49
-    * print "\n"
   164 sensor *tmp50 :block @name
-    * print "name: "
+  165 print "\nname: "
   166 print *tmp50
-    * print "\n"
   167 sensor *tmp51 :block @config
-    * print "config: "
+  168 print "\nconfig: "
   169 print *tmp51
-    * print "\n"
   170 sensor *tmp52 :block @enabled
-    * print "enabled: "
+  171 print "\nenabled: "
   172 print *tmp52
-    * print "\n"
   173 sensor *tmp53 :block @configure
-    * print "configure: "
+  174 print "\nconfigure: "
   175 print *tmp53
   176 print "\n"
   177 label *label18

Final code before resolving virtual instructions:

    0:  set :page 1                                                  page = 1;
        label *label0                                                while true do
    1:  getlink :block 2                                             block = getlink(2);  // First two links are a switch and a message
    2:  print "Property detector - page "                            println($"Property detector - page $page/$NUM_PAGES");
    3:  print :page                                                  ...
    4:  print "/7\n"                                                 ...
    5:  sensor *tmp1 :block @dead                                    if block.@dead === 0 then
    6:  jump *label3 strictEqual *tmp1 0                             ...
    7:  print "No linked block found.\n"                             println("No linked block found.");
    8:  jump *label4 always 0 0                                      if block.@dead === 0 then
        label *label3                                                ...
    9:  sensor *tmp4 :block @type                                    print(block.@type, " - ");
   10:  print *tmp4                                                  ...
   11:  print " - "                                                  ...
   12:  jump *label6 notEqual :page 1                                case page
   13:  sensor *tmp7 :block @totalItems                              println("totalItems: ",         block.@totalItems);
   14:  print "contents:\ntotalItems: "                              ...
   15:  print *tmp7                                                  ...
   16:  sensor *tmp8 :block @firstItem                               println("firstItem: ",          block.@firstItem);
   17:  print "\nfirstItem: "                                        ...
   18:  print *tmp8                                                  ...
   19:  sensor *tmp9 :block @itemCapacity                            println("itemCapacity: ",       block.@itemCapacity);
   20:  print "\nitemCapacity: "                                     ...
   21:  print *tmp9                                                  ...
   22:  sensor *tmp10 :block @totalLiquids                           println("totalLiquids: ",       floor(block.@totalLiquids));
   23:  op floor *tmp11 *tmp10 0                                     ...
   24:  print "\ntotalLiquids: "                                     ...
   25:  print *tmp11                                                 ...
   26:  sensor *tmp12 :block @liquidCapacity                         println("liquidCapacity: ",     block.@liquidCapacity);
   27:  print "\nliquidCapacity: "                                   ...
   28:  print *tmp12                                                 ...
   29:  print "\n"                                                   ...
   30:  jump *label5 always 0 0                                      case page
        label *label6                                                ...
   31:  jump *label8 notEqual :page 2                                ...
   32:  sensor *tmp13 :block @totalPower                             println("totalPower: ",         floor(block.@totalPower));
   33:  op floor *tmp14 *tmp13 0                                     ...
   34:  print "power:\ntotalPower: "                                 ...
   35:  print *tmp14                                                 ...
   36:  sensor *tmp15 :block @powerCapacity                          println("powerCapacity: ",      block.@powerCapacity);
   37:  print "\npowerCapacity: "                                    ...
   38:  print *tmp15                                                 ...
   39:  sensor *tmp16 :block @powerNetStored                         println("powerNetStored: ",     floor(block.@powerNetStored));
   40:  op floor *tmp17 *tmp16 0                                     ...
   41:  print "\npowerNetStored: "                                   ...
   42:  print *tmp17                                                 ...
   43:  sensor *tmp18 :block @powerNetCapacity                       println("powerNetCapacity: ",   block.@powerNetCapacity);
   44:  print "\npowerNetCapacity: "                                 ...
   45:  print *tmp18                                                 ...
   46:  sensor *tmp19 :block @powerNetIn                             println("powerNetIn: ",         floor(block.@powerNetIn));
   47:  op floor *tmp20 *tmp19 0                                     ...
   48:  print "\npowerNetIn: "                                       ...
   49:  print *tmp20                                                 ...
   50:  sensor *tmp21 :block @powerNetOut                            println("powerNetOut: ",        floor(block.@powerNetOut));
   51:  op floor *tmp22 *tmp21 0                                     ...
   52:  print "\npowerNetOut: "                                      ...
   53:  print *tmp22                                                 ...
   54:  print "\n"                                                   ...
   55:  jump *label5 always 0 0                                      case page
        label *label8                                                ...
   56:  jump *label10 notEqual :page 3                               ...
   57:  sensor *tmp23 :block @ammo                                   println("ammo: ",               block.@ammo);
   58:  print "combat:\nammo: "                                      ...
   59:  print *tmp23                                                 ...
   60:  sensor *tmp24 :block @ammoCapacity                           println("ammoCapacity: ",       block.@ammoCapacity);
   61:  print "\nammoCapacity: "                                     ...
   62:  print *tmp24                                                 ...
   63:  sensor *tmp25 :block @health                                 println("health: ",             block.@health);
   64:  print "\nhealth: "                                           ...
   65:  print *tmp25                                                 ...
   66:  sensor *tmp26 :block @maxHealth                              println("maxHealth: ",          block.@maxHealth);
   67:  print "\nmaxHealth: "                                        ...
   68:  print *tmp26                                                 ...
   69:  print "\n"                                                   ...
   70:  jump *label5 always 0 0                                      case page
        label *label10                                               ...
   71:  jump *label12 notEqual :page 4                               ...
   72:  sensor *tmp27 :block @heat                                   println("heat: ",               block.@heat);
   73:  print "status:\nheat: "                                      ...
   74:  print *tmp27                                                 ...
   75:  sensor *tmp28 :block @efficiency                             println("efficiency: ",         block.@efficiency);
   76:  print "\nefficiency: "                                       ...
   77:  print *tmp28                                                 ...
   78:  sensor *tmp29 :block @timescale                              println("timescale: ",          block.@timescale);
   79:  print "\ntimescale: "                                        ...
   80:  print *tmp29                                                 ...
   81:  sensor *tmp30 :block @dead                                   println("dead: ",               block.@dead);
   82:  print "\ndead: "                                             ...
   83:  print *tmp30                                                 ...
   84:  sensor *tmp31 :block @range                                  println("range: ",              block.@range);
   85:  print "\nrange: "                                            ...
   86:  print *tmp31                                                 ...
   87:  print "\n"                                                   ...
   88:  jump *label5 always 0 0                                      case page
        label *label12                                               ...
   89:  jump *label14 notEqual :page 5                               ...
   90:  sensor *tmp32 :block @rotation                               println("rotation: ",           block.@rotation);
   91:  print "position:\nrotation: "                                ...
   92:  print *tmp32                                                 ...
   93:  sensor *tmp33 :block @x                                      println("x: ",                  block.@x);
   94:  print "\nx: "                                                ...
   95:  print *tmp33                                                 ...
   96:  sensor *tmp34 :block @y                                      println("y: ",                  block.@y);
   97:  print "\ny: "                                                ...
   98:  print *tmp34                                                 ...
   99:  sensor *tmp35 :block @size                                   println("size: ",               block.@size);
  100:  print "\nsize: "                                             ...
  101:  print *tmp35                                                 ...
  102:  print "\n"                                                   ...
  103:  jump *label5 always 0 0                                      case page
        label *label14                                               ...
  104:  jump *label16 notEqual :page 6                               ...
  105:  sensor *tmp36 :block @shootX                                 println("shootX: ",             block.@shootX);
  106:  print "unit:\nshootX: "                                      ...
  107:  print *tmp36                                                 ...
  108:  sensor *tmp37 :block @shootY                                 println("shootY: ",             block.@shootY);
  109:  print "\nshootY: "                                           ...
  110:  print *tmp37                                                 ...
  111:  sensor *tmp38 :block @shooting                               println("shooting: ",           block.@shooting);
  112:  print "\nshooting: "                                         ...
  113:  print *tmp38                                                 ...
  114:  sensor *tmp39 :block @boosting                               println("boosting: ",           block.@boosting);
  115:  print "\nboosting: "                                         ...
  116:  print *tmp39                                                 ...
  117:  sensor *tmp40 :block @mineX                                  println("mineX: ",              block.@mineX);
  118:  print "\nmineX: "                                            ...
  119:  print *tmp40                                                 ...
  120:  sensor *tmp41 :block @mineY                                  println("mineY: ",              block.@mineY);
  121:  print "\nmineY: "                                            ...
  122:  print *tmp41                                                 ...
  123:  sensor *tmp42 :block @mining                                 println("mining: ",             block.@mining);
  124:  print "\nmining: "                                           ...
  125:  print *tmp42                                                 ...
  126:  sensor *tmp43 :block @payloadCount                           println("payloadCount: ",       block.@payloadCount);
  127:  print "\npayloadCount: "                                     ...
  128:  print *tmp43                                                 ...
  129:  sensor *tmp44 :block @payloadType                            println("payloadType: ",        block.@payloadType);
  130:  print "\npayloadType: "                                      ...
  131:  print *tmp44                                                 ...
  132:  sensor *tmp45 :block @controlled                             println("controlled: ",         block.@controlled);
  133:  print "\ncontrolled: "                                       ...
  134:  print *tmp45                                                 ...
  135:  sensor *tmp46 :block @controller                             println("controller: ",         block.@controller);
  136:  print "\ncontroller: "                                       ...
  137:  print *tmp46                                                 ...
  138:  print "\n"                                                   ...
  139:  jump *label5 always 0 0                                      case page
        label *label16                                               ...
  140:  jump *label18 notEqual :page 7                               ...
  141:  sensor *tmp47 :block @team                                   println("team: ",               block.@team);
  142:  print "other:\nteam: "                                       ...
  143:  print *tmp47                                                 ...
  144:  print "\ntype: "                                             println("type: ",               block.@type);
  145:  print *tmp4                                                  ...
  146:  sensor *tmp49 :block @flag                                   println("flag: ",               block.@flag);
  147:  print "\nflag: "                                             ...
  148:  print *tmp49                                                 ...
  149:  sensor *tmp50 :block @name                                   println("name: ",               block.@name);
  150:  print "\nname: "                                             ...
  151:  print *tmp50                                                 ...
  152:  sensor *tmp51 :block @config                                 println("config: ",             block.@config);
  153:  print "\nconfig: "                                           ...
  154:  print *tmp51                                                 ...
  155:  sensor *tmp52 :block @enabled                                println("enabled: ",            block.@enabled);
  156:  print "\nenabled: "                                          ...
  157:  print *tmp52                                                 ...
  158:  sensor *tmp53 :block @configure                              println("configure: ",          block.@configure);
  159:  print "\nconfigure: "                                        ...
  160:  print *tmp53                                                 ...
  161:  print "\n"                                                   ...
        label *label18                                               case page
        label *label5                                                ...
        label *label4                                                if block.@dead === 0 then
  162:  printflush message1                                          printflush(message1);
  163:  sensor *tmp54 switch1 @enabled                               if switch1.@enabled then
  164:  jump *label0 equal *tmp54 false                              ...
  165:  jump *label22 notEqual :page 7                               page = page == NUM_PAGES ? 1 : page + 1;
  166:  set :page 1                                                  ...
  167:  jump *label23 always 0 0                                     ...
        label *label22                                               ...
  168:  op add :page :page 1                                         ...
        label *label23                                               ...
  169:  control enabled switch1 false 0 0 0                          switch1.enabled = false;
  170:  jump *label0 always 0 0                                      while true do


Performance: parsed in 134 ms, compiled in 186 ms, optimized in 147 ms, run in 3 ms.
Error connecting to Mlog Watcher: Connection refused: connect
  - make sure Mindustry with active Mlog Watcher mod is running
  - verify Mlog Watcher listens on port 9992

Program output (6 steps):
Property detector - page 1/7

Execution exception at instruction 5: sensor *tmp1 :block @dead:
Instruction not supported by Mindcode emulator.
(Use the '#set err-unsupported-opcode = false;' directive or the '--err-unsupported-opcode false' command line option to ignore this exception.)
