   253 instructions before optimizations.
     2 instructions eliminated by Temp Variables Elimination.
     1 instructions eliminated by Case Expression Optimization.
    13 instructions eliminated by Dead Code Elimination (2 passes, 5 iterations).
     1 instructions eliminated by Jump Normalization (3 iterations).
     1 instructions eliminated by Jump Optimization (3 iterations).
     2 instructions eliminated by Single Step Elimination (4 iterations).
     1 instructions eliminated by If Expression Optimization (2 iterations).
     1 instructions modified by Data Flow Optimization (3 iterations).
     7 instructions eliminated by Jump Straightening (3 iterations).
     8 instructions updated by JumpThreading.
     1 instructions eliminated by Unreachable Code Elimination.
    52 instructions eliminated by Print Merging.
   172 instructions after optimizations.

Modifications by Initial phase, Case Expression Optimization, iteration 1 (-1 instructions):
 
    13 sensor *tmp4 :block @type
    14 print *tmp4
    15 print " - "
-    * set *tmp6 :page
-    * jump *label7 equal *tmp6 1
+   16 jump *label7 equal :page 1
    17 jump *label6 always
    18 label *label7
    19 print "contents:"
 
    42 set *tmp5 *tmp12
    43 jump *label5 always
    44 label *label6
-    * jump *label9 equal *tmp6 2
+   45 jump *label9 equal :page 2
    46 jump *label8 always
    47 label *label9
    48 print "power:"
 
    78 set *tmp5 *tmp22
    79 jump *label5 always
    80 label *label8
-    * jump *label11 equal *tmp6 3
+   81 jump *label11 equal :page 3
    82 jump *label10 always
    83 label *label11
    84 print "combat:"
 
   102 set *tmp5 *tmp26
   103 jump *label5 always
   104 label *label10
-    * jump *label13 equal *tmp6 4
+  105 jump *label13 equal :page 4
   106 jump *label12 always
   107 label *label13
   108 print "status:"
 
   130 set *tmp5 *tmp31
   131 jump *label5 always
   132 label *label12
-    * jump *label15 equal *tmp6 5
+  133 jump *label15 equal :page 5
   134 jump *label14 always
   135 label *label15
   136 print "position:"
 
   154 set *tmp5 *tmp35
   155 jump *label5 always
   156 label *label14
-    * jump *label17 equal *tmp6 6
+  157 jump *label17 equal :page 6
   158 jump *label16 always
   159 label *label17
   160 print "unit:"
 
   206 set *tmp5 *tmp46
   207 jump *label5 always
   208 label *label16
-    * jump *label19 equal *tmp6 7
+  209 jump *label19 equal :page 7
   210 jump *label18 always
   211 label *label19
   212 print "other:"

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-4 instructions):
 
   244 label *label18
   245 set *tmp5 null
   246 label *label5
-    * set *tmp3 *tmp5
   247 jump *label4 always
   248 label *label3
   249 print "No linked block found."
   250 print "\n"
-    * set *tmp3 "No linked block found."
   251 label *label4
   252 printflush message1
   253 sensor *tmp54 switch1 @enabled
 
   262 label *label23
   263 set :page *tmp57
   264 control enabled switch1 false
-    * set *tmp55 false
   265 jump *label21 always
   266 label *label20
-    * set *tmp55 null
   267 label *label21
   268 label *label1
   269 jump *label0 always

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-8 instructions):
 
    39 print "liquidCapacity: "
    40 print *tmp12
    41 print "\n"
-    * set *tmp5 *tmp12
    42 jump *label5 always
    43 label *label6
    44 jump *label9 equal :page 2
 
    74 print "powerNetOut: "
    75 print *tmp22
    76 print "\n"
-    * set *tmp5 *tmp22
    77 jump *label5 always
    78 label *label8
    79 jump *label11 equal :page 3
 
    97 print "maxHealth: "
    98 print *tmp26
    99 print "\n"
-    * set *tmp5 *tmp26
   100 jump *label5 always
   101 label *label10
   102 jump *label13 equal :page 4
 
   124 print "range: "
   125 print *tmp31
   126 print "\n"
-    * set *tmp5 *tmp31
   127 jump *label5 always
   128 label *label12
   129 jump *label15 equal :page 5
 
   147 print "size: "
   148 print *tmp35
   149 print "\n"
-    * set *tmp5 *tmp35
   150 jump *label5 always
   151 label *label14
   152 jump *label17 equal :page 6
 
   198 print "controller: "
   199 print *tmp46
   200 print "\n"
-    * set *tmp5 *tmp46
   201 jump *label5 always
   202 label *label16
   203 jump *label19 equal :page 7
 
   233 print "configure: "
   234 print *tmp53
   235 print "\n"
-    * set *tmp5 *tmp53
   236 jump *label5 always
   237 label *label18
-    * set *tmp5 null
   238 label *label5
   239 jump *label4 always
   240 label *label3

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-2 instructions):
     0 set :page 1
     1 label *label0
     2 jump *label2 equal true false
-    * getlink *tmp0 2
-    * set :block *tmp0
+    3 getlink :block 2
     4 print "Property detector - page "
     5 print :page
     6 print "/"
 
   248 set *tmp57 1
   249 jump *label23 always
   250 label *label22
-    * op add *tmp58 :page 1
-    * set *tmp57 *tmp58
+  251 op add *tmp57 :page 1
   252 label *label23
   253 set :page *tmp57
   254 control enabled switch1 false

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-1 instructions):
     0 set :page 1
     1 label *label0
-    * jump *label2 equal true false
     2 getlink :block 2
     3 print "Property detector - page "
     4 print :page

Modifications by Iterated phase, Jump Straightening, pass 1, iteration 1 (-7 instructions):
 
    11 sensor *tmp4 :block @type
    12 print *tmp4
    13 print " - "
-    * jump *label7 equal :page 1
-    * jump *label6 always
+   14 jump *label6 notEqual :page 1
    15 label *label7
    16 print "contents:"
    17 print "\n"
 
    38 print "\n"
    39 jump *label5 always
    40 label *label6
-    * jump *label9 equal :page 2
-    * jump *label8 always
+   41 jump *label8 notEqual :page 2
    42 label *label9
    43 print "power:"
    44 print "\n"
 
    72 print "\n"
    73 jump *label5 always
    74 label *label8
-    * jump *label11 equal :page 3
-    * jump *label10 always
+   75 jump *label10 notEqual :page 3
    76 label *label11
    77 print "combat:"
    78 print "\n"
 
    94 print "\n"
    95 jump *label5 always
    96 label *label10
-    * jump *label13 equal :page 4
-    * jump *label12 always
+   97 jump *label12 notEqual :page 4
    98 label *label13
    99 print "status:"
   100 print "\n"
 
   120 print "\n"
   121 jump *label5 always
   122 label *label12
-    * jump *label15 equal :page 5
-    * jump *label14 always
+  123 jump *label14 notEqual :page 5
   124 label *label15
   125 print "position:"
   126 print "\n"
 
   142 print "\n"
   143 jump *label5 always
   144 label *label14
-    * jump *label17 equal :page 6
-    * jump *label16 always
+  145 jump *label16 notEqual :page 6
   146 label *label17
   147 print "unit:"
   148 print "\n"
 
   192 print "\n"
   193 jump *label5 always
   194 label *label16
-    * jump *label19 equal :page 7
-    * jump *label18 always
+  195 jump *label18 notEqual :page 7
   196 label *label19
   197 print "other:"
   198 print "\n"

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-1 instructions):
 
   235 printflush message1
   236 sensor *tmp54 switch1 @enabled
   237 jump *label20 equal *tmp54 false
-    * op equal *tmp56 :page 7
-    * jump *label22 equal *tmp56 false
+  238 jump *label22 notEqual :page 7
   239 set *tmp57 1
   240 jump *label23 always
   241 label *label22

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-2 instructions):
 
   224 print "configure: "
   225 print *tmp53
   226 print "\n"
-    * jump *label5 always
   227 label *label18
   228 label *label5
   229 jump *label4 always
 
   242 label *label23
   243 set :page *tmp57
   244 control enabled switch1 false
-    * jump *label21 always
   245 label *label20
   246 label *label21
   247 label *label1

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
   202 print "\n"
   203 sensor *tmp48 :block @type
   204 print "type: "
-    * print *tmp48
+  205 print *tmp4
   206 print "\n"
   207 sensor *tmp49 :block @flag
   208 print "flag: "

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 1 (-1 instructions):
 
   235 sensor *tmp54 switch1 @enabled
   236 jump *label20 equal *tmp54 false
   237 jump *label22 notEqual :page 7
-    * set *tmp57 1
+  238 set :page 1
   239 jump *label23 always
   240 label *label22
-    * op add *tmp57 :page 1
+  241 op add :page :page 1
   242 label *label23
-    * set :page *tmp57
   243 control enabled switch1 false
   244 label *label20
   245 label *label21

Modifications by Final phase, Jump Threading, iteration 1:
 
    36 print "liquidCapacity: "
    37 print *tmp12
    38 print "\n"
-    * jump *label5 always
+   39 jump *label4 always
    40 label *label6
    41 jump *label8 notEqual :page 2
    42 label *label9
 
    70 print "powerNetOut: "
    71 print *tmp22
    72 print "\n"
-    * jump *label5 always
+   73 jump *label4 always
    74 label *label8
    75 jump *label10 notEqual :page 3
    76 label *label11
 
    92 print "maxHealth: "
    93 print *tmp26
    94 print "\n"
-    * jump *label5 always
+   95 jump *label4 always
    96 label *label10
    97 jump *label12 notEqual :page 4
    98 label *label13
 
   118 print "range: "
   119 print *tmp31
   120 print "\n"
-    * jump *label5 always
+  121 jump *label4 always
   122 label *label12
   123 jump *label14 notEqual :page 5
   124 label *label15
 
   140 print "size: "
   141 print *tmp35
   142 print "\n"
-    * jump *label5 always
+  143 jump *label4 always
   144 label *label14
   145 jump *label16 notEqual :page 6
   146 label *label17
 
   190 print "controller: "
   191 print *tmp46
   192 print "\n"
-    * jump *label5 always
+  193 jump *label4 always
   194 label *label16
-    * jump *label18 notEqual :page 7
+  195 jump *label4 notEqual :page 7
   196 label *label19
   197 print "other:"
   198 print "\n"
 
   233 label *label4
   234 printflush message1
   235 sensor *tmp54 switch1 @enabled
-    * jump *label20 equal *tmp54 false
+  236 jump *label0 equal *tmp54 false
   237 jump *label22 notEqual :page 7
   238 set :page 1
   239 jump *label23 always

Modifications by Final phase, Unreachable Code Elimination, iteration 1 (-1 instructions):
 
   245 label *label21
   246 label *label1
   247 jump *label0 always
-    * label *label2
-    * end

Modifications by Final phase, Dead Code Elimination, iteration 1 (-1 instructions):
 
   200 print "team: "
   201 print *tmp47
   202 print "\n"
-    * sensor *tmp48 :block @type
   203 print "type: "
   204 print *tmp4
   205 print "\n"

Modifications by Final phase, Print Merging, iteration 1 (-52 instructions):
 
     2 getlink :block 2
     3 print "Property detector - page "
     4 print :page
-    * print "/"
-    * print 7
-    * print "\n"
+    5 print "/7\n"
     6 sensor *tmp1 :block @dead
     7 op strictEqual *tmp2 *tmp1 0
     8 jump *label3 equal *tmp2 false
 
    11 print " - "
    12 jump *label6 notEqual :page 1
    13 label *label7
-    * print "contents:"
-    * print "\n"
    14 sensor *tmp7 :block @totalItems
-    * print "totalItems: "
+   15 print "contents:\ntotalItems: "
    16 print *tmp7
-    * print "\n"
    17 sensor *tmp8 :block @firstItem
-    * print "firstItem: "
+   18 print "\nfirstItem: "
    19 print *tmp8
-    * print "\n"
    20 sensor *tmp9 :block @itemCapacity
-    * print "itemCapacity: "
+   21 print "\nitemCapacity: "
    22 print *tmp9
-    * print "\n"
    23 sensor *tmp10 :block @totalLiquids
    24 op floor *tmp11 *tmp10
-    * print "totalLiquids: "
+   25 print "\ntotalLiquids: "
    26 print *tmp11
-    * print "\n"
    27 sensor *tmp12 :block @liquidCapacity
-    * print "liquidCapacity: "
+   28 print "\nliquidCapacity: "
    29 print *tmp12
    30 print "\n"
    31 jump *label4 always
    32 label *label6
    33 jump *label8 notEqual :page 2
    34 label *label9
-    * print "power:"
-    * print "\n"
    35 sensor *tmp13 :block @totalPower
    36 op floor *tmp14 *tmp13
-    * print "totalPower: "
+   37 print "power:\ntotalPower: "
    38 print *tmp14
-    * print "\n"
    39 sensor *tmp15 :block @powerCapacity
-    * print "powerCapacity: "
+   40 print "\npowerCapacity: "
    41 print *tmp15
-    * print "\n"
    42 sensor *tmp16 :block @powerNetStored
    43 op floor *tmp17 *tmp16
-    * print "powerNetStored: "
+   44 print "\npowerNetStored: "
    45 print *tmp17
-    * print "\n"
    46 sensor *tmp18 :block @powerNetCapacity
-    * print "powerNetCapacity: "
+   47 print "\npowerNetCapacity: "
    48 print *tmp18
-    * print "\n"
    49 sensor *tmp19 :block @powerNetIn
    50 op floor *tmp20 *tmp19
-    * print "powerNetIn: "
+   51 print "\npowerNetIn: "
    52 print *tmp20
-    * print "\n"
    53 sensor *tmp21 :block @powerNetOut
    54 op floor *tmp22 *tmp21
-    * print "powerNetOut: "
+   55 print "\npowerNetOut: "
    56 print *tmp22
    57 print "\n"
    58 jump *label4 always
    59 label *label8
    60 jump *label10 notEqual :page 3
    61 label *label11
-    * print "combat:"
-    * print "\n"
    62 sensor *tmp23 :block @ammo
-    * print "ammo: "
+   63 print "combat:\nammo: "
    64 print *tmp23
-    * print "\n"
    65 sensor *tmp24 :block @ammoCapacity
-    * print "ammoCapacity: "
+   66 print "\nammoCapacity: "
    67 print *tmp24
-    * print "\n"
    68 sensor *tmp25 :block @health
-    * print "health: "
+   69 print "\nhealth: "
    70 print *tmp25
-    * print "\n"
    71 sensor *tmp26 :block @maxHealth
-    * print "maxHealth: "
+   72 print "\nmaxHealth: "
    73 print *tmp26
    74 print "\n"
    75 jump *label4 always
    76 label *label10
    77 jump *label12 notEqual :page 4
    78 label *label13
-    * print "status:"
-    * print "\n"
    79 sensor *tmp27 :block @heat
-    * print "heat: "
+   80 print "status:\nheat: "
    81 print *tmp27
-    * print "\n"
    82 sensor *tmp28 :block @efficiency
-    * print "efficiency: "
+   83 print "\nefficiency: "
    84 print *tmp28
-    * print "\n"
    85 sensor *tmp29 :block @timescale
-    * print "timescale: "
+   86 print "\ntimescale: "
    87 print *tmp29
-    * print "\n"
    88 sensor *tmp30 :block @dead
-    * print "dead: "
+   89 print "\ndead: "
    90 print *tmp30
-    * print "\n"
    91 sensor *tmp31 :block @range
-    * print "range: "
+   92 print "\nrange: "
    93 print *tmp31
    94 print "\n"
    95 jump *label4 always
    96 label *label12
    97 jump *label14 notEqual :page 5
    98 label *label15
-    * print "position:"
-    * print "\n"
    99 sensor *tmp32 :block @rotation
-    * print "rotation: "
+  100 print "position:\nrotation: "
   101 print *tmp32
-    * print "\n"
   102 sensor *tmp33 :block @x
-    * print "x: "
+  103 print "\nx: "
   104 print *tmp33
-    * print "\n"
   105 sensor *tmp34 :block @y
-    * print "y: "
+  106 print "\ny: "
   107 print *tmp34
-    * print "\n"
   108 sensor *tmp35 :block @size
-    * print "size: "
+  109 print "\nsize: "
   110 print *tmp35
   111 print "\n"
   112 jump *label4 always
   113 label *label14
   114 jump *label16 notEqual :page 6
   115 label *label17
-    * print "unit:"
-    * print "\n"
   116 sensor *tmp36 :block @shootX
-    * print "shootX: "
+  117 print "unit:\nshootX: "
   118 print *tmp36
-    * print "\n"
   119 sensor *tmp37 :block @shootY
-    * print "shootY: "
+  120 print "\nshootY: "
   121 print *tmp37
-    * print "\n"
   122 sensor *tmp38 :block @shooting
-    * print "shooting: "
+  123 print "\nshooting: "
   124 print *tmp38
-    * print "\n"
   125 sensor *tmp39 :block @boosting
-    * print "boosting: "
+  126 print "\nboosting: "
   127 print *tmp39
-    * print "\n"
   128 sensor *tmp40 :block @mineX
-    * print "mineX: "
+  129 print "\nmineX: "
   130 print *tmp40
-    * print "\n"
   131 sensor *tmp41 :block @mineY
-    * print "mineY: "
+  132 print "\nmineY: "
   133 print *tmp41
-    * print "\n"
   134 sensor *tmp42 :block @mining
-    * print "mining: "
+  135 print "\nmining: "
   136 print *tmp42
-    * print "\n"
   137 sensor *tmp43 :block @payloadCount
-    * print "payloadCount: "
+  138 print "\npayloadCount: "
   139 print *tmp43
-    * print "\n"
   140 sensor *tmp44 :block @payloadType
-    * print "payloadType: "
+  141 print "\npayloadType: "
   142 print *tmp44
-    * print "\n"
   143 sensor *tmp45 :block @controlled
-    * print "controlled: "
+  144 print "\ncontrolled: "
   145 print *tmp45
-    * print "\n"
   146 sensor *tmp46 :block @controller
-    * print "controller: "
+  147 print "\ncontroller: "
   148 print *tmp46
   149 print "\n"
   150 jump *label4 always
   151 label *label16
   152 jump *label4 notEqual :page 7
   153 label *label19
-    * print "other:"
-    * print "\n"
   154 sensor *tmp47 :block @team
-    * print "team: "
+  155 print "other:\nteam: "
   156 print *tmp47
-    * print "\n"
-    * print "type: "
+  157 print "\ntype: "
   158 print *tmp4
-    * print "\n"
   159 sensor *tmp49 :block @flag
-    * print "flag: "
+  160 print "\nflag: "
   161 print *tmp49
-    * print "\n"
   162 sensor *tmp50 :block @name
-    * print "name: "
+  163 print "\nname: "
   164 print *tmp50
-    * print "\n"
   165 sensor *tmp51 :block @config
-    * print "config: "
+  166 print "\nconfig: "
   167 print *tmp51
-    * print "\n"
   168 sensor *tmp52 :block @enabled
-    * print "enabled: "
+  169 print "\nenabled: "
   170 print *tmp52
-    * print "\n"
   171 sensor *tmp53 :block @configure
-    * print "configure: "
+  172 print "\nconfigure: "
   173 print *tmp53
   174 print "\n"
   175 label *label18
   176 label *label5
   177 jump *label4 always
   178 label *label3
-    * print "No linked block found."
-    * print "\n"
+  179 print "No linked block found.\n"
   180 label *label4
   181 printflush message1
   182 sensor *tmp54 switch1 @enabled

Final code before resolving virtual instructions:

    0:  set :page 1                                                  page = 1;
        label *label0                                                while true do
    1:  getlink :block 2                                             block = getlink(2);  // First two links are a switch and a message
    2:  print "Property detector - page "                            println($"Property detector - page $page/$NUM_PAGES");
    3:  print :page                                                  ...
    4:  print "/7\n"                                                 ...
    5:  sensor *tmp1 :block @dead                                    if block.@dead === 0 then
    6:  op strictEqual *tmp2 *tmp1 0                                 ...
    7:  jump *label3 equal *tmp2 false                               ...
    8:  sensor *tmp4 :block @type                                    print(block.@type, " - ");
    9:  print *tmp4                                                  ...
   10:  print " - "                                                  ...
   11:  jump *label6 notEqual :page 1                                case page
   12:  sensor *tmp7 :block @totalItems                              println("totalItems: ",         block.@totalItems);
   13:  print "contents:\ntotalItems: "                              ...
   14:  print *tmp7                                                  ...
   15:  sensor *tmp8 :block @firstItem                               println("firstItem: ",          block.@firstItem);
   16:  print "\nfirstItem: "                                        ...
   17:  print *tmp8                                                  ...
   18:  sensor *tmp9 :block @itemCapacity                            println("itemCapacity: ",       block.@itemCapacity);
   19:  print "\nitemCapacity: "                                     ...
   20:  print *tmp9                                                  ...
   21:  sensor *tmp10 :block @totalLiquids                           println("totalLiquids: ",       floor(block.@totalLiquids));
   22:  op floor *tmp11 *tmp10 0                                     ...
   23:  print "\ntotalLiquids: "                                     ...
   24:  print *tmp11                                                 ...
   25:  sensor *tmp12 :block @liquidCapacity                         println("liquidCapacity: ",     block.@liquidCapacity);
   26:  print "\nliquidCapacity: "                                   ...
   27:  print *tmp12                                                 ...
   28:  print "\n"                                                   ...
   29:  jump *label4 always 0 0                                      case page
        label *label6                                                ...
   30:  jump *label8 notEqual :page 2                                ...
   31:  sensor *tmp13 :block @totalPower                             println("totalPower: ",         floor(block.@totalPower));
   32:  op floor *tmp14 *tmp13 0                                     ...
   33:  print "power:\ntotalPower: "                                 ...
   34:  print *tmp14                                                 ...
   35:  sensor *tmp15 :block @powerCapacity                          println("powerCapacity: ",      block.@powerCapacity);
   36:  print "\npowerCapacity: "                                    ...
   37:  print *tmp15                                                 ...
   38:  sensor *tmp16 :block @powerNetStored                         println("powerNetStored: ",     floor(block.@powerNetStored));
   39:  op floor *tmp17 *tmp16 0                                     ...
   40:  print "\npowerNetStored: "                                   ...
   41:  print *tmp17                                                 ...
   42:  sensor *tmp18 :block @powerNetCapacity                       println("powerNetCapacity: ",   block.@powerNetCapacity);
   43:  print "\npowerNetCapacity: "                                 ...
   44:  print *tmp18                                                 ...
   45:  sensor *tmp19 :block @powerNetIn                             println("powerNetIn: ",         floor(block.@powerNetIn));
   46:  op floor *tmp20 *tmp19 0                                     ...
   47:  print "\npowerNetIn: "                                       ...
   48:  print *tmp20                                                 ...
   49:  sensor *tmp21 :block @powerNetOut                            println("powerNetOut: ",        floor(block.@powerNetOut));
   50:  op floor *tmp22 *tmp21 0                                     ...
   51:  print "\npowerNetOut: "                                      ...
   52:  print *tmp22                                                 ...
   53:  print "\n"                                                   ...
   54:  jump *label4 always 0 0                                      case page
        label *label8                                                ...
   55:  jump *label10 notEqual :page 3                               ...
   56:  sensor *tmp23 :block @ammo                                   println("ammo: ",               block.@ammo);
   57:  print "combat:\nammo: "                                      ...
   58:  print *tmp23                                                 ...
   59:  sensor *tmp24 :block @ammoCapacity                           println("ammoCapacity: ",       block.@ammoCapacity);
   60:  print "\nammoCapacity: "                                     ...
   61:  print *tmp24                                                 ...
   62:  sensor *tmp25 :block @health                                 println("health: ",             block.@health);
   63:  print "\nhealth: "                                           ...
   64:  print *tmp25                                                 ...
   65:  sensor *tmp26 :block @maxHealth                              println("maxHealth: ",          block.@maxHealth);
   66:  print "\nmaxHealth: "                                        ...
   67:  print *tmp26                                                 ...
   68:  print "\n"                                                   ...
   69:  jump *label4 always 0 0                                      case page
        label *label10                                               ...
   70:  jump *label12 notEqual :page 4                               ...
   71:  sensor *tmp27 :block @heat                                   println("heat: ",               block.@heat);
   72:  print "status:\nheat: "                                      ...
   73:  print *tmp27                                                 ...
   74:  sensor *tmp28 :block @efficiency                             println("efficiency: ",         block.@efficiency);
   75:  print "\nefficiency: "                                       ...
   76:  print *tmp28                                                 ...
   77:  sensor *tmp29 :block @timescale                              println("timescale: ",          block.@timescale);
   78:  print "\ntimescale: "                                        ...
   79:  print *tmp29                                                 ...
   80:  sensor *tmp30 :block @dead                                   println("dead: ",               block.@dead);
   81:  print "\ndead: "                                             ...
   82:  print *tmp30                                                 ...
   83:  sensor *tmp31 :block @range                                  println("range: ",              block.@range);
   84:  print "\nrange: "                                            ...
   85:  print *tmp31                                                 ...
   86:  print "\n"                                                   ...
   87:  jump *label4 always 0 0                                      case page
        label *label12                                               ...
   88:  jump *label14 notEqual :page 5                               ...
   89:  sensor *tmp32 :block @rotation                               println("rotation: ",           block.@rotation);
   90:  print "position:\nrotation: "                                ...
   91:  print *tmp32                                                 ...
   92:  sensor *tmp33 :block @x                                      println("x: ",                  block.@x);
   93:  print "\nx: "                                                ...
   94:  print *tmp33                                                 ...
   95:  sensor *tmp34 :block @y                                      println("y: ",                  block.@y);
   96:  print "\ny: "                                                ...
   97:  print *tmp34                                                 ...
   98:  sensor *tmp35 :block @size                                   println("size: ",               block.@size);
   99:  print "\nsize: "                                             ...
  100:  print *tmp35                                                 ...
  101:  print "\n"                                                   ...
  102:  jump *label4 always 0 0                                      case page
        label *label14                                               ...
  103:  jump *label16 notEqual :page 6                               ...
  104:  sensor *tmp36 :block @shootX                                 println("shootX: ",             block.@shootX);
  105:  print "unit:\nshootX: "                                      ...
  106:  print *tmp36                                                 ...
  107:  sensor *tmp37 :block @shootY                                 println("shootY: ",             block.@shootY);
  108:  print "\nshootY: "                                           ...
  109:  print *tmp37                                                 ...
  110:  sensor *tmp38 :block @shooting                               println("shooting: ",           block.@shooting);
  111:  print "\nshooting: "                                         ...
  112:  print *tmp38                                                 ...
  113:  sensor *tmp39 :block @boosting                               println("boosting: ",           block.@boosting);
  114:  print "\nboosting: "                                         ...
  115:  print *tmp39                                                 ...
  116:  sensor *tmp40 :block @mineX                                  println("mineX: ",              block.@mineX);
  117:  print "\nmineX: "                                            ...
  118:  print *tmp40                                                 ...
  119:  sensor *tmp41 :block @mineY                                  println("mineY: ",              block.@mineY);
  120:  print "\nmineY: "                                            ...
  121:  print *tmp41                                                 ...
  122:  sensor *tmp42 :block @mining                                 println("mining: ",             block.@mining);
  123:  print "\nmining: "                                           ...
  124:  print *tmp42                                                 ...
  125:  sensor *tmp43 :block @payloadCount                           println("payloadCount: ",       block.@payloadCount);
  126:  print "\npayloadCount: "                                     ...
  127:  print *tmp43                                                 ...
  128:  sensor *tmp44 :block @payloadType                            println("payloadType: ",        block.@payloadType);
  129:  print "\npayloadType: "                                      ...
  130:  print *tmp44                                                 ...
  131:  sensor *tmp45 :block @controlled                             println("controlled: ",         block.@controlled);
  132:  print "\ncontrolled: "                                       ...
  133:  print *tmp45                                                 ...
  134:  sensor *tmp46 :block @controller                             println("controller: ",         block.@controller);
  135:  print "\ncontroller: "                                       ...
  136:  print *tmp46                                                 ...
  137:  print "\n"                                                   ...
  138:  jump *label4 always 0 0                                      case page
        label *label16                                               ...
  139:  jump *label4 notEqual :page 7                                ...
  140:  sensor *tmp47 :block @team                                   println("team: ",               block.@team);
  141:  print "other:\nteam: "                                       ...
  142:  print *tmp47                                                 ...
  143:  print "\ntype: "                                             println("type: ",               block.@type);
  144:  print *tmp4                                                  ...
  145:  sensor *tmp49 :block @flag                                   println("flag: ",               block.@flag);
  146:  print "\nflag: "                                             ...
  147:  print *tmp49                                                 ...
  148:  sensor *tmp50 :block @name                                   println("name: ",               block.@name);
  149:  print "\nname: "                                             ...
  150:  print *tmp50                                                 ...
  151:  sensor *tmp51 :block @config                                 println("config: ",             block.@config);
  152:  print "\nconfig: "                                           ...
  153:  print *tmp51                                                 ...
  154:  sensor *tmp52 :block @enabled                                println("enabled: ",            block.@enabled);
  155:  print "\nenabled: "                                          ...
  156:  print *tmp52                                                 ...
  157:  sensor *tmp53 :block @configure                              println("configure: ",          block.@configure);
  158:  print "\nconfigure: "                                        ...
  159:  print *tmp53                                                 ...
  160:  print "\n"                                                   ...
  161:  jump *label4 always 0 0                                      if block.@dead === 0 then
        label *label3                                                ...
  162:  print "No linked block found.\n"                             println("No linked block found.");
        label *label4                                                if block.@dead === 0 then
  163:  printflush message1                                          printflush(message1);
  164:  sensor *tmp54 switch1 @enabled                               if switch1.@enabled then
  165:  jump *label0 equal *tmp54 false                              ...
  166:  jump *label22 notEqual :page 7                               page = page == NUM_PAGES ? 1 : page + 1;
  167:  set :page 1                                                  ...
  168:  jump *label23 always 0 0                                     ...
        label *label22                                               ...
  169:  op add :page :page 1                                         ...
        label *label23                                               ...
  170:  control enabled switch1 false 0 0 0                          switch1.enabled = false;
  171:  jump *label0 always 0 0                                      while true do


Performance: parsed in 134 ms, compiled in 198 ms, optimized in 145 ms, run in 3 ms.

Compiled mlog code was sent to Mlog Watcher.
  No response from Mlog Watcher - maybe an old version is installed?

Program output (6 steps):
Property detector - page 1/7

Execution exception at instruction 5: sensor *tmp1 :block @dead:
Instruction not supported by Mindcode emulator.
(Use the '#set err-unsupported-opcode = false;' directive or the '--err-unsupported-opcode false' command line option to ignore this exception.)
