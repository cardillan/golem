   253 instructions before optimizations.
     2 instructions eliminated by Temp Variables Elimination (5 iterations).
     1 instructions eliminated by Case Expression Optimization.
    12 instructions eliminated by Dead Code Elimination (5 iterations).
     1 instructions eliminated by Jump Normalization (4 iterations).
     1 instructions eliminated by Condition Optimization (5 iterations).
     2 instructions eliminated by Single Step Elimination (5 iterations).
     1 instructions eliminated by If Expression Optimization (2 iterations).
     1 instructions eliminated by Data Flow Optimization (5 iterations).
     2 instructions added by Case Switching (3 iterations).
     1 case expressions converted to switched jumps by Case Switching.
     7 instructions eliminated by Jump Straightening (5 iterations).
     9 instructions updated by Jump Threading.
     1 instructions eliminated by Unreachable Code Elimination (2 iterations).
    52 instructions eliminated by Print Merging.
   174 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 775):
  o Convert case at line 9:9 (segments: 4)                       size    +1, benefit        5.4, efficiency      5.357
  * Convert case at line 9:9 (segments: 7)                       size    +2, benefit       10.7, efficiency      5.357 (+2 instructions)

Modifications by Initial phase, Case Expression Optimization, iteration 1 (-1 instructions):
 
    13 sensor *tmp4 :block @type
    14 print *tmp4
    15 print " - "
-    * set *tmp6 :page
-    * jump *label7 equal *tmp6 1
+   16 jump *label7 equal :page 1
    17 jump *label6 always
    18 label *label7
    19 print "contents:"
 
    42 set *tmp5 *tmp12
    43 jump *label5 always
    44 label *label6
-    * jump *label9 equal *tmp6 2
+   45 jump *label9 equal :page 2
    46 jump *label8 always
    47 label *label9
    48 print "power:"
 
    78 set *tmp5 *tmp22
    79 jump *label5 always
    80 label *label8
-    * jump *label11 equal *tmp6 3
+   81 jump *label11 equal :page 3
    82 jump *label10 always
    83 label *label11
    84 print "combat:"
 
   102 set *tmp5 *tmp26
   103 jump *label5 always
   104 label *label10
-    * jump *label13 equal *tmp6 4
+  105 jump *label13 equal :page 4
   106 jump *label12 always
   107 label *label13
   108 print "status:"
 
   130 set *tmp5 *tmp31
   131 jump *label5 always
   132 label *label12
-    * jump *label15 equal *tmp6 5
+  133 jump *label15 equal :page 5
   134 jump *label14 always
   135 label *label15
   136 print "position:"
 
   154 set *tmp5 *tmp35
   155 jump *label5 always
   156 label *label14
-    * jump *label17 equal *tmp6 6
+  157 jump *label17 equal :page 6
   158 jump *label16 always
   159 label *label17
   160 print "unit:"
 
   206 set *tmp5 *tmp46
   207 jump *label5 always
   208 label *label16
-    * jump *label19 equal *tmp6 7
+  209 jump *label19 equal :page 7
   210 jump *label18 always
   211 label *label19
   212 print "other:"

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-4 instructions):
 
   244 label *label18
   245 set *tmp5 null
   246 label *label5
-    * set *tmp3 *tmp5
   247 jump *label4 always
   248 label *label3
   249 print "No linked block found."
   250 print "\n"
-    * set *tmp3 "No linked block found."
   251 label *label4
   252 printflush message1
   253 sensor *tmp54 switch1 @enabled
 
   262 label *label23
   263 set :page *tmp57
   264 control enabled switch1 false
-    * set *tmp55 false
   265 jump *label21 always
   266 label *label20
-    * set *tmp55 null
   267 label *label21
   268 label *label1
   269 jump *label0 always

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-8 instructions):
 
    39 print "liquidCapacity: "
    40 print *tmp12
    41 print "\n"
-    * set *tmp5 *tmp12
    42 jump *label5 always
    43 label *label6
    44 jump *label9 equal :page 2
 
    74 print "powerNetOut: "
    75 print *tmp22
    76 print "\n"
-    * set *tmp5 *tmp22
    77 jump *label5 always
    78 label *label8
    79 jump *label11 equal :page 3
 
    97 print "maxHealth: "
    98 print *tmp26
    99 print "\n"
-    * set *tmp5 *tmp26
   100 jump *label5 always
   101 label *label10
   102 jump *label13 equal :page 4
 
   124 print "range: "
   125 print *tmp31
   126 print "\n"
-    * set *tmp5 *tmp31
   127 jump *label5 always
   128 label *label12
   129 jump *label15 equal :page 5
 
   147 print "size: "
   148 print *tmp35
   149 print "\n"
-    * set *tmp5 *tmp35
   150 jump *label5 always
   151 label *label14
   152 jump *label17 equal :page 6
 
   198 print "controller: "
   199 print *tmp46
   200 print "\n"
-    * set *tmp5 *tmp46
   201 jump *label5 always
   202 label *label16
   203 jump *label19 equal :page 7
 
   233 print "solid: "
   234 print *tmp53
   235 print "\n"
-    * set *tmp5 *tmp53
   236 jump *label5 always
   237 label *label18
-    * set *tmp5 null
   238 label *label5
   239 jump *label4 always
   240 label *label3

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-2 instructions):
     0 set :page 1
     1 label *label0
     2 jump *label2 equal true false
-    * getlink *tmp0 2
-    * set :block *tmp0
+    3 getlink :block 2
     4 print "Property detector - page "
     5 print :page
     6 print "/"
 
   248 set *tmp57 1
   249 jump *label23 always
   250 label *label22
-    * op add *tmp58 :page 1
-    * set *tmp57 *tmp58
+  251 op add *tmp57 :page 1
   252 label *label23
   253 set :page *tmp57
   254 control enabled switch1 false

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-1 instructions):
     0 set :page 1
     1 label *label0
-    * jump *label2 equal true false
     2 getlink :block 2
     3 print "Property detector - page "
     4 print :page

Modifications by Iterated phase, Jump Straightening, pass 1, iteration 1 (-7 instructions):
 
    11 sensor *tmp4 :block @type
    12 print *tmp4
    13 print " - "
-    * jump *label7 equal :page 1
-    * jump *label6 always
+   14 jump *label6 notEqual :page 1
    15 label *label7
    16 print "contents:"
    17 print "\n"
 
    38 print "\n"
    39 jump *label5 always
    40 label *label6
-    * jump *label9 equal :page 2
-    * jump *label8 always
+   41 jump *label8 notEqual :page 2
    42 label *label9
    43 print "power:"
    44 print "\n"
 
    72 print "\n"
    73 jump *label5 always
    74 label *label8
-    * jump *label11 equal :page 3
-    * jump *label10 always
+   75 jump *label10 notEqual :page 3
    76 label *label11
    77 print "combat:"
    78 print "\n"
 
    94 print "\n"
    95 jump *label5 always
    96 label *label10
-    * jump *label13 equal :page 4
-    * jump *label12 always
+   97 jump *label12 notEqual :page 4
    98 label *label13
    99 print "status:"
   100 print "\n"
 
   120 print "\n"
   121 jump *label5 always
   122 label *label12
-    * jump *label15 equal :page 5
-    * jump *label14 always
+  123 jump *label14 notEqual :page 5
   124 label *label15
   125 print "position:"
   126 print "\n"
 
   142 print "\n"
   143 jump *label5 always
   144 label *label14
-    * jump *label17 equal :page 6
-    * jump *label16 always
+  145 jump *label16 notEqual :page 6
   146 label *label17
   147 print "unit:"
   148 print "\n"
 
   192 print "\n"
   193 jump *label5 always
   194 label *label16
-    * jump *label19 equal :page 7
-    * jump *label18 always
+  195 jump *label18 notEqual :page 7
   196 label *label19
   197 print "other:"
   198 print "\n"

Modifications by Iterated phase, Condition Optimization, pass 1, iteration 1 (-1 instructions):
 
   235 printflush message1
   236 sensor *tmp54 switch1 @enabled
   237 jump *label20 equal *tmp54 false
-    * op equal *tmp56 :page 7
-    * jump *label22 equal *tmp56 false
+  238 jump *label22 notEqual :page 7
   239 set *tmp57 1
   240 jump *label23 always
   241 label *label22

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-2 instructions):
 
   224 print "solid: "
   225 print *tmp53
   226 print "\n"
-    * jump *label5 always
   227 label *label18
   228 label *label5
   229 jump *label4 always
 
   242 label *label23
   243 set :page *tmp57
   244 control enabled switch1 false
-    * jump *label21 always
   245 label *label20
   246 label *label21
   247 label *label1

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
   202 print "\n"
   203 sensor *tmp48 :block @type
   204 print "type: "
-    * print *tmp48
+  205 print *tmp4
   206 print "\n"
   207 sensor *tmp49 :block @flag
   208 print "flag: "

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-1 instructions):
 
   200 print "team: "
   201 print *tmp47
   202 print "\n"
-    * sensor *tmp48 :block @type
   203 print "type: "
   204 print *tmp4
   205 print "\n"

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 1 (-1 instructions):
 
   234 sensor *tmp54 switch1 @enabled
   235 jump *label20 equal *tmp54 false
   236 jump *label22 notEqual :page 7
-    * set *tmp57 1
+  237 set :page 1
   238 jump *label23 always
   239 label *label22
-    * op add *tmp57 :page 1
+  240 op add :page :page 1
   241 label *label23
-    * set :page *tmp57
   242 control enabled switch1 false
   243 label *label20
   244 label *label21

Modifications by Convert case at line 9:9 (segments: 7) (+2 instructions):
 
    11 sensor *tmp4 :block @type
    12 print *tmp4
    13 print " - "
-    * jump *label6 notEqual :page 1
+   14 jump *label25 greaterThanEq :page 4
+   15 jump *label26 greaterThanEq :page 2
+   16 jump *label24 lessThan :page 1
    17 label *label7
-    * print "contents:"
-    * print "\n"
-    * sensor *tmp7 :block @totalItems
-    * print "totalItems: "
-    * print *tmp7
-    * print "\n"
-    * sensor *tmp8 :block @firstItem
-    * print "firstItem: "
-    * print *tmp8
-    * print "\n"
-    * sensor *tmp9 :block @itemCapacity
-    * print "itemCapacity: "
-    * print *tmp9
-    * print "\n"
-    * sensor *tmp10 :block @totalLiquids
-    * op floor *tmp11 *tmp10
-    * print "totalLiquids: "
-    * print *tmp11
-    * print "\n"
-    * sensor *tmp12 :block @liquidCapacity
-    * print "liquidCapacity: "
-    * print *tmp12
-    * print "\n"
-    * jump *label5 always
+   18 print "contents:"
+   19 print "\n"
+   20 sensor *tmp7 :block @totalItems
+   21 print "totalItems: "
+   22 print *tmp7
+   23 print "\n"
+   24 sensor *tmp8 :block @firstItem
+   25 print "firstItem: "
+   26 print *tmp8
+   27 print "\n"
+   28 sensor *tmp9 :block @itemCapacity
+   29 print "itemCapacity: "
+   30 print *tmp9
+   31 print "\n"
+   32 sensor *tmp10 :block @totalLiquids
+   33 op floor *tmp11 *tmp10
+   34 print "totalLiquids: "
+   35 print *tmp11
+   36 print "\n"
+   37 sensor *tmp12 :block @liquidCapacity
+   38 print "liquidCapacity: "
+   39 print *tmp12
+   40 print "\n"
+   41 jump *label5 always
+   42 label *label26
+   43 jump *label11 greaterThanEq :page 3
+   44 label *label9
+   45 print "power:"
+   46 print "\n"
+   47 sensor *tmp13 :block @totalPower
+   48 op floor *tmp14 *tmp13
+   49 print "totalPower: "
+   50 print *tmp14
+   51 print "\n"
+   52 sensor *tmp15 :block @powerCapacity
+   53 print "powerCapacity: "
+   54 print *tmp15
+   55 print "\n"
+   56 sensor *tmp16 :block @powerNetStored
+   57 op floor *tmp17 *tmp16
+   58 print "powerNetStored: "
+   59 print *tmp17
+   60 print "\n"
+   61 sensor *tmp18 :block @powerNetCapacity
+   62 print "powerNetCapacity: "
+   63 print *tmp18
+   64 print "\n"
+   65 sensor *tmp19 :block @powerNetIn
+   66 op floor *tmp20 *tmp19
+   67 print "powerNetIn: "
+   68 print *tmp20
+   69 print "\n"
+   70 sensor *tmp21 :block @powerNetOut
+   71 op floor *tmp22 *tmp21
+   72 print "powerNetOut: "
+   73 print *tmp22
+   74 print "\n"
+   75 jump *label5 always
+   76 label *label25
+   77 jump *label27 greaterThanEq :page 6
+   78 jump *label15 greaterThanEq :page 5
+   79 label *label13
+   80 print "status:"
+   81 print "\n"
+   82 sensor *tmp27 :block @heat
+   83 print "heat: "
+   84 print *tmp27
+   85 print "\n"
+   86 sensor *tmp28 :block @efficiency
+   87 print "efficiency: "
+   88 print *tmp28
+   89 print "\n"
+   90 sensor *tmp29 :block @timescale
+   91 print "timescale: "
+   92 print *tmp29
+   93 print "\n"
+   94 sensor *tmp30 :block @dead
+   95 print "dead: "
+   96 print *tmp30
+   97 print "\n"
+   98 sensor *tmp31 :block @range
+   99 print "range: "
+  100 print *tmp31
+  101 print "\n"
+  102 jump *label5 always
+  103 label *label27
+  104 jump *label17 lessThan :page 7
+  105 jump *label19 lessThan :page 8
+  106 jump *label24 always
   107 label *label6
-    * jump *label8 notEqual :page 2
-    * label *label9
-    * print "power:"
-    * print "\n"
-    * sensor *tmp13 :block @totalPower
-    * op floor *tmp14 *tmp13
-    * print "totalPower: "
-    * print *tmp14
-    * print "\n"
-    * sensor *tmp15 :block @powerCapacity
-    * print "powerCapacity: "
-    * print *tmp15
-    * print "\n"
-    * sensor *tmp16 :block @powerNetStored
-    * op floor *tmp17 *tmp16
-    * print "powerNetStored: "
-    * print *tmp17
-    * print "\n"
-    * sensor *tmp18 :block @powerNetCapacity
-    * print "powerNetCapacity: "
-    * print *tmp18
-    * print "\n"
-    * sensor *tmp19 :block @powerNetIn
-    * op floor *tmp20 *tmp19
-    * print "powerNetIn: "
-    * print *tmp20
-    * print "\n"
-    * sensor *tmp21 :block @powerNetOut
-    * op floor *tmp22 *tmp21
-    * print "powerNetOut: "
-    * print *tmp22
-    * print "\n"
-    * jump *label5 always
   108 label *label8
-    * jump *label10 notEqual :page 3
   109 label *label11
   110 print "combat:"
   111 print "\n"
 
   127 print "\n"
   128 jump *label5 always
   129 label *label10
-    * jump *label12 notEqual :page 4
-    * label *label13
-    * print "status:"
-    * print "\n"
-    * sensor *tmp27 :block @heat
-    * print "heat: "
-    * print *tmp27
-    * print "\n"
-    * sensor *tmp28 :block @efficiency
-    * print "efficiency: "
-    * print *tmp28
-    * print "\n"
-    * sensor *tmp29 :block @timescale
-    * print "timescale: "
-    * print *tmp29
-    * print "\n"
-    * sensor *tmp30 :block @dead
-    * print "dead: "
-    * print *tmp30
-    * print "\n"
-    * sensor *tmp31 :block @range
-    * print "range: "
-    * print *tmp31
-    * print "\n"
-    * jump *label5 always
   130 label *label12
-    * jump *label14 notEqual :page 5
   131 label *label15
   132 print "position:"
   133 print "\n"
 
   149 print "\n"
   150 jump *label5 always
   151 label *label14
-    * jump *label16 notEqual :page 6
   152 label *label17
   153 print "unit:"
   154 print "\n"
 
   198 print "\n"
   199 jump *label5 always
   200 label *label16
-    * jump *label18 notEqual :page 7
   201 label *label19
   202 print "other:"
   203 print "\n"
 
   229 print *tmp53
   230 print "\n"
   231 label *label18
+  232 label *label24
   233 label *label5
   234 jump *label4 always
   235 label *label3

Modifications by Jumps phase, Unreachable Code Elimination, pass 3, iteration 1 (-1 instructions):
 
    14 jump *label25 greaterThanEq :page 4
    15 jump *label26 greaterThanEq :page 2
    16 jump *label24 lessThan :page 1
-    * label *label7
    17 print "contents:"
    18 print "\n"
    19 sensor *tmp7 :block @totalItems
 
    40 jump *label5 always
    41 label *label26
    42 jump *label11 greaterThanEq :page 3
-    * label *label9
    43 print "power:"
    44 print "\n"
    45 sensor *tmp13 :block @totalPower
 
    74 label *label25
    75 jump *label27 greaterThanEq :page 6
    76 jump *label15 greaterThanEq :page 5
-    * label *label13
    77 print "status:"
    78 print "\n"
    79 sensor *tmp27 :block @heat
 
   101 jump *label17 lessThan :page 7
   102 jump *label19 lessThan :page 8
   103 jump *label24 always
-    * label *label6
-    * label *label8
   104 label *label11
   105 print "combat:"
   106 print "\n"
 
   121 print *tmp26
   122 print "\n"
   123 jump *label5 always
-    * label *label10
-    * label *label12
   124 label *label15
   125 print "position:"
   126 print "\n"
 
   141 print *tmp35
   142 print "\n"
   143 jump *label5 always
-    * label *label14
   144 label *label17
   145 print "unit:"
   146 print "\n"
 
   189 print *tmp46
   190 print "\n"
   191 jump *label5 always
-    * label *label16
   192 label *label19
   193 print "other:"
   194 print "\n"
 
   219 print "solid: "
   220 print *tmp53
   221 print "\n"
-    * label *label18
   222 label *label24
   223 label *label5
   224 jump *label4 always
 
   237 label *label23
   238 control enabled switch1 false
   239 label *label20
-    * label *label21
-    * label *label1
   240 jump *label0 always
-    * label *label2
-    * end

Modifications by Jumps phase, Jump Threading, pass 3, iteration 1:
 
    13 print " - "
    14 jump *label25 greaterThanEq :page 4
    15 jump *label26 greaterThanEq :page 2
-    * jump *label24 lessThan :page 1
+   16 jump *label4 lessThan :page 1
    17 print "contents:"
    18 print "\n"
    19 sensor *tmp7 :block @totalItems
 
    37 print "liquidCapacity: "
    38 print *tmp12
    39 print "\n"
-    * jump *label5 always
+   40 jump *label4 always
    41 label *label26
    42 jump *label11 greaterThanEq :page 3
    43 print "power:"
 
    70 print "powerNetOut: "
    71 print *tmp22
    72 print "\n"
-    * jump *label5 always
+   73 jump *label4 always
    74 label *label25
    75 jump *label27 greaterThanEq :page 6
    76 jump *label15 greaterThanEq :page 5
 
    96 print "range: "
    97 print *tmp31
    98 print "\n"
-    * jump *label5 always
+   99 jump *label4 always
   100 label *label27
   101 jump *label17 lessThan :page 7
   102 jump *label19 lessThan :page 8
-    * jump *label24 always
+  103 jump *label4 always
   104 label *label11
   105 print "combat:"
   106 print "\n"
 
   120 print "maxHealth: "
   121 print *tmp26
   122 print "\n"
-    * jump *label5 always
+  123 jump *label4 always
   124 label *label15
   125 print "position:"
   126 print "\n"
 
   140 print "size: "
   141 print *tmp35
   142 print "\n"
-    * jump *label5 always
+  143 jump *label4 always
   144 label *label17
   145 print "unit:"
   146 print "\n"
 
   188 print "controller: "
   189 print *tmp46
   190 print "\n"
-    * jump *label5 always
+  191 jump *label4 always
   192 label *label19
   193 print "other:"
   194 print "\n"
 
   228 label *label4
   229 printflush message1
   230 sensor *tmp54 switch1 @enabled
-    * jump *label20 equal *tmp54 false
+  231 jump *label0 equal *tmp54 false
   232 jump *label22 notEqual :page 7
   233 set :page 1
   234 jump *label23 always

Modifications by Final phase, Print Merging, iteration 1 (-52 instructions):
 
     2 getlink :block 2
     3 print "Property detector - page "
     4 print :page
-    * print "/"
-    * print 7
-    * print "\n"
+    5 print "/7\n"
     6 sensor *tmp1 :block @dead
     7 op strictEqual *tmp2 *tmp1 0
     8 jump *label3 equal *tmp2 false
 
    12 jump *label25 greaterThanEq :page 4
    13 jump *label26 greaterThanEq :page 2
    14 jump *label4 lessThan :page 1
-    * print "contents:"
-    * print "\n"
    15 sensor *tmp7 :block @totalItems
-    * print "totalItems: "
+   16 print "contents:\ntotalItems: "
    17 print *tmp7
-    * print "\n"
    18 sensor *tmp8 :block @firstItem
-    * print "firstItem: "
+   19 print "\nfirstItem: "
    20 print *tmp8
-    * print "\n"
    21 sensor *tmp9 :block @itemCapacity
-    * print "itemCapacity: "
+   22 print "\nitemCapacity: "
    23 print *tmp9
-    * print "\n"
    24 sensor *tmp10 :block @totalLiquids
    25 op floor *tmp11 *tmp10
-    * print "totalLiquids: "
+   26 print "\ntotalLiquids: "
    27 print *tmp11
-    * print "\n"
    28 sensor *tmp12 :block @liquidCapacity
-    * print "liquidCapacity: "
+   29 print "\nliquidCapacity: "
    30 print *tmp12
    31 print "\n"
    32 jump *label4 always
    33 label *label26
    34 jump *label11 greaterThanEq :page 3
-    * print "power:"
-    * print "\n"
    35 sensor *tmp13 :block @totalPower
    36 op floor *tmp14 *tmp13
-    * print "totalPower: "
+   37 print "power:\ntotalPower: "
    38 print *tmp14
-    * print "\n"
    39 sensor *tmp15 :block @powerCapacity
-    * print "powerCapacity: "
+   40 print "\npowerCapacity: "
    41 print *tmp15
-    * print "\n"
    42 sensor *tmp16 :block @powerNetStored
    43 op floor *tmp17 *tmp16
-    * print "powerNetStored: "
+   44 print "\npowerNetStored: "
    45 print *tmp17
-    * print "\n"
    46 sensor *tmp18 :block @powerNetCapacity
-    * print "powerNetCapacity: "
+   47 print "\npowerNetCapacity: "
    48 print *tmp18
-    * print "\n"
    49 sensor *tmp19 :block @powerNetIn
    50 op floor *tmp20 *tmp19
-    * print "powerNetIn: "
+   51 print "\npowerNetIn: "
    52 print *tmp20
-    * print "\n"
    53 sensor *tmp21 :block @powerNetOut
    54 op floor *tmp22 *tmp21
-    * print "powerNetOut: "
+   55 print "\npowerNetOut: "
    56 print *tmp22
    57 print "\n"
    58 jump *label4 always
    59 label *label25
    60 jump *label27 greaterThanEq :page 6
    61 jump *label15 greaterThanEq :page 5
-    * print "status:"
-    * print "\n"
    62 sensor *tmp27 :block @heat
-    * print "heat: "
+   63 print "status:\nheat: "
    64 print *tmp27
-    * print "\n"
    65 sensor *tmp28 :block @efficiency
-    * print "efficiency: "
+   66 print "\nefficiency: "
    67 print *tmp28
-    * print "\n"
    68 sensor *tmp29 :block @timescale
-    * print "timescale: "
+   69 print "\ntimescale: "
    70 print *tmp29
-    * print "\n"
    71 sensor *tmp30 :block @dead
-    * print "dead: "
+   72 print "\ndead: "
    73 print *tmp30
-    * print "\n"
    74 sensor *tmp31 :block @range
-    * print "range: "
+   75 print "\nrange: "
    76 print *tmp31
    77 print "\n"
    78 jump *label4 always
 
    81 jump *label19 lessThan :page 8
    82 jump *label4 always
    83 label *label11
-    * print "combat:"
-    * print "\n"
    84 sensor *tmp23 :block @ammo
-    * print "ammo: "
+   85 print "combat:\nammo: "
    86 print *tmp23
-    * print "\n"
    87 sensor *tmp24 :block @ammoCapacity
-    * print "ammoCapacity: "
+   88 print "\nammoCapacity: "
    89 print *tmp24
-    * print "\n"
    90 sensor *tmp25 :block @health
-    * print "health: "
+   91 print "\nhealth: "
    92 print *tmp25
-    * print "\n"
    93 sensor *tmp26 :block @maxHealth
-    * print "maxHealth: "
+   94 print "\nmaxHealth: "
    95 print *tmp26
    96 print "\n"
    97 jump *label4 always
    98 label *label15
-    * print "position:"
-    * print "\n"
    99 sensor *tmp32 :block @rotation
-    * print "rotation: "
+  100 print "position:\nrotation: "
   101 print *tmp32
-    * print "\n"
   102 sensor *tmp33 :block @x
-    * print "x: "
+  103 print "\nx: "
   104 print *tmp33
-    * print "\n"
   105 sensor *tmp34 :block @y
-    * print "y: "
+  106 print "\ny: "
   107 print *tmp34
-    * print "\n"
   108 sensor *tmp35 :block @size
-    * print "size: "
+  109 print "\nsize: "
   110 print *tmp35
   111 print "\n"
   112 jump *label4 always
   113 label *label17
-    * print "unit:"
-    * print "\n"
   114 sensor *tmp36 :block @shootX
-    * print "shootX: "
+  115 print "unit:\nshootX: "
   116 print *tmp36
-    * print "\n"
   117 sensor *tmp37 :block @shootY
-    * print "shootY: "
+  118 print "\nshootY: "
   119 print *tmp37
-    * print "\n"
   120 sensor *tmp38 :block @shooting
-    * print "shooting: "
+  121 print "\nshooting: "
   122 print *tmp38
-    * print "\n"
   123 sensor *tmp39 :block @boosting
-    * print "boosting: "
+  124 print "\nboosting: "
   125 print *tmp39
-    * print "\n"
   126 sensor *tmp40 :block @mineX
-    * print "mineX: "
+  127 print "\nmineX: "
   128 print *tmp40
-    * print "\n"
   129 sensor *tmp41 :block @mineY
-    * print "mineY: "
+  130 print "\nmineY: "
   131 print *tmp41
-    * print "\n"
   132 sensor *tmp42 :block @mining
-    * print "mining: "
+  133 print "\nmining: "
   134 print *tmp42
-    * print "\n"
   135 sensor *tmp43 :block @payloadCount
-    * print "payloadCount: "
+  136 print "\npayloadCount: "
   137 print *tmp43
-    * print "\n"
   138 sensor *tmp44 :block @payloadType
-    * print "payloadType: "
+  139 print "\npayloadType: "
   140 print *tmp44
-    * print "\n"
   141 sensor *tmp45 :block @controlled
-    * print "controlled: "
+  142 print "\ncontrolled: "
   143 print *tmp45
-    * print "\n"
   144 sensor *tmp46 :block @controller
-    * print "controller: "
+  145 print "\ncontroller: "
   146 print *tmp46
   147 print "\n"
   148 jump *label4 always
   149 label *label19
-    * print "other:"
-    * print "\n"
   150 sensor *tmp47 :block @team
-    * print "team: "
+  151 print "other:\nteam: "
   152 print *tmp47
-    * print "\n"
-    * print "type: "
+  153 print "\ntype: "
   154 print *tmp4
-    * print "\n"
   155 sensor *tmp49 :block @flag
-    * print "flag: "
+  156 print "\nflag: "
   157 print *tmp49
-    * print "\n"
   158 sensor *tmp50 :block @name
-    * print "name: "
+  159 print "\nname: "
   160 print *tmp50
-    * print "\n"
   161 sensor *tmp51 :block @config
-    * print "config: "
+  162 print "\nconfig: "
   163 print *tmp51
-    * print "\n"
   164 sensor *tmp52 :block @enabled
-    * print "enabled: "
+  165 print "\nenabled: "
   166 print *tmp52
-    * print "\n"
   167 sensor *tmp53 :block @solid
-    * print "solid: "
+  168 print "\nsolid: "
   169 print *tmp53
   170 print "\n"
   171 jump *label4 always
   172 label *label3
-    * print "No linked block found."
-    * print "\n"
+  173 print "No linked block found.\n"
   174 label *label4
   175 printflush message1
   176 sensor *tmp54 switch1 @enabled

Final code before resolving virtual instructions:

    0:  set :page 1                                                  page = 1;
        label *label0                                                while true do
    1:  getlink :block 2                                             block = getlink(2);  // First two links are a switch and a message
    2:  print "Property detector - page "                            println($"Property detector - page $page/$NUM_PAGES");
    3:  print :page                                                  ...
    4:  print "/7\n"                                                 ...
    5:  sensor *tmp1 :block @dead                                    if block.@dead === 0 then
    6:  op strictEqual *tmp2 *tmp1 0                                 ...
    7:  jump *label3 equal *tmp2 false                               ...
    8:  sensor *tmp4 :block @type                                    print(block.@type, " - ");
    9:  print *tmp4                                                  ...
   10:  print " - "                                                  ...
   11:  jump *label25 greaterThanEq :page 4                          case page
   12:  jump *label26 greaterThanEq :page 2                          ...
   13:  jump *label4 lessThan :page 1                                ...
   14:  sensor *tmp7 :block @totalItems                              println("totalItems: ",         block.@totalItems);
   15:  print "contents:\ntotalItems: "                              ...
   16:  print *tmp7                                                  ...
   17:  sensor *tmp8 :block @firstItem                               println("firstItem: ",          block.@firstItem);
   18:  print "\nfirstItem: "                                        ...
   19:  print *tmp8                                                  ...
   20:  sensor *tmp9 :block @itemCapacity                            println("itemCapacity: ",       block.@itemCapacity);
   21:  print "\nitemCapacity: "                                     ...
   22:  print *tmp9                                                  ...
   23:  sensor *tmp10 :block @totalLiquids                           println("totalLiquids: ",       floor(block.@totalLiquids));
   24:  op floor *tmp11 *tmp10 0                                     ...
   25:  print "\ntotalLiquids: "                                     ...
   26:  print *tmp11                                                 ...
   27:  sensor *tmp12 :block @liquidCapacity                         println("liquidCapacity: ",     block.@liquidCapacity);
   28:  print "\nliquidCapacity: "                                   ...
   29:  print *tmp12                                                 ...
   30:  print "\n"                                                   ...
   31:  jump *label4 always 0 0                                      case page
        label *label26                                               ...
   32:  jump *label11 greaterThanEq :page 3                          ...
   33:  sensor *tmp13 :block @totalPower                             println("totalPower: ",         floor(block.@totalPower));
   34:  op floor *tmp14 *tmp13 0                                     ...
   35:  print "power:\ntotalPower: "                                 ...
   36:  print *tmp14                                                 ...
   37:  sensor *tmp15 :block @powerCapacity                          println("powerCapacity: ",      block.@powerCapacity);
   38:  print "\npowerCapacity: "                                    ...
   39:  print *tmp15                                                 ...
   40:  sensor *tmp16 :block @powerNetStored                         println("powerNetStored: ",     floor(block.@powerNetStored));
   41:  op floor *tmp17 *tmp16 0                                     ...
   42:  print "\npowerNetStored: "                                   ...
   43:  print *tmp17                                                 ...
   44:  sensor *tmp18 :block @powerNetCapacity                       println("powerNetCapacity: ",   block.@powerNetCapacity);
   45:  print "\npowerNetCapacity: "                                 ...
   46:  print *tmp18                                                 ...
   47:  sensor *tmp19 :block @powerNetIn                             println("powerNetIn: ",         floor(block.@powerNetIn));
   48:  op floor *tmp20 *tmp19 0                                     ...
   49:  print "\npowerNetIn: "                                       ...
   50:  print *tmp20                                                 ...
   51:  sensor *tmp21 :block @powerNetOut                            println("powerNetOut: ",        floor(block.@powerNetOut));
   52:  op floor *tmp22 *tmp21 0                                     ...
   53:  print "\npowerNetOut: "                                      ...
   54:  print *tmp22                                                 ...
   55:  print "\n"                                                   ...
   56:  jump *label4 always 0 0                                      case page
        label *label25                                               ...
   57:  jump *label27 greaterThanEq :page 6                          ...
   58:  jump *label15 greaterThanEq :page 5                          ...
   59:  sensor *tmp27 :block @heat                                   println("heat: ",               block.@heat);
   60:  print "status:\nheat: "                                      ...
   61:  print *tmp27                                                 ...
   62:  sensor *tmp28 :block @efficiency                             println("efficiency: ",         block.@efficiency);
   63:  print "\nefficiency: "                                       ...
   64:  print *tmp28                                                 ...
   65:  sensor *tmp29 :block @timescale                              println("timescale: ",          block.@timescale);
   66:  print "\ntimescale: "                                        ...
   67:  print *tmp29                                                 ...
   68:  sensor *tmp30 :block @dead                                   println("dead: ",               block.@dead);
   69:  print "\ndead: "                                             ...
   70:  print *tmp30                                                 ...
   71:  sensor *tmp31 :block @range                                  println("range: ",              block.@range);
   72:  print "\nrange: "                                            ...
   73:  print *tmp31                                                 ...
   74:  print "\n"                                                   ...
   75:  jump *label4 always 0 0                                      case page
        label *label27                                               ...
   76:  jump *label17 lessThan :page 7                               ...
   77:  jump *label19 lessThan :page 8                               ...
   78:  jump *label4 always 0 0                                      ...
        label *label11                                               ...
   79:  sensor *tmp23 :block @ammo                                   println("ammo: ",               block.@ammo);
   80:  print "combat:\nammo: "                                      ...
   81:  print *tmp23                                                 ...
   82:  sensor *tmp24 :block @ammoCapacity                           println("ammoCapacity: ",       block.@ammoCapacity);
   83:  print "\nammoCapacity: "                                     ...
   84:  print *tmp24                                                 ...
   85:  sensor *tmp25 :block @health                                 println("health: ",             block.@health);
   86:  print "\nhealth: "                                           ...
   87:  print *tmp25                                                 ...
   88:  sensor *tmp26 :block @maxHealth                              println("maxHealth: ",          block.@maxHealth);
   89:  print "\nmaxHealth: "                                        ...
   90:  print *tmp26                                                 ...
   91:  print "\n"                                                   ...
   92:  jump *label4 always 0 0                                      case page
        label *label15                                               ...
   93:  sensor *tmp32 :block @rotation                               println("rotation: ",           block.@rotation);
   94:  print "position:\nrotation: "                                ...
   95:  print *tmp32                                                 ...
   96:  sensor *tmp33 :block @x                                      println("x: ",                  block.@x);
   97:  print "\nx: "                                                ...
   98:  print *tmp33                                                 ...
   99:  sensor *tmp34 :block @y                                      println("y: ",                  block.@y);
  100:  print "\ny: "                                                ...
  101:  print *tmp34                                                 ...
  102:  sensor *tmp35 :block @size                                   println("size: ",               block.@size);
  103:  print "\nsize: "                                             ...
  104:  print *tmp35                                                 ...
  105:  print "\n"                                                   ...
  106:  jump *label4 always 0 0                                      case page
        label *label17                                               ...
  107:  sensor *tmp36 :block @shootX                                 println("shootX: ",             block.@shootX);
  108:  print "unit:\nshootX: "                                      ...
  109:  print *tmp36                                                 ...
  110:  sensor *tmp37 :block @shootY                                 println("shootY: ",             block.@shootY);
  111:  print "\nshootY: "                                           ...
  112:  print *tmp37                                                 ...
  113:  sensor *tmp38 :block @shooting                               println("shooting: ",           block.@shooting);
  114:  print "\nshooting: "                                         ...
  115:  print *tmp38                                                 ...
  116:  sensor *tmp39 :block @boosting                               println("boosting: ",           block.@boosting);
  117:  print "\nboosting: "                                         ...
  118:  print *tmp39                                                 ...
  119:  sensor *tmp40 :block @mineX                                  println("mineX: ",              block.@mineX);
  120:  print "\nmineX: "                                            ...
  121:  print *tmp40                                                 ...
  122:  sensor *tmp41 :block @mineY                                  println("mineY: ",              block.@mineY);
  123:  print "\nmineY: "                                            ...
  124:  print *tmp41                                                 ...
  125:  sensor *tmp42 :block @mining                                 println("mining: ",             block.@mining);
  126:  print "\nmining: "                                           ...
  127:  print *tmp42                                                 ...
  128:  sensor *tmp43 :block @payloadCount                           println("payloadCount: ",       block.@payloadCount);
  129:  print "\npayloadCount: "                                     ...
  130:  print *tmp43                                                 ...
  131:  sensor *tmp44 :block @payloadType                            println("payloadType: ",        block.@payloadType);
  132:  print "\npayloadType: "                                      ...
  133:  print *tmp44                                                 ...
  134:  sensor *tmp45 :block @controlled                             println("controlled: ",         block.@controlled);
  135:  print "\ncontrolled: "                                       ...
  136:  print *tmp45                                                 ...
  137:  sensor *tmp46 :block @controller                             println("controller: ",         block.@controller);
  138:  print "\ncontroller: "                                       ...
  139:  print *tmp46                                                 ...
  140:  print "\n"                                                   ...
  141:  jump *label4 always 0 0                                      case page
        label *label19                                               ...
  142:  sensor *tmp47 :block @team                                   println("team: ",               block.@team);
  143:  print "other:\nteam: "                                       ...
  144:  print *tmp47                                                 ...
  145:  print "\ntype: "                                             println("type: ",               block.@type);
  146:  print *tmp4                                                  ...
  147:  sensor *tmp49 :block @flag                                   println("flag: ",               block.@flag);
  148:  print "\nflag: "                                             ...
  149:  print *tmp49                                                 ...
  150:  sensor *tmp50 :block @name                                   println("name: ",               block.@name);
  151:  print "\nname: "                                             ...
  152:  print *tmp50                                                 ...
  153:  sensor *tmp51 :block @config                                 println("config: ",             block.@config);
  154:  print "\nconfig: "                                           ...
  155:  print *tmp51                                                 ...
  156:  sensor *tmp52 :block @enabled                                println("enabled: ",            block.@enabled);
  157:  print "\nenabled: "                                          ...
  158:  print *tmp52                                                 ...
  159:  sensor *tmp53 :block @solid                                  println("solid: ",              block.@solid);
  160:  print "\nsolid: "                                            ...
  161:  print *tmp53                                                 ...
  162:  print "\n"                                                   ...
  163:  jump *label4 always 0 0                                      if block.@dead === 0 then
        label *label3                                                ...
  164:  print "No linked block found.\n"                             println("No linked block found.");
        label *label4                                                if block.@dead === 0 then
  165:  printflush message1                                          printflush(message1);
  166:  sensor *tmp54 switch1 @enabled                               if switch1.@enabled then
  167:  jump *label0 equal *tmp54 false                              ...
  168:  jump *label22 notEqual :page 7                               page = page == NUM_PAGES ? 1 : page + 1;
  169:  set :page 1                                                  ...
  170:  jump *label23 always 0 0                                     ...
        label *label22                                               ...
  171:  op add :page :page 1                                         ...
        label *label23                                               ...
  172:  control enabled switch1 false 0 0 0                          switch1.enabled = false;
  173:  jump *label0 always 0 0                                      while true do


Code size and number of instantiations by function:
  Size  Times  AvgSize  Function
   175     1x    175,0  <no function>

Performance: parsed in 162 ms, compiled in 224 ms, optimized in 278 ms, run in 2 ms.
Error connecting to Mlog Watcher: Connection refused: connect
  - make sure Mindustry with active Mlog Watcher mod is running
  - verify Mlog Watcher listens on port 9992

Program output (6 steps):
Property detector - page 1/7

Execution exception at instruction 5: sensor *tmp1 :block @dead:
Instruction not supported by Mindcode emulator.
(Use the '#set err-unsupported-opcode = false;' directive or the '--err-unsupported-opcode false' command line option to ignore this exception.)
